/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dat.gui/build/dat.gui.module.js":
/*!******************************************************!*\
  !*** ./node_modules/dat.gui/build/dat.gui.module.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GUI: () => (/* binding */ GUI$1),
/* harmony export */   color: () => (/* binding */ color),
/* harmony export */   controllers: () => (/* binding */ controllers),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   dom: () => (/* binding */ dom$1),
/* harmony export */   gui: () => (/* binding */ gui)
/* harmony export */ });
/**
 * dat-gui JavaScript Controller Library
 * https://github.com/dataarts/dat.gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function () {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function () {
      dom.addClass(this, 'drag').bind(window, 'touchend', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);
//# sourceMappingURL=dat.gui.module.js.map


/***/ }),

/***/ "./src/shaders/equirectangular.wgsl":
/*!******************************************!*\
  !*** ./src/shaders/equirectangular.wgsl ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("const PI: f32 = 3.14159265359;\r\n\r\nstruct Face {\r\n    forward: vec3f,\r\n    up: vec3f,\r\n    right: vec3f,\r\n}\r\n\r\n@group(0)\r\n@binding(0)\r\nvar src: texture_2d<f32>;\r\n\r\n@group(0)\r\n@binding(1)\r\nvar dst: texture_storage_2d_array<rgba32float, write>;\r\n\r\n@compute\r\n@workgroup_size(16, 16, 1)\r\nfn compute_main(@builtin(global_invocation_id) gid: vec3u) {\r\n    // If texture size is not divisible by 32, we need to make sure we don't try to write to pixels that don't exist.\r\n    if gid.x >= u32(textureDimensions(dst).x) {\r\n        return;\r\n    }\r\n\r\n    let faces: array<Face, 6> = array(\r\n        // FACES +X\r\n        Face(\r\n            vec3(1.0, 0.0, 0.0),  // forward\r\n            vec3(0.0, 1.0, 0.0),  // up\r\n            vec3(0.0, 0.0, -1.0), // right\r\n        ),\r\n        // FACES -X\r\n        Face (\r\n            vec3(-1.0, 0.0, 0.0),\r\n            vec3(0.0, 1.0, 0.0),\r\n            vec3(0.0, 0.0, 1.0),\r\n        ),\r\n        // FACES +Y\r\n        Face (\r\n            vec3(0.0, -1.0, 0.0),\r\n            vec3(0.0, 0.0, 1.0),\r\n            vec3(1.0, 0.0, 0.0),\r\n        ),\r\n        // FACES -Y\r\n        Face (\r\n            vec3(0.0, 1.0, 0.0),\r\n            vec3(0.0, 0.0, -1.0),\r\n            vec3(1.0, 0.0, 0.0),\r\n        ),\r\n        // FACES +Z\r\n        Face (\r\n            vec3(0.0, 0.0, 1.0),\r\n            vec3(0.0, 1.0, 0.0),\r\n            vec3(1.0, 0.0, 0.0),\r\n        ),\r\n        // FACES -Z\r\n        Face (\r\n            vec3(0.0, 0.0, -1.0),\r\n            vec3(0.0, 1.0, 0.0),\r\n            vec3(-1.0, 0.0, 0.0),\r\n        ),\r\n    );\r\n\r\n    // Get texture coords relative to cubemap face\r\n    let dstDimensions = vec2<f32>(textureDimensions(dst));\r\n    let cubeUV = vec2<f32>(gid.xy) / dstDimensions * 2.0 - 1.0;\r\n\r\n    // Get spherical coordinate from cubeUV\r\n    let face = faces[gid.z];\r\n    let spherical = normalize(face.forward + face.right * cubeUV.x + face.up * cubeUV.y);\r\n\r\n    // Get coordinate on the equirectangular texture\r\n    let invAtan = vec2(0.1591, 0.3183);\r\n    let eqUV = vec2(atan2(spherical.z, spherical.x), asin(spherical.y)) * invAtan + 0.5;\r\n    let eqPixel = vec2<i32>(eqUV * vec2<f32>(textureDimensions(src)));\r\n\r\n    // We use textureLoad() as textureSample() is not allowed in compute shaders\r\n    let sample = textureLoad(src, eqPixel, 0);\r\n\r\n    textureStore(dst, gid.xy, gid.z, sample);\r\n}\r\n");

/***/ }),

/***/ "./src/shaders/irradiancemap.wgsl":
/*!****************************************!*\
  !*** ./src/shaders/irradiancemap.wgsl ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("const PI: f32 = 3.14159265359;\r\n\r\nstruct Face {\r\n    forward: vec3f,\r\n    up: vec3f,\r\n    right: vec3f,\r\n}\r\n\r\n@group(0)\r\n@binding(0)\r\nvar src: texture_storage_2d_array<rgba32float, read>;\r\n\r\n@group(0)\r\n@binding(1)\r\nvar dst: texture_storage_2d_array<rgba32float, write>;\r\n\r\n@compute\r\n@workgroup_size(16, 16, 1)\r\nfn compute_main(@builtin(global_invocation_id) gid: vec3u) {\r\n    // If texture size is not divisible by 32, we need to make sure we don't try to write to pixels that don't exist.\r\n    if gid.x >= u32(textureDimensions(dst).x) {\r\n        return;\r\n    }\r\n\r\n    let faces: array<Face, 6> = array(\r\n        // FACES +X\r\n        Face(\r\n            vec3(1.0, 0.0, 0.0),  // forward\r\n            vec3(0.0, 1.0, 0.0),  // up\r\n            vec3(0.0, 0.0, -1.0), // right\r\n        ),\r\n        // FACES -X\r\n        Face (\r\n            vec3(-1.0, 0.0, 0.0),\r\n            vec3(0.0, 1.0, 0.0),\r\n            vec3(0.0, 0.0, 1.0),\r\n        ),\r\n        // FACES +Y\r\n        Face (\r\n            vec3(0.0, -1.0, 0.0),\r\n            vec3(0.0, 0.0, 1.0),\r\n            vec3(1.0, 0.0, 0.0),\r\n        ),\r\n        // FACES -Y\r\n        Face (\r\n            vec3(0.0, 1.0, 0.0),\r\n            vec3(0.0, 0.0, -1.0),\r\n            vec3(1.0, 0.0, 0.0),\r\n        ),\r\n        // FACES +Z\r\n        Face (\r\n            vec3(0.0, 0.0, 1.0),\r\n            vec3(0.0, 1.0, 0.0),\r\n            vec3(1.0, 0.0, 0.0),\r\n        ),\r\n        // FACES -Z\r\n        Face (\r\n            vec3(0.0, 0.0, -1.0),\r\n            vec3(0.0, 1.0, 0.0),\r\n            vec3(-1.0, 0.0, 0.0),\r\n        ),\r\n    );\r\n\r\n    // Get texture coords relative to cubemap face\r\n    let dstDimensions = vec2<f32>(textureDimensions(dst));\r\n    let cubeUV = vec2<f32>(gid.xy) / dstDimensions * 2.0 - 1.0;\r\n\r\n    // Get spherical coordinate from cubeUV\r\n    let face = faces[gid.z];\r\n    let spherical = normalize(face.forward + face.right * cubeUV.x + face.up * cubeUV.y);\r\n\r\n    var irradiance = vec3(0.0);   \r\n    \r\n    // tangent space calculation from origin point\r\n    var up    = vec3(0.0, 1.0, 0.0);\r\n    let right = normalize(cross(up, spherical));\r\n    up = normalize(cross(spherical, right));\r\n\r\n    let invAtan = vec2(0.1591, 0.3183);\r\n\r\n    let sampleDelta = 0.025;\r\n    var nrSamples = 0;\r\n    for(var phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\r\n    {\r\n        for(var theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\r\n        {\r\n            // spherical to cartesian (in tangent space)\r\n            let tangentSample = vec3f(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\r\n            // tangent space to world\r\n            let sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * spherical;\r\n            let eqUV = vec2(atan2(sampleVec.z, sampleVec.x), asin(sampleVec.y)) * invAtan + 0.5;\r\n            let eqPixel = vec2<i32>(eqUV * vec2<f32>(textureDimensions(src)));\r\n            // We use textureLoad() as textureSample() is not allowed in compute shaders\r\n            irradiance += textureLoad(src, eqPixel, gid.z).rgb * cos(theta) * sin(theta);\r\n            nrSamples++;\r\n        }\r\n    }\r\n    irradiance = PI * irradiance * (1.0 / f32(nrSamples));\r\n\r\n    textureStore(dst, gid.xy, gid.z, vec4f(irradiance, 1.0));\r\n}\r\n");

/***/ }),

/***/ "./src/shaders/mipmap.wgsl":
/*!*********************************!*\
  !*** ./src/shaders/mipmap.wgsl ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\r\nstruct VertexInput {\r\n  @location(0) position: vec4f,\r\n  @location(1) texCoord: vec2f,\r\n};\r\n\r\nstruct VertexOut {\r\n  @builtin(position) position: vec4f,\r\n  @location(0) texCoord: vec2f,\r\n};\r\n\r\n@vertex\r\nfn vs_main(vertData: VertexInput) -> VertexOut {\r\n  var out: VertexOut;\r\n  out.position = vec4f(vertData.position);\r\n  out.texCoord = vertData.texCoord;\r\n  return out;\r\n}\r\n\r\n@group(0) @binding(0) var mySampler: sampler;\r\n@group(0) @binding(1) var myTexture: texture_2d<f32>;\r\n\r\n@fragment \r\nfn fs_main(fragData: VertexOut) -> @location(0) vec4f {\r\n  return textureSample(myTexture, mySampler, fragData.texCoord);\r\n}\r\n");

/***/ }),

/***/ "./src/shaders/shader.wgsl":
/*!*********************************!*\
  !*** ./src/shaders/shader.wgsl ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("struct VertexInput {\r\n  @location(0) position : vec3f,\r\n  @location(1) texCoord : vec2f,\r\n  @location(2) normal : vec3f\r\n};\r\n\r\nstruct VertexOut {\r\n  @builtin(position) position : vec4f,\r\n  @location(0) texCoord : vec2f,\r\n  @location(1) normal : vec3f,\r\n  @location(2) pos: vec3f,\r\n};\r\n\r\nstruct Transform {\r\n  model: mat4x4f,\r\n  normal: mat4x4f,\r\n  view: mat4x4f,\r\n  projection: mat4x4f,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> transform: Transform;\r\n@group(0) @binding(1) var<uniform> viewPos: vec3f;\r\n@group(0) @binding(2) var<uniform> lightPositions: array<vec3f, 4>;\r\n@group(0) @binding(3) var<uniform> lightColors: array<vec3f, 4>;\r\n@group(1) @binding(0) var albedoMap: texture_2d<f32>;\r\n@group(1) @binding(1) var metallicRoughnessMap: texture_2d<f32>;\r\n@group(1) @binding(2) var normalMap: texture_2d<f32>;\r\n@group(1) @binding(3) var<uniform> emissiveFactor: vec3f;\r\n@group(1) @binding(4) var emissiveMap: texture_2d<f32>;\r\n@group(1) @binding(5) var occlusionMap: texture_2d<f32>;\r\n@group(2) @binding(0) var irradianceMap: texture_cube<f32>;\r\n@group(3) @binding(0) var sampler2D: sampler;\r\n@group(3) @binding(1) var samplerCube: sampler;\r\n\r\n@vertex\r\nfn vs_main(vertData: VertexInput) -> VertexOut {\r\n  var output: VertexOut;\r\n\r\n  output.position = transform.projection * transform.view * transform.model * vec4f(vertData.position, 1.0);\r\n  output.texCoord = vertData.texCoord;\r\n  output.normal = (transform.normal * vec4f(vertData.normal, 0.0)).xyz;\r\n  output.pos = (transform.normal * vec4f(vertData.position, 0.0)).xyz;\r\n\r\n  return output;\r\n}\r\n\r\nconst PI = 3.14159265359;\r\n\r\n// D: Normal Distribution Function\r\nfn TrowbridgeReitzGGX(normal: vec3f, halfwayDir: vec3f, roughness: f32) -> f32 {\r\n  let a = roughness * roughness;\r\n  let a2 = a * a;\r\n  let NdotH = max(dot(normal, halfwayDir), 0.0);\r\n  let NdotH2 = NdotH * NdotH;\r\n\r\n  let numerator = a2;\r\n  var denominator = (NdotH2 * (a2 - 1.0) + 1.0);\r\n  denominator = PI * denominator * denominator;\r\n\r\n  return numerator / denominator; \r\n}\r\n\r\n// F: Fresnel Equation\r\nfn FresnelSchlickApproximation(cosTheta: f32, f0: vec3f, roughness: f32) -> vec3f {\r\n  return f0 + (max(vec3f(1.0 -roughness), f0) - f0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\r\n}\r\n\r\n// G: Geometry Function\r\nfn GeometrySmith(normal: vec3f, viewDir: vec3f, lightDir: vec3f, roughness: f32) -> f32 {\r\n  let NdotV = max(dot(normal, viewDir), 0.0);\r\n  let ggx1 = GeometrySmithGGX(NdotV, roughness);\r\n  let NdotL = max(dot(normal, lightDir), 0.0);\r\n  let ggx2 = GeometrySmithGGX(NdotL, roughness);\r\n\r\n  return ggx1 * ggx2;\r\n}\r\n\r\nfn GeometrySmithGGX(cosTheta: f32, roughness: f32) -> f32 {\r\n  let r = (roughness + 1.0);\r\n  let k = (r * r) / 8.0;\r\n\r\n  let numerator = cosTheta;\r\n  let denominator = (cosTheta * (1.0 - k) + k);\r\n\r\n  return numerator / denominator;\r\n}\r\n\r\n// ACES: Academy Color Encoding System\r\nfn ToneMapACES(hdr: vec3f) -> vec3f {\r\n    let m1 = mat3x3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777,\r\n    );\r\n    let m2 = mat3x3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602,\r\n    );\r\n    let v = m1 * hdr;\r\n    let a = v * (v + 0.0245786) - 0.000090537;\r\n    let b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n    return clamp(m2 * (a / b), vec3(0.0), vec3(1.0));\r\n}\r\n\r\n\r\n@fragment\r\nfn fs_main(fragData: VertexOut) -> @location(0) vec4f {\r\n  let albedo = textureSample(albedoMap, sampler2D, fragData.texCoord).rgb;\r\n  var normal = textureSample(normalMap, sampler2D, fragData.texCoord).xyz * 2.0 - 1.0;\r\n  let q1 = dpdx(fragData.pos);\r\n  let q2 = dpdy(fragData.pos);\r\n  let st1 = dpdx(fragData.texCoord);\r\n  let st2 = dpdy(fragData.texCoord);\r\n  let N = normalize(fragData.normal);\r\n  let T = normalize(q1 * st2.y - q2 * st1.y);\r\n  let B = -normalize(cross(N, T));\r\n  let TBN = mat3x3f(T, B, N);\r\n  normal = normalize(TBN * normal);\r\n  let metalness = textureSample(metallicRoughnessMap, sampler2D, fragData.texCoord).b;\r\n  let roughness = textureSample(metallicRoughnessMap, sampler2D, fragData.texCoord).g;\r\n  let emissive = textureSample(emissiveMap, sampler2D, fragData.texCoord).rgb * emissiveFactor;\r\n  let occlusion = textureSample(occlusionMap, sampler2D, fragData.texCoord).r;\r\n\r\n  let viewDir = normalize(viewPos - fragData.pos);\r\n  var f0 = vec3f(0.04);\r\n  f0 = mix(f0, albedo, metalness);\r\n\r\n  // relflectance equation\r\n  var Lo = vec3f(0.0);\r\n\r\n  for(var i = 0; i < 4; i++) {\r\n    let lightDir = normalize(lightPositions[i] - fragData.pos);\r\n    let halfwayDir = normalize(viewDir + lightDir);\r\n    let distance = length(lightPositions[i] - fragData.pos);\r\n    let attenuation = 1.0 / pow(distance, 2.0);\r\n    let radiance = lightColors[i] * attenuation;\r\n\r\n    // BRDF: Cook-Torrance\r\n    let D = TrowbridgeReitzGGX(normal, halfwayDir, roughness);\r\n    let F = FresnelSchlickApproximation(max(dot(halfwayDir, viewDir), 0.0), f0, roughness);\r\n    let G = GeometrySmith(normal, viewDir, lightDir, roughness);\r\n\r\n    let kS = F;\r\n    var kD = vec3f(1.0) - kS;\r\n    kD *= 1.0 - metalness;\r\n\r\n    let numerator = D * F * G;\r\n    let denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(dot(normal, lightDir), 0.0) + 0.001;\r\n    let specular = numerator / denominator;\r\n\r\n    Lo += (kD * albedo / PI + specular) * radiance * dot(normal, lightDir);\r\n  }\r\n\r\n  let kS = FresnelSchlickApproximation(max(dot(normal, viewDir), 0.0), f0, roughness);\r\n  var kD = vec3f(1.0) - kS;\r\n  kD *= 1.0 - metalness;\r\n  let irradiance = textureSample(irradianceMap, samplerCube, normal).rgb;\r\n  let diffuse  = irradiance * albedo;\r\n  let ambient =( kD * diffuse) * occlusion;\r\n\r\n  var color = vec3f(0.03) * occlusion + Lo + emissive;\r\n  // HDR Tone Mapping\r\n  color = ToneMapACES(color);\r\n  // Gamma Correction\r\n  color = pow(color, vec3f(1.0 / 2.2));\r\n\r\n  return vec4f(color, 1.0);\r\n}\r\n");

/***/ }),

/***/ "./src/shaders/skybox.wgsl":
/*!*********************************!*\
  !*** ./src/shaders/skybox.wgsl ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("struct VertexOut {\r\n  @builtin(position) position : vec4f,\r\n  @location(0) pos: vec4f,\r\n};\r\n\r\n\r\n@group(0) @binding(0) var<uniform> matrix: mat4x4f;\r\n@group(0) @binding(1) var cubeSampler: sampler;\r\n@group(1) @binding(0) var cubeTexture: texture_cube<f32>;\r\n\r\n\r\n@vertex\r\nfn vs_main(@builtin(vertex_index)  vertexIndex: u32) -> VertexOut {\r\n  let positions = array(vec2f(-1, 3), vec2f(-1,-1), vec2f(3, -1));\r\n\r\n  var output: VertexOut;\r\n\r\n  output.position = vec4f(positions[vertexIndex], 1.0, 1.0);\r\n  output.pos = output.position;\r\n\r\n  return output;\r\n}\r\n\r\n// ACES: Academy Color Encoding System\r\nfn ToneMapACES(hdr: vec3f) -> vec3f {\r\n    let m1 = mat3x3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777,\r\n    );\r\n    let m2 = mat3x3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602,\r\n    );\r\n    let v = m1 * hdr;\r\n    let a = v * (v + 0.0245786) - 0.000090537;\r\n    let b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n    return clamp(m2 * (a / b), vec3(0.0), vec3(1.0));\r\n}\r\n\r\n@fragment\r\nfn fs_main(fragData: VertexOut) -> @location(0) vec4f {\r\n  let texCoord = matrix * fragData.pos;\r\n  // WebGPU uses a right-handed coordinate system, but cubemaps are an exception, using a left-handed coordinate system\r\n  var color = textureSample(cubeTexture, cubeSampler, normalize(texCoord.xyz / texCoord.w) * vec3f(1, 1, -1)).rgb;\r\n  // HDR Tone Mapping\r\n  color = ToneMapACES(color);\r\n  // Gamma Correction\r\n  color = pow(color, vec3f(1.0/2.2));\r\n\r\n  return vec4f(color, 1.0);\r\n}\r\n");

/***/ }),

/***/ "./src/camera.ts":
/*!***********************!*\
  !*** ./src/camera.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wgpu-matrix */ "./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");

var MoveMode;
(function (MoveMode) {
    MoveMode["NONE"] = "None";
    MoveMode["TUMBLE"] = "Tumble";
    MoveMode["TRACK"] = "Track";
    MoveMode["DOLLY"] = "Dolly";
})(MoveMode || (MoveMode = {}));
var Camera = /** @class */ (function () {
    function Camera() {
        var _this = this;
        this.controlled = false;
        this.moveMode = MoveMode.NONE;
        this.rotateAmplitude = 0.1;
        this.panAmplitude = 0.01;
        this.scrollAmplitude = 0.01;
        this.x = 0;
        this.y = 0;
        this.pitch = 0.0;
        this.yaw = 0.0;
        this.distance = 5.0;
        this.target = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(0.0, 0.0, 0.0);
        this.eye = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(0.0, 0.0, 5.0);
        this.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(0.0, 1.0, 0.0);
        this.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(1.0, 0.0, 0.0);
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        document.addEventListener("contextmenu", function (event) {
            if (_this.controlled) {
                event.preventDefault();
            }
        });
        document.addEventListener("keydown", this.onKeyDown);
        document.addEventListener("keyup", this.onKeyUp);
        document.addEventListener("mousedown", this.onMouseDown);
        document.addEventListener("mouseup", this.onMouseUp);
        document.addEventListener("mousemove", this.onMouseMove);
        this.div = document.createElement("div");
        this.div.setAttribute("style", "position: absolute; top: 10px; left: 10px; width: 200px; color: white; font-size: 16px; font-weight: bold;");
        var body = document.querySelector("body");
        if (body) {
            body.appendChild(this.div);
        }
    }
    Object.defineProperty(Camera.prototype, "view", {
        get: function () {
            return wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.lookAt(this.eye, this.target, this.up);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "position", {
        get: function () {
            return this.eye;
        },
        enumerable: false,
        configurable: true
    });
    Camera.prototype.onKeyDown = function (event) {
        switch (event.key) {
            case "Alt":
                this.controlled = true;
                break;
            default:
                break;
        }
    };
    Camera.prototype.onKeyUp = function (event) {
        switch (event.key) {
            case "Alt":
                this.controlled = false;
                this.div.innerText = "";
                break;
            default:
                break;
        }
    };
    Camera.prototype.onMouseDown = function (event) {
        if (!this.controlled) {
            return;
        }
        this.x = event.clientX;
        this.y = event.clientY;
        switch (event.button) {
            case 0:
                this.moveMode = MoveMode.TUMBLE;
                this.div.innerText = "Tumble: Alt + LMB";
                break;
            case 1:
                this.moveMode = MoveMode.TRACK;
                this.div.innerText = "Track: Alt + MMB";
                break;
            case 2:
                this.moveMode = MoveMode.DOLLY;
                this.div.innerText = "Dolly: Alt + RMB";
                break;
            default:
                this.moveMode = MoveMode.NONE;
                this.div.innerText = "";
                break;
        }
    };
    Camera.prototype.onMouseUp = function () {
        if (!this.controlled) {
            return;
        }
        this.moveMode = MoveMode.NONE;
    };
    Camera.prototype.onMouseMove = function (event) {
        if (!this.controlled || MoveMode.NONE === this.moveMode) {
            return;
        }
        var deltaX = event.clientX - this.x;
        this.x = event.clientX;
        var deltaY = event.clientY - this.y;
        this.y = event.clientY;
        switch (this.moveMode) {
            case MoveMode.TUMBLE:
                this.updateCameraRotation(deltaX, deltaY);
                break;
            case MoveMode.DOLLY:
                this.updateCameraDistance(deltaX, deltaY);
                break;
            case MoveMode.TRACK:
                this.updateCameraTarget(deltaX, deltaY);
                break;
            default:
                break;
        }
    };
    Camera.prototype.updateCameraRotation = function (deltaX, deltaY) {
        this.target = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(0.0, 0.0, 0.0);
        this.yaw = -deltaX * this.rotateAmplitude;
        this.pitch = -deltaY * this.rotateAmplitude;
        var quatYaw = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.quat.fromAxisAngle(this.up, wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.utils.degToRad(this.yaw));
        var back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(this.eye, this.target));
        this.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformQuat(wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(this.up, back), quatYaw);
        var quatPitch = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.quat.fromAxisAngle(this.right, wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.utils.degToRad(this.pitch));
        var rotation = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.quat.mul(quatYaw, quatPitch);
        var newBack = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.transformQuat(back, rotation);
        this.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.cross(newBack, this.right));
        this.eye = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.add(this.target, wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.mulScalar(newBack, this.distance));
    };
    Camera.prototype.updateCameraDistance = function (deltaX, deltaY) {
        this.distance -= (deltaX + deltaY) * this.scrollAmplitude;
        var back = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.sub(this.eye, this.target));
        this.eye = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.add(this.target, wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.mulScalar(back, this.distance));
    };
    Camera.prototype.updateCameraTarget = function (deltaX, deltaY) {
        var panOffset = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(0.0, 0.0, 0.0);
        panOffset = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.addScaled(panOffset, this.right, -deltaX * this.panAmplitude);
        panOffset = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.addScaled(panOffset, this.up, deltaY * this.panAmplitude);
        this.target = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.add(this.target, panOffset);
        this.eye = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.add(this.eye, panOffset);
    };
    return Camera;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Camera);


/***/ }),

/***/ "./src/glTF.ts":
/*!*********************!*\
  !*** ./src/glTF.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComponentCount: () => (/* binding */ ComponentCount),
/* harmony export */   ComponentType: () => (/* binding */ ComponentType),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ "./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var ComponentType = {
    5120: "sint8",
    5121: "uint8",
    5122: "sint16",
    5123: "uint16",
    5125: "uint32",
    5126: "float32",
};
var ComponentCount = {
    SCALAR: "",
    VEC2: "x2",
    VEC3: "x3",
    VEC4: "x4",
    MAT2: "x8",
    MAT3: "x12",
    MAT4: "x16",
};
var glTFLoader = /** @class */ (function () {
    function glTFLoader() {
        this.loadBinBuffer = this.loadBinBuffer.bind(this);
    }
    glTFLoader.prototype.load = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var index;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        index = url.lastIndexOf("/");
                        this.pathname = url.slice(0, index + 1);
                        return [4 /*yield*/, this.loadJSON(url)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.loadBinBuffers()];
                    case 2:
                        _a.sent();
                        this.generateGeometries();
                        return [2 /*return*/];
                }
            });
        });
    };
    glTFLoader.prototype.getGeometries = function () {
        return this.geometries;
    };
    glTFLoader.prototype.loadJSON = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var res, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, fetch(url)];
                    case 1:
                        res = _b.sent();
                        if (!res.ok) {
                            throw new Error("Failed to fetch .gltf file: ".concat(url));
                        }
                        _a = this;
                        return [4 /*yield*/, res.json()];
                    case 2:
                        _a.gltf = _b.sent();
                        if ("2.0" !== this.gltf.asset.version) {
                            throw new Error("Unsupported glTF version: ".concat(this.gltf.asset.version));
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    glTFLoader.prototype.loadBinBuffers = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, Promise.all(this.gltf.buffers.map(this.loadBinBuffer))];
                    case 1:
                        _a.buffers = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    glTFLoader.prototype.loadBinBuffer = function (buffer) {
        return __awaiter(this, void 0, void 0, function () {
            var res, arrayBuffer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch(this.pathname + buffer.uri)];
                    case 1:
                        res = _a.sent();
                        if (!res.ok) {
                            throw new Error("Failed to fetch .bin file: ".concat(buffer.uri));
                        }
                        return [4 /*yield*/, res.arrayBuffer()];
                    case 2:
                        arrayBuffer = _a.sent();
                        if (arrayBuffer.byteLength !== buffer.byteLength) {
                            throw new Error("Wrong buffer byte length.");
                        }
                        return [2 /*return*/, arrayBuffer];
                }
            });
        });
    };
    glTFLoader.prototype.generateGeometries = function () {
        var _this = this;
        var nodes = this.gltf.nodes;
        this.geometries = new Array(nodes.length);
        nodes.forEach(function (node, index) {
            var model;
            if ("matrix" in node) {
                model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.create.apply(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4, node.matrix);
            }
            else {
                model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.identity();
                if ("scale" in node) {
                    model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.scale(model, wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create.apply(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3, node.scale));
                }
                if ("translation" in node) {
                    model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.translate(model, wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create.apply(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3, node.translation));
                }
                if ("rotation" in node) {
                    var q = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.quat.fromValues.apply(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.quat, node.rotation);
                    model = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.mul(model, wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.fromQuat(q));
                }
            }
            var mesh = _this.gltf.meshes[node.mesh];
            mesh.primitives.map(function (primitive) {
                if ("mode" in primitive && 4 !== primitive.mode) {
                    return;
                }
                // positions
                var positionAccessor = _this.gltf.accessors[primitive.attributes.POSITION];
                var positionType = (ComponentType[positionAccessor.componentType] +
                    ComponentCount[positionAccessor.type]);
                var positionOffset = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.calculateByteLength)();
                var positionBufferview = _this.gltf.bufferViews[positionAccessor.bufferView];
                var positionBuffer = new Float32Array(_this.buffers[positionBufferview.buffer], positionBufferview.byteOffset, positionBufferview.byteLength / Float32Array.BYTES_PER_ELEMENT);
                // texture coordinates
                var texCoordAccessor = _this.gltf.accessors[primitive.attributes.TEXCOORD_0];
                var texCoordType = (ComponentType[texCoordAccessor.componentType] +
                    ComponentCount[texCoordAccessor.type]);
                var texCoordOffset = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.calculateByteLength)(positionType);
                var texCoordBufferview = _this.gltf.bufferViews[texCoordAccessor.bufferView];
                var texCoordlBuffer = new Float32Array(_this.buffers[texCoordBufferview.buffer], texCoordBufferview.byteOffset, texCoordBufferview.byteLength / Float32Array.BYTES_PER_ELEMENT);
                // normals
                var normalAccessor = _this.gltf.accessors[primitive.attributes.NORMAL];
                var normalType = (ComponentType[normalAccessor.componentType] +
                    ComponentCount[normalAccessor.type]);
                var normalOffset = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.calculateByteLength)(positionType) + (0,_utils__WEBPACK_IMPORTED_MODULE_0__.calculateByteLength)(texCoordType);
                var normalBufferview = _this.gltf.bufferViews[normalAccessor.bufferView];
                var normalBuffer = new Float32Array(_this.buffers[normalBufferview.buffer], normalBufferview.byteOffset, normalBufferview.byteLength / Float32Array.BYTES_PER_ELEMENT);
                var arrayStride = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.calculateByteLength)(positionType) +
                    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.calculateByteLength)(texCoordType) +
                    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.calculateByteLength)(normalType);
                // vertices array
                var vertices = new Float32Array((positionAccessor.count * arrayStride) /
                    Float32Array.BYTES_PER_ELEMENT);
                var pOffset = 0;
                var nOffset = 0;
                var tOffset = 0;
                var stride = 8;
                for (var i = 0; i < positionAccessor.count; ++i) {
                    var position = [
                        positionBuffer[pOffset++],
                        positionBuffer[pOffset++],
                        positionBuffer[pOffset++],
                    ];
                    vertices.set(position, stride * i);
                    var texCoord = [
                        texCoordlBuffer[tOffset++],
                        texCoordlBuffer[tOffset++],
                    ];
                    vertices.set(texCoord, stride * i + 3);
                    var normal = [
                        normalBuffer[nOffset++],
                        normalBuffer[nOffset++],
                        normalBuffer[nOffset++],
                    ];
                    vertices.set(normal, stride * i + 5);
                }
                // indices
                var indexAccessor = _this.gltf.accessors[primitive.indices];
                var indexBufferView = _this.gltf.bufferViews[indexAccessor.bufferView];
                var indexBuffer = _this.buffers[indexBufferView.buffer];
                // indices array
                var indices = new Uint16Array(indexBuffer, indexBufferView.byteOffset, indexBufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                var material = _this.gltf.materials[primitive.material];
                // base color texture
                var bcTerxtureIndex = material.pbrMetallicRoughness.baseColorTexture.index;
                var bcImageIndex = _this.gltf.textures[bcTerxtureIndex].source;
                var baseColorURI = _this.pathname + _this.gltf.images[bcImageIndex].uri;
                // metallic roughness texture
                var mrTextureIndex = material.pbrMetallicRoughness.metallicRoughnessTexture.index;
                var mrImageIndex = _this.gltf.textures[mrTextureIndex].source;
                var metallicRoughnessURI = _this.pathname + _this.gltf.images[mrImageIndex].uri;
                // normal texture
                var nTextureIndex = material.normalTexture.index;
                var nImageIndex = _this.gltf.textures[nTextureIndex].source;
                var normalURI = _this.pathname + _this.gltf.images[nImageIndex].uri;
                // emissive factor texture
                var emissive = material.emissiveFactor;
                var eTextureIndex = material.emissiveTexture.index;
                var eImageIndex = _this.gltf.textures[eTextureIndex].source;
                var emissiveURI = _this.pathname + _this.gltf.images[eImageIndex].uri;
                // occlusion texture
                var oTextureIndex = material.occlusionTexture.index;
                var oImageIndex = _this.gltf.textures[oTextureIndex].source;
                var occlusionURI = _this.pathname + _this.gltf.images[oImageIndex].uri;
                _this.geometries[index] = {
                    model: model,
                    vertices: vertices,
                    arrayStride: arrayStride,
                    position: {
                        format: positionType,
                        offset: positionOffset,
                    },
                    normal: {
                        format: normalType,
                        offset: normalOffset,
                    },
                    texCoord: {
                        format: texCoordType,
                        offset: texCoordOffset,
                    },
                    indices: indices,
                    textures: {
                        baseColorURI: baseColorURI,
                        metallicRoughnessURI: metallicRoughnessURI,
                        normalURI: normalURI,
                        emissive: emissive,
                        emissiveURI: emissiveURI,
                        occlusionURI: occlusionURI,
                    },
                };
            });
        });
    };
    return glTFLoader;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (glTFLoader);


/***/ }),

/***/ "./src/hdr.ts":
/*!********************!*\
  !*** ./src/hdr.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var HDRLoader = /** @class */ (function () {
    function HDRLoader() {
    }
    Object.defineProperty(HDRLoader.prototype, "hdr", {
        get: function () {
            return {
                width: this.width,
                height: this.height,
                data: this.data,
            };
        },
        enumerable: false,
        configurable: true
    });
    HDRLoader.prototype.load = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loadBuffer(url)];
                    case 1:
                        _a.sent();
                        this.parseHDR();
                        return [2 /*return*/];
                }
            });
        });
    };
    HDRLoader.prototype.loadBuffer = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var res, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, fetch(url)];
                    case 1:
                        res = _b.sent();
                        if (!res.ok) {
                            throw new Error("Failed to fetch .hdr file: ".concat(url));
                        }
                        _a = this;
                        return [4 /*yield*/, res.arrayBuffer()];
                    case 2:
                        _a.buffer = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    HDRLoader.prototype.parseHDR = function () {
        var bytes = new Uint8Array(this.buffer);
        // HDR header
        var decoder = new TextDecoder("ascii");
        var index = 0;
        var header = "";
        while (index < bytes.length) {
            var char = decoder.decode(bytes.slice(index, index + 1));
            header += char;
            index++;
            if (char === "\n" && header.includes("-Y ") && header.includes(" +X ")) {
                break;
            }
        }
        if (!header.includes("32-bit_rle_rgbe") &&
            !header.includes("32-bit_rle_xyze")) {
            throw new Error("HDRLoader: Unsupported .hdr format.");
        }
        var resolution = header.match(/-Y (\d+) \+X (\d+)/);
        if (!resolution) {
            throw new Error("HDRLoader: No resolution found.");
        }
        this.width = parseInt(resolution[2]);
        this.height = parseInt(resolution[1]);
        // HDR pixel bytes
        this.data = new Float32Array(this.width * this.height * 4);
        var currentPixel = 0;
        while (index < bytes.length) {
            var scanlineHeader = bytes.slice(index, index + 4);
            index += 4;
            if (scanlineHeader[0] !== 2 ||
                scanlineHeader[1] !== 2 ||
                (scanlineHeader[2] << 8) + scanlineHeader[3] !== this.width) {
                throw new Error("HDRLoader: Only support RLE format.");
            }
            var scanline = new Uint8Array(this.width * 4);
            for (var i = 0; i < 4; i++) {
                var position = 0;
                while (position < this.width) {
                    var count = bytes[index++];
                    if (count > 128) {
                        var runLength = count - 128;
                        var value = bytes[index++];
                        for (var j = 0; j < runLength; j++) {
                            scanline[i + position * 4] = value;
                            position++;
                        }
                    }
                    else {
                        for (var j = 0; j < count; j++) {
                            scanline[i + position * 4] = bytes[index++];
                            position++;
                        }
                    }
                }
            }
            for (var x = 0; x < this.width; x++) {
                var r = scanline[x * 4];
                var g = scanline[x * 4 + 1];
                var b = scanline[x * 4 + 2];
                var e = scanline[x * 4 + 3];
                var scale = Math.pow(2, e - 128) / 255;
                this.data[currentPixel++] = r * scale;
                this.data[currentPixel++] = g * scale;
                this.data[currentPixel++] = b * scale;
                this.data[currentPixel++] = 1.0;
            }
        }
    };
    return HDRLoader;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HDRLoader);


/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _shaders_shader_wgsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/shaders/shader.wgsl */ "./src/shaders/shader.wgsl");
/* harmony import */ var _shaders_mipmap_wgsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/shaders/mipmap.wgsl */ "./src/shaders/mipmap.wgsl");
/* harmony import */ var _shaders_skybox_wgsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/shaders/skybox.wgsl */ "./src/shaders/skybox.wgsl");
/* harmony import */ var _shaders_equirectangular_wgsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/shaders/equirectangular.wgsl */ "./src/shaders/equirectangular.wgsl");
/* harmony import */ var _shaders_irradiancemap_wgsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/shaders/irradiancemap.wgsl */ "./src/shaders/irradiancemap.wgsl");
/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! wgpu-matrix */ "./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js");
/* harmony import */ var dat_gui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! dat.gui */ "./node_modules/dat.gui/build/dat.gui.module.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/utils */ "./src/utils.ts");
/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/camera */ "./src/camera.ts");
/* harmony import */ var _glTF__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/glTF */ "./src/glTF.ts");
/* harmony import */ var _hdr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/hdr */ "./src/hdr.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};











var fpsAvg = new _utils__WEBPACK_IMPORTED_MODULE_6__.RollingAverage();
var cpuTimeAvg = new _utils__WEBPACK_IMPORTED_MODULE_6__.RollingAverage();
var gpuTimeAvg = new _utils__WEBPACK_IMPORTED_MODULE_6__.RollingAverage();
var Renderer = /** @class */ (function () {
    function Renderer() {
        this.camera = new _camera__WEBPACK_IMPORTED_MODULE_7__["default"]();
        this.depthTextures = new Array(2);
        this.depthTextureViews = new Array(2);
        this.renderPipelines = new Array(2);
        this.bindGroups = new Array(new Array(), new Array(), new Array(), new Array());
        this.skyboxRenderPipelines = new Array(2);
        this.skyboxBindGroups = new Array(new Array(), new Array(), new Array());
        this.current = 0;
        this.drawFrame = this.drawFrame.bind(this);
    }
    Renderer.prototype.render = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.init()];
                    case 1:
                        _a.sent();
                        this.run();
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.checkWebGPUSupport();
                        return [4 /*yield*/, this.requestAdapter()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.requestDevice()];
                    case 2:
                        _a.sent();
                        this.getCanvas();
                        this.configContext();
                        this.createMultisamplingTexture();
                        this.createDepthTextures();
                        return [4 /*yield*/, this.loadModel()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.loadHDR()];
                    case 4:
                        _a.sent();
                        this.createRenderPipeline();
                        this.createVertexBuffer();
                        this.createIndexBuffer();
                        this.createUniformBuffer();
                        return [4 /*yield*/, this.createTexture()];
                    case 5:
                        _a.sent();
                        this.createSkyboxRenderPipeline();
                        return [4 /*yield*/, this.createSkyboxUniformBuffer()];
                    case 6:
                        _a.sent();
                        this.initGUI();
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.checkWebGPUSupport = function () {
        if (!navigator.gpu) {
            throw new Error("WebGPU not supported.");
        }
    };
    Renderer.prototype.requestAdapter = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, ((_b = navigator.gpu) === null || _b === void 0 ? void 0 : _b.requestAdapter())];
                    case 1:
                        _a.adapter = _c.sent();
                        if (!this.adapter) {
                            throw new Error("Failed to request WebGPU adapter.");
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.requestDevice = function () {
        return __awaiter(this, void 0, void 0, function () {
            var requiredFeatures, _a;
            var _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        this.hasTimestamp = (_b = this.adapter) === null || _b === void 0 ? void 0 : _b.features.has("timestamp-query");
                        requiredFeatures = this.hasTimestamp
                            ? ["timestamp-query"]
                            : [];
                        _a = this;
                        return [4 /*yield*/, ((_c = this.adapter) === null || _c === void 0 ? void 0 : _c.requestDevice({
                                label: "GPU Device ".concat(this.hasTimestamp && "with feature: timestamp-query"),
                                requiredFeatures: requiredFeatures,
                            }))];
                    case 1:
                        _a.device = _d.sent();
                        if (!this.device) {
                            throw new Error("Failed to request WebGPU device.");
                        }
                        if (this.hasTimestamp) {
                            this.querySet = this.device.createQuerySet({
                                label: "GPU Query Set with Type: timestamp",
                                type: "timestamp",
                                count: 2,
                            });
                            this.resolveBuffer = this.device.createBuffer({
                                label: "GPU Buffer: Resolve",
                                size: this.querySet.count * 8,
                                usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
                            });
                            this.resultBuffer = this.device.createBuffer({
                                label: "GPU Buffer: Result",
                                size: this.resolveBuffer.size,
                                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                            });
                        }
                        this.device.lost.then(function (info) {
                            if (info.reason !== "destroyed") {
                                throw new Error("WebGPU device was lost: ".concat(info.message));
                            }
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.getCanvas = function () {
        var _this = this;
        this.canvas = document.querySelector("canvas");
        if (!this.canvas) {
            throw new Error("Failed to find canvas element.");
        }
        var observer = new ResizeObserver(function (entries) {
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                var canvas = entry.target;
                var width = entry.contentBoxSize[0].inlineSize;
                var height = entry.contentBoxSize[0].blockSize;
                canvas.width = Math.max(1, Math.min(width, _this.device.limits.maxTextureDimension2D));
                canvas.height = Math.max(1, Math.min(height, _this.device.limits.maxTextureDimension2D));
                _this.createMultisamplingTexture();
                _this.createDepthTextures();
            }
        });
        observer.observe(this.canvas);
    };
    Renderer.prototype.configContext = function () {
        this.context = this.canvas.getContext("webgpu");
        if (!this.context) {
            throw new Error("Failed to get WebGPU context from canvas.");
        }
        this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        this.context.configure({
            device: this.device,
            format: this.presentationFormat,
            alphaMode: "premultiplied",
        });
    };
    Renderer.prototype.createMultisamplingTexture = function () {
        if (this.multisamplingTexture) {
            this.multisamplingTexture.destroy();
        }
        this.multisamplingTexture = this.device.createTexture({
            label: "GPU Texture: Multisampling Texture",
            size: [this.canvas.width, this.canvas.height],
            format: this.presentationFormat,
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
            sampleCount: 4,
        });
        this.multisamplingTextureView = this.multisamplingTexture.createView({
            label: "GPU Texture View: Multisampling Texture View",
        });
    };
    Renderer.prototype.createDepthTextures = function () {
        for (var i = 0; i < 2; ++i) {
            if (this.depthTextures[i]) {
                this.depthTextures[i].destroy();
            }
            this.depthTextures[i] = this.device.createTexture({
                label: "GPU Texture: Depth Texture ".concat(i && "with MSAA"),
                size: [this.canvas.width, this.canvas.height],
                format: "depth24plus",
                usage: GPUTextureUsage.RENDER_ATTACHMENT,
                sampleCount: i ? 4 : 1,
            });
            this.depthTextureViews[i] = this.depthTextures[i].createView({
                label: "GPU Texture View: Depth Texture View ".concat(i && "with MSAA"),
            });
        }
    };
    Renderer.prototype.loadModel = function () {
        return __awaiter(this, void 0, void 0, function () {
            var loader;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        loader = new _glTF__WEBPACK_IMPORTED_MODULE_8__["default"]();
                        return [4 /*yield*/, loader.load("models/DamagedHelmet/DamagedHelmet.gltf")];
                    case 1:
                        _a.sent();
                        this.geometries = loader.getGeometries();
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.loadHDR = function () {
        return __awaiter(this, void 0, void 0, function () {
            var loader0, loader1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        loader0 = new _hdr__WEBPACK_IMPORTED_MODULE_9__["default"]();
                        return [4 /*yield*/, loader0.load("images/puresky_4k.hdr")];
                    case 1:
                        _a.sent();
                        loader1 = new _hdr__WEBPACK_IMPORTED_MODULE_9__["default"]();
                        return [4 /*yield*/, loader1.load("images/clear_puresky_4k.hdr")];
                    case 2:
                        _a.sent();
                        this.hdrs = [loader0.hdr, loader1.hdr];
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.createRenderPipeline = function () {
        var shaderModule = this.createShaderModule("GPU Shader Module", _shaders_shader_wgsl__WEBPACK_IMPORTED_MODULE_0__["default"]);
        var bindGroupLayout0 = this.device.createBindGroupLayout({
            label: "GPU Bind Group 0 Layout",
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.VERTEX,
                    buffer: { type: "uniform" },
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: "uniform" },
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: "uniform" },
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: "uniform" },
                },
            ],
        });
        var bindGroupLayout1 = this.device.createBindGroupLayout({
            label: "GPU Bind Group 1 Layout",
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d",
                        multisampled: false,
                    },
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d",
                        multisampled: false,
                    },
                },
                {
                    binding: 2,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d",
                        multisampled: false,
                    },
                },
                {
                    binding: 3,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: { type: "uniform" },
                },
                {
                    binding: 4,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d",
                        multisampled: false,
                    },
                },
                {
                    binding: 5,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: "float",
                        viewDimension: "2d",
                        multisampled: false,
                    },
                },
            ],
        });
        var bindGroupLayout2 = this.device.createBindGroupLayout({
            label: "GPU Bind Group 2 Layout",
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: "unfilterable-float",
                        viewDimension: "cube",
                        multisampled: false,
                    },
                },
            ],
        });
        var bindGroupLayout3 = this.device.createBindGroupLayout({
            label: "GPU Bind Group 3 Layout",
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: { type: "filtering" },
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: { type: "non-filtering" },
                },
            ],
        });
        var renderPipelineLayout = this.device.createPipelineLayout({
            label: "GPU Render Pipeline Layout",
            bindGroupLayouts: [
                bindGroupLayout0,
                bindGroupLayout1,
                bindGroupLayout2,
                bindGroupLayout3,
            ],
        });
        var renderPipelineDescriptor = {
            label: "GPU Render Pipeline",
            layout: renderPipelineLayout,
            vertex: {
                module: shaderModule,
                entryPoint: "vs_main",
                buffers: [
                    {
                        arrayStride: this.geometries[0].arrayStride,
                        stepMode: "vertex",
                        attributes: [
                            {
                                format: this.geometries[0].position.format,
                                offset: this.geometries[0].position.offset,
                                shaderLocation: 0,
                            },
                            {
                                format: this.geometries[0].texCoord.format,
                                offset: this.geometries[0].texCoord.offset,
                                shaderLocation: 1,
                            },
                            {
                                format: this.geometries[0].normal.format,
                                offset: this.geometries[0].normal.offset,
                                shaderLocation: 2,
                            },
                        ],
                    },
                ],
            },
            primitive: {
                topology: "triangle-list",
                cullMode: "back",
            },
            depthStencil: {
                format: "depth24plus",
                depthWriteEnabled: true,
                depthCompare: "less",
            },
            multisample: {
                count: 1,
            },
            fragment: {
                module: shaderModule,
                entryPoint: "fs_main",
                targets: [
                    {
                        format: this.presentationFormat,
                    },
                ],
            },
        };
        for (var i = 0; i < 2; ++i) {
            if (i) {
                renderPipelineDescriptor.label = "GPU Render Pipeline with MSAA";
                renderPipelineDescriptor.multisample.count = 4;
            }
            this.renderPipelines[i] = this.device.createRenderPipeline(renderPipelineDescriptor);
        }
    };
    Renderer.prototype.createVertexBuffer = function () {
        // prettier-ignore
        var vertices = this.geometries[0].vertices;
        this.vertexBuffer = this.createBuffer("GPU Buffer: Vertex", vertices.byteLength, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
        this.device.queue.writeBuffer(this.vertexBuffer, 0, vertices.buffer, 0, vertices.byteLength);
    };
    Renderer.prototype.createIndexBuffer = function () {
        // prettier-ignore
        var indices = this.geometries[0].indices;
        this.indexBuffer = this.createBuffer("GPU Buffer: Index", indices.byteLength, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST);
        this.device.queue.writeBuffer(this.indexBuffer, 0, indices.buffer, 0, indices.byteLength);
    };
    Renderer.prototype.createUniformBuffer = function () {
        this.transformUniformBuffer = this.createBuffer("GPU Uniform Buffer: Transform", (4 * 4 + 4 * 4 + 4 * 4 + 4 * 4) * Float32Array.BYTES_PER_ELEMENT, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);
        this.viewPositionUniformBuffer = this.createBuffer("GPU Uniform Buffer: View Position", 4 * Float32Array.BYTES_PER_ELEMENT, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);
        this.lightPositionsUniformBuffer = this.createBuffer("GPU Uniform Buffer: Light Positions", 4 * 4 * Float32Array.BYTES_PER_ELEMENT, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);
        this.lightColorsUniformBuffer = this.createBuffer("GPU Uniform Buffer: Light Colors", 4 * 4 * Float32Array.BYTES_PER_ELEMENT, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);
        for (var i = 0; i < 2; ++i) {
            var bindGroup = this.device.createBindGroup({
                label: "GPU Bind Group 0: Transform, View Position, Light Direction".concat(i && "with MSAA"),
                layout: this.renderPipelines[i].getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: this.transformUniformBuffer,
                        },
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: this.viewPositionUniformBuffer,
                        },
                    },
                    {
                        binding: 2,
                        resource: {
                            buffer: this.lightPositionsUniformBuffer,
                        },
                    },
                    {
                        binding: 3,
                        resource: {
                            buffer: this.lightColorsUniformBuffer,
                        },
                    },
                ],
            });
            this.bindGroups[0].push(bindGroup);
        }
    };
    Renderer.prototype.createTexture = function () {
        return __awaiter(this, void 0, void 0, function () {
            var baseColorImageBitmap, metallicRoughnessImageBitmap, normalImageBitmap, emissive, emissiveBuffer, emissiveImageBitmap, occlusionImageBitmap, i, mipIndex, renderPipelineIndex, baseColorMipLevelCount, baseColorTexture, baseColorTextureView, metallicRoughnessMipLevelCount, metallicRoughnessTexture, metallicRoughnessTextureView, noramlMipLevelCount, normalTexture, normalTextureView, emissiveMipLevelCount, emissiveTexture, emissiveTextureView, occlusionMipLevelCount, occlusionTexture, occlusionTextureView, bindGroup, i, mipIndex, renderPipelineIndex, skyboxIndex, cubeTexture, cubeTextureView, bindGroup, i, sampler2D, samplerCube, renderPipelineIndex, bindGroup;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_6__.loadImageBitmap)(this.geometries[0].textures.baseColorURI)];
                    case 1:
                        baseColorImageBitmap = _a.sent();
                        return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_6__.loadImageBitmap)(this.geometries[0].textures.metallicRoughnessURI)];
                    case 2:
                        metallicRoughnessImageBitmap = _a.sent();
                        return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_6__.loadImageBitmap)(this.geometries[0].textures.normalURI)];
                    case 3:
                        normalImageBitmap = _a.sent();
                        emissive = new Float32Array(this.geometries[0].textures.emissive);
                        emissiveBuffer = this.createBuffer("GPU Uniform Buffer: Emissive Factor", 4 * Float32Array.BYTES_PER_ELEMENT, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);
                        this.device.queue.writeBuffer(emissiveBuffer, 0, emissive.buffer, emissive.byteOffset, emissive.byteLength);
                        return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_6__.loadImageBitmap)(this.geometries[0].textures.emissiveURI)];
                    case 4:
                        emissiveImageBitmap = _a.sent();
                        return [4 /*yield*/, (0,_utils__WEBPACK_IMPORTED_MODULE_6__.loadImageBitmap)(this.geometries[0].textures.occlusionURI)];
                    case 5:
                        occlusionImageBitmap = _a.sent();
                        for (i = 0; i < 4; ++i) {
                            mipIndex = i & 1 ? 1 : 0;
                            renderPipelineIndex = i & 2 ? 1 : 0;
                            baseColorMipLevelCount = mipIndex
                                ? (0,_utils__WEBPACK_IMPORTED_MODULE_6__.calculateMipLevelCount)(baseColorImageBitmap.width, baseColorImageBitmap.height)
                                : 1;
                            baseColorTexture = this.createTexture2DFromSource("GPU Texture: Base Color ".concat(mipIndex && "with Mipmaps"), baseColorImageBitmap, baseColorMipLevelCount);
                            baseColorTextureView = baseColorTexture.createView({
                                label: "GPU Texture View: Base Color ".concat(mipIndex && "with Mipmaps"),
                            });
                            metallicRoughnessMipLevelCount = mipIndex
                                ? (0,_utils__WEBPACK_IMPORTED_MODULE_6__.calculateMipLevelCount)(metallicRoughnessImageBitmap.width, metallicRoughnessImageBitmap.height)
                                : 1;
                            metallicRoughnessTexture = this.createTexture2DFromSource("GPU Texture: Metallic Roughness ".concat(mipIndex && "with Mipmaps"), metallicRoughnessImageBitmap, metallicRoughnessMipLevelCount);
                            metallicRoughnessTextureView = metallicRoughnessTexture.createView({
                                label: "GPU Texture View: Metallic Roughness ".concat(mipIndex && "with Mipmaps"),
                            });
                            noramlMipLevelCount = mipIndex
                                ? (0,_utils__WEBPACK_IMPORTED_MODULE_6__.calculateMipLevelCount)(normalImageBitmap.width, normalImageBitmap.height)
                                : 1;
                            normalTexture = this.createTexture2DFromSource("GPU Texture: Noraml ".concat(mipIndex && "with Mipmaps"), normalImageBitmap, noramlMipLevelCount);
                            normalTextureView = normalTexture.createView({
                                label: "GPU Texture View: Noraml ".concat(mipIndex && "with Mipmaps"),
                            });
                            emissiveMipLevelCount = mipIndex
                                ? (0,_utils__WEBPACK_IMPORTED_MODULE_6__.calculateMipLevelCount)(emissiveImageBitmap.width, emissiveImageBitmap.height)
                                : 1;
                            emissiveTexture = this.createTexture2DFromSource("GPU Texture: Emissive ".concat(mipIndex && "with Mipmaps"), emissiveImageBitmap, emissiveMipLevelCount);
                            emissiveTextureView = emissiveTexture.createView({
                                label: "GPU Texture View: Emissive ".concat(mipIndex && "with Mipmaps"),
                            });
                            occlusionMipLevelCount = mipIndex
                                ? (0,_utils__WEBPACK_IMPORTED_MODULE_6__.calculateMipLevelCount)(occlusionImageBitmap.width, occlusionImageBitmap.height)
                                : 1;
                            occlusionTexture = this.createTexture2DFromSource("GPU Texture: Occlusion ".concat(mipIndex && "with Mipmaps"), occlusionImageBitmap, occlusionMipLevelCount);
                            occlusionTextureView = occlusionTexture.createView({
                                label: "GPU Texture View: Occlusion ".concat(mipIndex && "with Mipmaps"),
                            });
                            bindGroup = this.device.createBindGroup({
                                label: "GPU Bind Group 1: Material ".concat(mipIndex && "with Mipmaps", " ").concat(renderPipelineIndex && "with MSAA"),
                                layout: this.renderPipelines[renderPipelineIndex].getBindGroupLayout(1),
                                entries: [
                                    {
                                        binding: 0,
                                        resource: baseColorTextureView,
                                    },
                                    {
                                        binding: 1,
                                        resource: metallicRoughnessTextureView,
                                    },
                                    {
                                        binding: 2,
                                        resource: normalTextureView,
                                    },
                                    {
                                        binding: 3,
                                        resource: {
                                            buffer: emissiveBuffer,
                                        },
                                    },
                                    {
                                        binding: 4,
                                        resource: emissiveTextureView,
                                    },
                                    {
                                        binding: 5,
                                        resource: occlusionTextureView,
                                    },
                                ],
                            });
                            this.bindGroups[1].push(bindGroup);
                        }
                        for (i = 0; i < 8; ++i) {
                            mipIndex = i & 1 ? 1 : 0;
                            renderPipelineIndex = i & 2 ? 1 : 0;
                            skyboxIndex = i & 4 ? 1 : 0;
                            cubeTexture = this.createTextureCubeFromHDR(this.hdrs[skyboxIndex]);
                            cubeTexture = this.generateIrradianceMap()(this.device, cubeTexture, 32);
                            cubeTextureView = cubeTexture.createView({
                                label: "GPU Texture View: Cube ".concat(skyboxIndex),
                                dimension: "cube",
                            });
                            bindGroup = this.device.createBindGroup({
                                label: "GPU Bind Group 2: Cube ".concat(mipIndex && "with Mipmaps", " ").concat(renderPipelineIndex && "with MSAA"),
                                layout: this.renderPipelines[renderPipelineIndex].getBindGroupLayout(2),
                                entries: [
                                    {
                                        binding: 0,
                                        resource: cubeTextureView,
                                    },
                                ],
                            });
                            this.bindGroups[2].push(bindGroup);
                        }
                        for (i = 0; i < 32; ++i) {
                            sampler2D = this.device.createSampler({
                                label: "GPU Sampler: Sampler 2D ".concat(i),
                                addressModeU: i & 1 ? "repeat" : "clamp-to-edge",
                                addressModeV: i & 2 ? "repeat" : "clamp-to-edge",
                                magFilter: i & 4 ? "linear" : "nearest",
                                minFilter: i & 8 ? "linear" : "nearest",
                            });
                            samplerCube = this.device.createSampler({
                                label: "GPU Sampler: Sampler Cube ".concat(i),
                                addressModeU: "clamp-to-edge",
                                addressModeV: "clamp-to-edge",
                                addressModeW: "clamp-to-edge",
                                magFilter: "nearest",
                                minFilter: "nearest",
                                mipmapFilter: "nearest",
                            });
                            renderPipelineIndex = i & 16 ? 1 : 0;
                            bindGroup = this.device.createBindGroup({
                                label: "GPU Bind Group 3 : Sampler ".concat(i, ", ").concat(renderPipelineIndex && "with MSAA"),
                                layout: this.renderPipelines[renderPipelineIndex].getBindGroupLayout(3),
                                entries: [
                                    {
                                        binding: 0,
                                        resource: sampler2D,
                                    },
                                    {
                                        binding: 1,
                                        resource: samplerCube,
                                    },
                                ],
                            });
                            this.bindGroups[3].push(bindGroup);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Renderer.prototype.createSkyboxRenderPipeline = function () {
        var skyboxShaderModule = this.createShaderModule("GPU Shader Module: Skybox", _shaders_skybox_wgsl__WEBPACK_IMPORTED_MODULE_2__["default"]);
        var bindGroupLayout0 = this.device.createBindGroupLayout({
            label: "GPU Bind Group 0 Layout: Skybox",
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    buffer: {
                        type: "uniform",
                    },
                },
                {
                    binding: 1,
                    visibility: GPUShaderStage.FRAGMENT,
                    sampler: { type: "non-filtering" },
                },
            ],
        });
        var bindGroupLayout1 = this.device.createBindGroupLayout({
            label: "GPU Bind Group 1 Layout: Skybox",
            entries: [
                {
                    binding: 0,
                    visibility: GPUShaderStage.FRAGMENT,
                    texture: {
                        sampleType: "unfilterable-float",
                        viewDimension: "cube",
                        multisampled: false,
                    },
                },
            ],
        });
        var skyboxRenderPipelineLayout = this.device.createPipelineLayout({
            label: "GPU Render Pipeline Layout: Skybox",
            bindGroupLayouts: [bindGroupLayout0, bindGroupLayout1],
        });
        var skyboxRenderPipelineDescriptor = {
            label: "GPU Render Pipeline: Skybox",
            layout: skyboxRenderPipelineLayout,
            vertex: {
                module: skyboxShaderModule,
                entryPoint: "vs_main",
            },
            depthStencil: {
                format: "depth24plus",
                depthWriteEnabled: true,
                depthCompare: "less-equal",
            },
            multisample: {
                count: 1,
            },
            fragment: {
                module: skyboxShaderModule,
                entryPoint: "fs_main",
                targets: [
                    {
                        format: this.presentationFormat,
                    },
                ],
            },
        };
        for (var i = 0; i < 2; ++i) {
            if (i) {
                skyboxRenderPipelineDescriptor.label = "GPU Render Pipeline with MSAA";
                skyboxRenderPipelineDescriptor.multisample.count = 4;
            }
            this.skyboxRenderPipelines[i] = this.device.createRenderPipeline(skyboxRenderPipelineDescriptor);
        }
    };
    Renderer.prototype.createSkyboxUniformBuffer = function () {
        return __awaiter(this, void 0, void 0, function () {
            var skyboxSampler, i, bindGroup, skyboxTextureViews, i, skyboxTexture, i, renderPipelineIndex, skyboxIndex, bindGroup;
            return __generator(this, function (_a) {
                this.skyboxUniformBuffer = this.createBuffer("GPU Uniform Buffer: Skybox", 4 * 4 * Float32Array.BYTES_PER_ELEMENT, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);
                skyboxSampler = this.device.createSampler({
                    label: "GPU Sampler: Skybox",
                    addressModeU: "clamp-to-edge",
                    addressModeV: "clamp-to-edge",
                    addressModeW: "clamp-to-edge",
                    magFilter: "nearest",
                    minFilter: "nearest",
                    mipmapFilter: "nearest",
                });
                for (i = 0; i < 2; ++i) {
                    bindGroup = this.device.createBindGroup({
                        label: "GPU Bind Group: Skybox Matrix, Sampler ".concat(i && "with MSAA"),
                        layout: this.skyboxRenderPipelines[i].getBindGroupLayout(0),
                        entries: [
                            {
                                binding: 0,
                                resource: {
                                    buffer: this.skyboxUniformBuffer,
                                },
                            },
                            {
                                binding: 1,
                                resource: skyboxSampler,
                            },
                        ],
                    });
                    this.skyboxBindGroups[0].push(bindGroup);
                }
                skyboxTextureViews = [];
                for (i = 0; i < 2; ++i) {
                    skyboxTexture = this.createTextureCubeFromHDR(this.hdrs[i]);
                    skyboxTextureViews.push(skyboxTexture.createView({
                        label: "GPU Texture View: Skybox ".concat(i),
                        dimension: "cube",
                    }));
                }
                for (i = 0; i < 4; ++i) {
                    renderPipelineIndex = i & 1 ? 1 : 0;
                    skyboxIndex = i & 2 ? 1 : 0;
                    bindGroup = this.device.createBindGroup({
                        label: "GPU Bind Group: Skybox Texture ".concat(renderPipelineIndex && "with MSAA"),
                        layout: this.skyboxRenderPipelines[renderPipelineIndex].getBindGroupLayout(1),
                        entries: [
                            {
                                binding: 0,
                                resource: skyboxTextureViews[skyboxIndex],
                            },
                        ],
                    });
                    this.skyboxBindGroups[1].push(bindGroup);
                }
                return [2 /*return*/];
            });
        });
    };
    Renderer.prototype.createShaderModule = function (label, code) {
        var shaderModule = this.device.createShaderModule({
            label: label,
            code: code,
        });
        return shaderModule;
    };
    Renderer.prototype.createBuffer = function (label, size, usage) {
        var buffer = this.device.createBuffer({
            label: label,
            size: size,
            usage: usage,
        });
        return buffer;
    };
    Renderer.prototype.createTexture2DFromSource = function (label, source, mipLevelCount) {
        var width;
        var height;
        if (source instanceof HTMLVideoElement) {
            width = source.videoWidth;
            height = source.videoHeight;
        }
        else if (source instanceof VideoFrame) {
            width = source.codedWidth;
            height = source.codedHeight;
        }
        else {
            width = source.width;
            height = source.height;
        }
        var texture = this.device.createTexture({
            label: label,
            format: "rgba8unorm",
            mipLevelCount: mipLevelCount,
            size: [width, height],
            usage: GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT,
        });
        this.copySourceToTexture(this.device, source, texture);
        return texture;
    };
    Renderer.prototype.createTextureCubeFromHDR = function (hdr) {
        var texture = this.generateCubemap()(this.device, hdr, 1440);
        return texture;
    };
    Renderer.prototype.copySourceToTexture = function (device, source, texture) {
        var width;
        var height;
        if (source instanceof HTMLVideoElement) {
            width = source.videoWidth;
            height = source.videoHeight;
        }
        else if (source instanceof VideoFrame) {
            width = source.codedWidth;
            height = source.codedHeight;
        }
        else {
            width = source.width;
            height = source.height;
        }
        device.queue.copyExternalImageToTexture({ source: source }, { texture: texture }, { width: width, height: height });
        if (texture.mipLevelCount > 1) {
            this.generateMipmaps()(device, texture);
        }
    };
    Renderer.prototype.generateMipmaps = function () {
        var sampler;
        var module;
        var pipelineByFormat = new Map();
        var context = this;
        return function generateMipmaps(device, texture) {
            if (!module) {
                module = device.createShaderModule({
                    label: "GPU Shader Module: Mipmap Generation",
                    code: _shaders_mipmap_wgsl__WEBPACK_IMPORTED_MODULE_1__["default"],
                });
                sampler = device.createSampler({
                    minFilter: "linear",
                });
            }
            if (!pipelineByFormat.has(texture.format)) {
                var pipeline_1 = device.createRenderPipeline({
                    label: "GPU Render Pipeline: Mipmap Generation ",
                    layout: "auto",
                    vertex: {
                        module: module,
                        entryPoint: "vs_main",
                        buffers: [
                            {
                                arrayStride: (4 + 2) * Float32Array.BYTES_PER_ELEMENT,
                                stepMode: "vertex",
                                attributes: [
                                    {
                                        format: "float32x4",
                                        offset: 0,
                                        shaderLocation: 0,
                                    },
                                    {
                                        format: "float32x2",
                                        offset: 4 * Float32Array.BYTES_PER_ELEMENT,
                                        shaderLocation: 1,
                                    },
                                ],
                            },
                        ],
                    },
                    primitive: {
                        topology: "triangle-list",
                    },
                    fragment: {
                        module: module,
                        entryPoint: "fs_main",
                        targets: [
                            {
                                format: texture.format,
                            },
                        ],
                    },
                });
                pipelineByFormat.set(texture.format, pipeline_1);
            }
            var pipeline = pipelineByFormat.get(texture.format);
            // vertex buffer
            // prettier-ignore
            var vertices = new Float32Array([
                -1.0, 1.0, 0.0, 1.0, 0.0, 0.0,
                -1.0, -1.0, 0.0, 1.0, 0.0, 1.0,
                1.0, 1.0, 0.0, 1.0, 1.0, 0.0,
                1.0, -1.0, 0.0, 1.0, 1.0, 1.0,
            ]);
            var vertexBuffer = context.createBuffer("GPU Buffer: Mipmaps Generation Vertex", vertices.byteLength, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);
            device.queue.writeBuffer(vertexBuffer, 0, vertices.buffer, 0, vertices.byteLength);
            // index buffer
            var indices = new Uint32Array([0, 1, 2, 2, 1, 3]);
            var indexBuffer = context.createBuffer("GPU Buffer: Mipmap Generation Index ", indices.byteLength, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST);
            device.queue.writeBuffer(indexBuffer, 0, indices.buffer, 0, indices.byteLength);
            var encoder = device.createCommandEncoder({
                label: "GPU Command Encoder: Mipmap Generation",
            });
            var width = texture.width;
            var height = texture.height;
            var baseMipLevel = 0;
            while (width > 1 || height > 1) {
                width = Math.max(1, (width / 2) | 0);
                height = Math.max(1, (height / 2) | 0);
                if (1 == texture.depthOrArrayLayers) {
                    var bindGroup = device.createBindGroup({
                        label: "GPU Bind Group: Mipmap Generation",
                        layout: pipeline.getBindGroupLayout(0),
                        entries: [
                            {
                                binding: 0,
                                resource: sampler,
                            },
                            {
                                binding: 1,
                                resource: texture.createView({
                                    label: "GPU Texture View: Mipmap Generation",
                                    baseMipLevel: baseMipLevel,
                                    mipLevelCount: 1,
                                }),
                            },
                        ],
                    });
                    ++baseMipLevel;
                    var colorAttachments = [
                        {
                            view: texture.createView({
                                label: "GPU Texture View: Mipmap Generation Render Target",
                                baseMipLevel: baseMipLevel,
                                mipLevelCount: 1,
                            }),
                            loadOp: "clear",
                            storeOp: "store",
                        },
                    ];
                    var passDescriptor = {
                        label: "GPU Render Pass Descriptor: Mipmap Generation",
                        colorAttachments: colorAttachments,
                    };
                    var pass = encoder.beginRenderPass(passDescriptor);
                    pass.setPipeline(pipeline);
                    pass.setVertexBuffer(0, vertexBuffer);
                    pass.setIndexBuffer(indexBuffer, "uint32");
                    pass.setBindGroup(0, bindGroup);
                    pass.drawIndexed(6);
                    pass.end();
                }
                else if (6 == texture.depthOrArrayLayers) {
                    for (var layer = 0; layer < texture.depthOrArrayLayers; ++layer) {
                        var bindGroup = device.createBindGroup({
                            label: "GPU Bind Group: Mipmap Generation",
                            layout: pipeline.getBindGroupLayout(0),
                            entries: [
                                {
                                    binding: 0,
                                    resource: sampler,
                                },
                                {
                                    binding: 1,
                                    resource: texture.createView({
                                        label: "GPU Texture View: Mipmap Generation",
                                        dimension: "2d",
                                        baseMipLevel: baseMipLevel,
                                        mipLevelCount: 1,
                                        baseArrayLayer: layer,
                                        arrayLayerCount: 1,
                                    }),
                                },
                            ],
                        });
                        var colorAttachments = [
                            {
                                view: texture.createView({
                                    label: "GPU Texture View: Mipmap Generation Render Target",
                                    dimension: "2d",
                                    baseMipLevel: baseMipLevel + 1,
                                    mipLevelCount: 1,
                                    baseArrayLayer: layer,
                                    arrayLayerCount: 1,
                                }),
                                loadOp: "clear",
                                storeOp: "store",
                            },
                        ];
                        var passDescriptor = {
                            label: "GPU Render Pass Descriptor: Mipmap Generation",
                            colorAttachments: colorAttachments,
                        };
                        var pass = encoder.beginRenderPass(passDescriptor);
                        pass.setPipeline(pipeline);
                        pass.setVertexBuffer(0, vertexBuffer);
                        pass.setIndexBuffer(indexBuffer, "uint32");
                        pass.setBindGroup(0, bindGroup);
                        pass.drawIndexed(6);
                        pass.end();
                    }
                    ++baseMipLevel;
                }
            }
            device.queue.submit([encoder.finish()]);
        };
    };
    Renderer.prototype.generateCubemap = function () {
        var module;
        var computePipeline;
        return function generateCubemap(device, hdr, size) {
            if (!module) {
                module = device.createShaderModule({
                    label: "GPU Shader Module: Cubemap Generation",
                    code: _shaders_equirectangular_wgsl__WEBPACK_IMPORTED_MODULE_3__["default"],
                });
            }
            if (!computePipeline) {
                var bindGroupLayout = device.createBindGroupLayout({
                    label: "GPU Bind Group Layout: Cubemap Generation",
                    entries: [
                        {
                            binding: 0,
                            visibility: GPUShaderStage.COMPUTE,
                            texture: {
                                sampleType: "unfilterable-float",
                                viewDimension: "2d",
                                multisampled: false,
                            },
                        },
                        {
                            binding: 1,
                            visibility: GPUShaderStage.COMPUTE,
                            storageTexture: {
                                access: "write-only",
                                format: "rgba32float",
                                viewDimension: "2d-array",
                            },
                        },
                    ],
                });
                var computePipelineLayout = device.createPipelineLayout({
                    label: "GPU Compute Pipeline Layout: Cubemap Generation",
                    bindGroupLayouts: [bindGroupLayout],
                });
                computePipeline = device.createComputePipeline({
                    label: "GPU Compute Pipeline: Cubemap Generation",
                    layout: computePipelineLayout,
                    compute: {
                        module: module,
                        entryPoint: "compute_main",
                    },
                });
            }
            var srcTexture = device.createTexture({
                label: "GPU Texture: Cubemap Generation Source",
                size: [hdr.width, hdr.height],
                format: "rgba32float",
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
            });
            device.queue.writeTexture({
                texture: srcTexture,
                mipLevel: 0,
                origin: [0, 0, 0],
            }, hdr.data, {
                offset: 0,
                bytesPerRow: hdr.width * 4 * Float32Array.BYTES_PER_ELEMENT,
                rowsPerImage: hdr.height,
            }, {
                width: hdr.width,
                height: hdr.height,
            });
            var srcTextureView = srcTexture.createView({
                label: "GPU Texture View: Cubemap Generation Source",
                format: "rgba32float",
                dimension: "2d",
            });
            var dstTexture = device.createTexture({
                label: "GPU Texture: Cubemap Generation Destination",
                size: [size, size, 6],
                format: "rgba32float",
                usage: GPUTextureUsage.TEXTURE_BINDING |
                    GPUTextureUsage.STORAGE_BINDING |
                    GPUTextureUsage.COPY_SRC,
            });
            var dstTextureView = dstTexture.createView({
                label: "GPU Texture View: Cubemap Generation Destination",
                format: "rgba32float",
                dimension: "2d-array",
            });
            var bindGroup = device.createBindGroup({
                label: "GPU Bind Group: Cubemap Generation",
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: srcTextureView,
                    },
                    {
                        binding: 1,
                        resource: dstTextureView,
                    },
                ],
            });
            var encoder = device.createCommandEncoder({
                label: "GPU Command Encoder: Cubemap Generation",
            });
            var workgroupsNum = Math.floor((size + 15) / 16);
            var pass = encoder.beginComputePass({
                label: "GPU Compute Pass: Cubemap Generation",
            });
            pass.setPipeline(computePipeline);
            pass.setBindGroup(0, bindGroup);
            pass.dispatchWorkgroups(workgroupsNum, workgroupsNum, 6);
            pass.end();
            device.queue.submit([encoder.finish()]);
            return dstTexture;
        };
    };
    Renderer.prototype.generateIrradianceMap = function () {
        var module;
        var computePipeline;
        return function generateIrradianceMap(device, texture, size) {
            if (!module) {
                module = device.createShaderModule({
                    label: "GPU Shader Module: Irradiance Cubemap Generation",
                    code: _shaders_irradiancemap_wgsl__WEBPACK_IMPORTED_MODULE_4__["default"],
                });
            }
            if (!computePipeline) {
                var bindGroupLayout = device.createBindGroupLayout({
                    label: "GPU Bind Group Layout: Irradiance Cubemap Generation",
                    entries: [
                        {
                            binding: 0,
                            visibility: GPUShaderStage.COMPUTE,
                            storageTexture: {
                                access: "read-only",
                                format: "rgba32float",
                                viewDimension: "2d-array",
                            },
                        },
                        {
                            binding: 1,
                            visibility: GPUShaderStage.COMPUTE,
                            storageTexture: {
                                access: "write-only",
                                format: "rgba32float",
                                viewDimension: "2d-array",
                            },
                        },
                    ],
                });
                var computePipelineLayout = device.createPipelineLayout({
                    label: "GPU Compute Pipeline Layout: Irradiance Cubemap Generation",
                    bindGroupLayouts: [bindGroupLayout],
                });
                computePipeline = device.createComputePipeline({
                    label: "GPU Compute Pipeline: Irradiance Cubemap Generation",
                    layout: computePipelineLayout,
                    compute: {
                        module: module,
                        entryPoint: "compute_main",
                    },
                });
            }
            var srcTexture = device.createTexture({
                label: "GPU Texture: Irradiance Cubemap Generation Source",
                size: [texture.width, texture.height, 6],
                format: "rgba32float",
                usage: GPUTextureUsage.TEXTURE_BINDING |
                    GPUTextureUsage.STORAGE_BINDING |
                    GPUTextureUsage.COPY_DST,
            });
            var copyCommandEncoder = device.createCommandEncoder();
            copyCommandEncoder.copyTextureToTexture({
                texture: texture,
            }, {
                texture: srcTexture,
            }, [texture.width, texture.height, 6]);
            device.queue.submit([copyCommandEncoder.finish()]);
            var srcTextureView = srcTexture.createView({
                label: "GPU Texture View: Irradiance Cubemap Generation Source",
                format: "rgba32float",
                dimension: "2d-array",
            });
            var dstTexture = device.createTexture({
                label: "GPU Texture: Irradiance Cubemap Generation Destination",
                size: [size, size, 6],
                format: "rgba32float",
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,
            });
            var dstTextureView = dstTexture.createView({
                label: "GPU Texture View: Irradiance Cubemap Generation Destination",
                format: "rgba32float",
                dimension: "2d-array",
            });
            var bindGroup = device.createBindGroup({
                label: "GPU Bind Group: Cubemap Generation",
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: srcTextureView,
                    },
                    {
                        binding: 1,
                        resource: dstTextureView,
                    },
                ],
            });
            var encoder = device.createCommandEncoder({
                label: "GPU Command Encoder: Irradiance Cubemap Generation",
            });
            var workgroupsNum = Math.floor((size + 15) / 16);
            var pass = encoder.beginComputePass({
                label: "GPU Compute Pass: Irradiance Cubemap Generation",
            });
            pass.setPipeline(computePipeline);
            pass.setBindGroup(0, bindGroup);
            pass.dispatchWorkgroups(workgroupsNum, workgroupsNum, 6);
            pass.end();
            device.queue.submit([encoder.finish()]);
            return dstTexture;
        };
    };
    Renderer.prototype.initGUI = function () {
        var gui = new dat_gui__WEBPACK_IMPORTED_MODULE_5__.GUI({
            name: "My GUI",
            autoPlace: true,
            hideable: true,
            width: 300,
        });
        // profiling GUI
        var profiler = { fps: "0", cpuTime: "0", gpuTime: "0" };
        var profilerGUI = gui.addFolder("Profiler");
        profilerGUI.closed = false;
        this.fpsController = profilerGUI
            .add({ display: profiler.fps }, "display")
            .name("FPS");
        this.cpuTimeController = profilerGUI
            .add({ display: profiler.cpuTime }, "display")
            .name("CPU Time (ms)");
        this.gpuTimeController = profilerGUI
            .add({ display: profiler.gpuTime }, "display")
            .name("GPU Time (s)");
        // texture options GUI
        var textureOptions = {
            mimaps: true,
            addressModeU: "repeat",
            addressModeV: "repeat",
            magFilter: "linear",
            minFilter: "linear",
        };
        var textureOptionsGUI = gui.addFolder("Texture Options");
        textureOptionsGUI.closed = false;
        this.mipmapsController = textureOptionsGUI
            .add(textureOptions, "mimaps")
            .name("Mipmaps");
        this.addressModeUController = textureOptionsGUI
            .add(textureOptions, "addressModeU")
            .options(["repeat", "clamp-to-edge"])
            .name("addressModeU");
        this.addressModeVController = textureOptionsGUI
            .add(textureOptions, "addressModeV")
            .options(["repeat", "clamp-to-edge"])
            .name("addressModeV");
        this.magFilterController = textureOptionsGUI
            .add(textureOptions, "magFilter")
            .options(["linear", "nearest"])
            .name("magFilter");
        this.minFilterController = textureOptionsGUI
            .add(textureOptions, "minFilter")
            .options(["linear", "nearest"])
            .name("minFilter");
        // multisampling anti-aliasing GUI
        var msaaOptions = {
            enable: false,
        };
        var antiAliasingGUI = gui.addFolder("Multisampling Anti-Aliasing (MSAA)");
        antiAliasingGUI.closed = false;
        this.msaaController = antiAliasingGUI
            .add(msaaOptions, "enable")
            .name("Enable");
        // skybox GUI
        var skyboxOptions = {
            skybox: "Pure Sky",
        };
        var skyboxGUI = gui.addFolder("Skybox");
        skyboxGUI.closed = false;
        this.skyboxController = skyboxGUI
            .add(skyboxOptions, "skybox")
            .options(["Pure Sky", "Clear Pure Sky"])
            .name("Skybox");
    };
    Renderer.prototype.run = function () {
        requestAnimationFrame(this.drawFrame);
    };
    Renderer.prototype.drawFrame = function (now) {
        var _this = this;
        fpsAvg.value = 1000 / (now - this.current);
        this.fpsController.setValue(fpsAvg.value.toFixed(1));
        this.current = now;
        var startTime = performance.now();
        // transform values
        var transformValues = new Float32Array(this.transformUniformBuffer.size / Float32Array.BYTES_PER_ELEMENT);
        // model matrix
        var model = this.geometries[0].model;
        transformValues.set(model, 0);
        // noraml matrix
        var normal = wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.mat4.transpose(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.mat4.inverse(model));
        transformValues.set(normal, model.length);
        // view matrix
        var view = this.camera.view;
        transformValues.set(view, model.length + normal.length);
        // projection matrix
        var aspect = this.canvas.width / this.canvas.height;
        var projection = wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.mat4.perspective(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.utils.degToRad(45.0), aspect, 1.0, 100.0);
        transformValues.set(projection, model.length + normal.length + view.length);
        this.device.queue.writeBuffer(this.transformUniformBuffer, 0, transformValues.buffer, transformValues.byteOffset, transformValues.byteLength);
        // skybox uniform buffer values
        var skyboxValues = new Float32Array(this.skyboxUniformBuffer.size / Float32Array.BYTES_PER_ELEMENT);
        skyboxValues.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.mat4.inverse(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.mat4.mul(projection, view)), 0);
        this.device.queue.writeBuffer(this.skyboxUniformBuffer, 0, skyboxValues.buffer, skyboxValues.byteOffset, skyboxValues.byteLength);
        // camera position
        this.device.queue.writeBuffer(this.viewPositionUniformBuffer, 0, this.camera.position.buffer, this.camera.position.byteOffset, this.camera.position.byteLength);
        // light positions
        var lightPositions = new Float32Array(this.lightPositionsUniformBuffer.size / Float32Array.BYTES_PER_ELEMENT);
        lightPositions.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(10.0, 10.0, 10.0), 0);
        lightPositions.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(-10.0, 10.0, 10.0), 4);
        lightPositions.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(10.0, -10.0, 10.0), 8);
        lightPositions.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(-10.0, -10.0, 10.0), 12);
        this.device.queue.writeBuffer(this.lightPositionsUniformBuffer, 0, lightPositions.buffer, lightPositions.byteOffset, lightPositions.byteLength);
        // light colors
        var lightColors = new Float32Array(this.lightColorsUniformBuffer.size / Float32Array.BYTES_PER_ELEMENT);
        lightColors.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(300.0, 300.0, 300.0), 0);
        lightColors.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(300.0, 300.0, 300.0), 4);
        lightColors.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(300.0, 300.0, 300.0), 8);
        lightColors.set(wgpu_matrix__WEBPACK_IMPORTED_MODULE_10__.vec3.create(300.0, 300.0, 300.0), 12);
        this.device.queue.writeBuffer(this.lightColorsUniformBuffer, 0, lightColors.buffer, lightColors.byteOffset, lightColors.byteLength);
        // sampler index
        var addressModeU = this.addressModeUController.getValue();
        var addressModeV = this.addressModeVController.getValue();
        var magFilter = this.magFilterController.getValue();
        var minFilter = this.minFilterController.getValue();
        var samplerIndex = (addressModeU === "repeat" ? 1 : 0) +
            (addressModeV === "repeat" ? 2 : 0) +
            (magFilter === "linear" ? 4 : 0) +
            (minFilter === "linear" ? 8 : 0) +
            (this.msaaController.getValue() ? 16 : 0);
        var commandEncoder = this.device.createCommandEncoder({
            label: "GPU Command Encoder: Draw Frame",
        });
        var canvasTexture = this.context.getCurrentTexture();
        var canvasTextureView = canvasTexture.createView({
            label: "GPU Texture View: Canvas Texture View",
        });
        var colorAttachments = [
            {
                view: canvasTextureView,
                clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                loadOp: "clear",
                storeOp: "store",
            },
        ];
        if (this.msaaController.getValue()) {
            colorAttachments[0].view = this.multisamplingTextureView;
            colorAttachments[0].resolveTarget = canvasTextureView;
        }
        var depthTextureViewIndex = this.msaaController.getValue() ? 1 : 0;
        var renderPassDescriptor = {
            label: "GPU Renderpass Descriptor: Draw Frame",
            colorAttachments: colorAttachments,
            depthStencilAttachment: {
                view: this.depthTextureViews[depthTextureViewIndex],
                depthClearValue: 1.0,
                depthLoadOp: "clear",
                depthStoreOp: "store",
            },
        };
        if (this.hasTimestamp) {
            renderPassDescriptor.timestampWrites = {
                querySet: this.querySet,
                beginningOfPassWriteIndex: 0,
                endOfPassWriteIndex: 1,
            };
        }
        // mipmaps index
        var mipIndex = this.mipmapsController.getValue() ? 1 : 0;
        // render pipeline(w/ MSAA, w/o MSAA) index
        var renderPipelineIndex = this.msaaController.getValue() ? 1 : 0;
        // texture index
        var textureIndex = (mipIndex ? 1 : 0) + (renderPipelineIndex ? 2 : 0);
        // skybox index
        var skyboxIndex = this.skyboxController.getValue() === "Pure Sky" ? 0 : 1;
        // cubemap index
        var cubemapIndex = (mipIndex ? 1 : 0) +
            (renderPipelineIndex ? 2 : 0) +
            (skyboxIndex ? 4 : 0);
        // skybox texture index
        var skyboxTextureIndex = (renderPipelineIndex ? 1 : 0) + (skyboxIndex ? 2 : 0);
        var passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setPipeline(this.renderPipelines[renderPipelineIndex]);
        passEncoder.setVertexBuffer(0, this.vertexBuffer);
        passEncoder.setIndexBuffer(this.indexBuffer, "uint16");
        passEncoder.setBindGroup(0, this.bindGroups[0][renderPipelineIndex]);
        passEncoder.setBindGroup(1, this.bindGroups[1][textureIndex]);
        passEncoder.setBindGroup(2, this.bindGroups[2][cubemapIndex]);
        passEncoder.setBindGroup(3, this.bindGroups[3][samplerIndex]);
        passEncoder.drawIndexed(this.geometries[0].indices.length);
        passEncoder.setPipeline(this.skyboxRenderPipelines[renderPipelineIndex]);
        passEncoder.setBindGroup(0, this.skyboxBindGroups[0][renderPipelineIndex]);
        passEncoder.setBindGroup(1, this.skyboxBindGroups[1][skyboxTextureIndex]);
        passEncoder.draw(3);
        passEncoder.end();
        if (this.hasTimestamp) {
            commandEncoder.resolveQuerySet(this.querySet, 0, this.querySet.count, this.resolveBuffer, 0);
            if ("unmapped" === this.resultBuffer.mapState) {
                commandEncoder.copyBufferToBuffer(this.resolveBuffer, 0, this.resultBuffer, 0, this.resultBuffer.size);
            }
        }
        this.device.queue.submit([commandEncoder.finish()]);
        cpuTimeAvg.value = performance.now() - startTime;
        this.cpuTimeController.setValue(cpuTimeAvg.value.toFixed(1));
        if (this.hasTimestamp && "unmapped" === this.resultBuffer.mapState) {
            this.resultBuffer.mapAsync(GPUMapMode.READ).then(function () {
                var times = new BigInt64Array(_this.resultBuffer.getMappedRange());
                gpuTimeAvg.value = Number(times[1] - times[0]) / 1000;
                _this.gpuTimeController.setValue(gpuTimeAvg.value.toFixed(1));
                _this.resultBuffer.unmap();
            });
        }
        requestAnimationFrame(this.drawFrame);
    };
    return Renderer;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Renderer);


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RollingAverage: () => (/* binding */ RollingAverage),
/* harmony export */   calculateByteLength: () => (/* binding */ calculateByteLength),
/* harmony export */   calculateMipLevelCount: () => (/* binding */ calculateMipLevelCount),
/* harmony export */   loadImageBitmap: () => (/* binding */ loadImageBitmap),
/* harmony export */   rand: () => (/* binding */ rand)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function rand(min, max) {
    if (undefined === min) {
        min = 0;
        max = 1;
    }
    else if (undefined === max) {
        max = min;
        min = 0;
    }
    return min + Math.random() * (max - min);
}
function loadImageBitmap(url) {
    return __awaiter(this, void 0, void 0, function () {
        var res, blob;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fetch(url)];
                case 1:
                    res = _a.sent();
                    return [4 /*yield*/, res.blob()];
                case 2:
                    blob = _a.sent();
                    return [4 /*yield*/, createImageBitmap(blob, { colorSpaceConversion: "none" })];
                case 3: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function calculateMipLevelCount() {
    var sizes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sizes[_i] = arguments[_i];
    }
    var maxSize = Math.max.apply(Math, sizes);
    return (1 + Math.log2(maxSize)) | 0;
}
function calculateByteLength(type) {
    switch (type) {
        case "float32":
            return 4;
        case "float32x2":
            return 8;
        case "float32x3":
            return 12;
        case "float32x4":
            return 16;
        default:
            return 0;
    }
}
var RollingAverage = /** @class */ (function () {
    function RollingAverage(sampleCount) {
        if (sampleCount === void 0) { sampleCount = 100; }
        this.total = 0;
        this.samples = [];
        this.cursor = 0;
        this.sampleCount = sampleCount;
    }
    Object.defineProperty(RollingAverage.prototype, "value", {
        get: function () {
            return this.total / this.samples.length;
        },
        set: function (value) {
            this.total += value - (this.samples[this.cursor] || 0);
            this.samples[this.cursor] = value;
            this.cursor = (this.cursor + 1) % this.sampleCount;
        },
        enumerable: false,
        configurable: true
    });
    return RollingAverage;
}());



/***/ }),

/***/ "./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js":
/*!*****************************************************************!*\
  !*** ./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mat3: () => (/* binding */ mat3),
/* harmony export */   mat3d: () => (/* binding */ mat3d),
/* harmony export */   mat3n: () => (/* binding */ mat3n),
/* harmony export */   mat4: () => (/* binding */ mat4),
/* harmony export */   mat4d: () => (/* binding */ mat4d),
/* harmony export */   mat4n: () => (/* binding */ mat4n),
/* harmony export */   quat: () => (/* binding */ quat),
/* harmony export */   quatd: () => (/* binding */ quatd),
/* harmony export */   quatn: () => (/* binding */ quatn),
/* harmony export */   utils: () => (/* binding */ utils),
/* harmony export */   vec2: () => (/* binding */ vec2),
/* harmony export */   vec2d: () => (/* binding */ vec2d),
/* harmony export */   vec2n: () => (/* binding */ vec2n),
/* harmony export */   vec3: () => (/* binding */ vec3),
/* harmony export */   vec3d: () => (/* binding */ vec3d),
/* harmony export */   vec3n: () => (/* binding */ vec3n),
/* harmony export */   vec4: () => (/* binding */ vec4),
/* harmony export */   vec4d: () => (/* binding */ vec4d),
/* harmony export */   vec4n: () => (/* binding */ vec4n)
/* harmony export */ });
/* wgpu-matrix@3.0.1, license MIT */
function wrapConstructor(OriginalConstructor, modifier) {
    return class extends OriginalConstructor {
        constructor(...args) {
            super(...args);
            modifier(this);
        }
    }; // Type assertion is necessary here
}
const ZeroArray = wrapConstructor((Array), a => a.fill(0));

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
let EPSILON = 0.000001;
/**
 * Set the value for EPSILON for various checks
 * @param v - Value to use for EPSILON.
 * @returns previous value of EPSILON;
 */
function setEpsilon(v) {
    const old = EPSILON;
    EPSILON = v;
    return old;
}
/**
 * Convert degrees to radians
 * @param degrees - Angle in degrees
 * @returns angle converted to radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}
/**
 * Convert radians to degrees
 * @param radians - Angle in radians
 * @returns angle converted to degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}
/**
 * Lerps between a and b via t
 * @param a - starting value
 * @param b - ending value
 * @param t - value where 0 = a and 1 = b
 * @returns a + (b - a) * t
 */
function lerp(a, b, t) {
    return a + (b - a) * t;
}
/**
 * Compute the opposite of lerp. Given a and b and a value between
 * a and b returns a value between 0 and 1. 0 if a, 1 if b.
 * Note: no clamping is done.
 * @param a - start value
 * @param b - end value
 * @param v - value between a and b
 * @returns (v - a) / (b - a)
 */
function inverseLerp(a, b, v) {
    const d = b - a;
    return (Math.abs(b - a) < EPSILON)
        ? a
        : (v - a) / d;
}
/**
 * Compute the euclidean modulo
 *
 * ```
 * // table for n / 3
 * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n
 * ------------------------------------
 * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3
 *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)
 * ```
 *
 * @param n - dividend
 * @param m - divisor
 * @returns the euclidean modulo of n / m
 */
function euclideanModulo(n, m) {
    return ((n % m) + m) % m;
}

var utils = {
    __proto__: null,
    get EPSILON () { return EPSILON; },
    degToRad: degToRad,
    euclideanModulo: euclideanModulo,
    inverseLerp: inverseLerp,
    lerp: lerp,
    radToDeg: radToDeg,
    setEpsilon: setEpsilon
};

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec3
 */
function getAPIImpl$5(Ctor) {
    /**
     * Creates a Vec2; may be called with x, y, z to set initial values.
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Vec2's specified type
     * it would be faster to use
     *
     * ```
     * const v = vec2.clone(someJSArray);
     * ```
     *
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @returns the created vector
     */
    function create(x = 0, y = 0) {
        const newDst = new Ctor(2);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
            }
        }
        return newDst;
    }
    /**
     * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec2
     * Also see {@link vec2.create} and {@link vec2.copy}
     *
     * @param x first value
     * @param y second value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = x;
        newDst[1] = y;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        return newDst;
    }
    /**
     * Returns the angle in radians between two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns The angle in radians between the 2 vectors.
     */
    function angle(a, b) {
        const ax = a[0];
        const ay = a[1];
        const bx = b[0];
        const by = b[1];
        const mag1 = Math.sqrt(ax * ax + ay * ay);
        const mag2 = Math.sqrt(bx * bx + by * by);
        const mag = mag1 * mag2;
        const cosine = mag && dot(a, b) / mag;
        return Math.acos(cosine);
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the cross product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of a cross b.
     */
    function cross(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        const z = a[0] * b[1] - a[1] * b[0];
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = z;
        return newDst;
    }
    /**
     * Computes the dot product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        return Math.sqrt(v0 * v0 + v1 * v1);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        return v0 * v0 + v1 * v1;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        return Math.sqrt(dx * dx + dy * dy);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        return dx * dx + dy * dy;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        const v0 = v[0];
        const v1 = v[1];
        const len = Math.sqrt(v0 * v0 + v1 * v1);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec2.clone})
     * Also see {@link vec2.create} and {@link vec2.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = v[0];
        newDst[1] = v[1];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec2.copy})
     * Also see {@link vec2.create} and {@link vec2.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Creates a random unit vector * scale
     * @param scale - Default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The random vector.
     */
    function random(scale = 1, dst) {
        const newDst = (dst ?? new Ctor(2));
        const angle = Math.random() * 2 * Math.PI;
        newDst[0] = Math.cos(angle) * scale;
        newDst[1] = Math.sin(angle) * scale;
        return newDst;
    }
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(2));
        newDst[0] = 0;
        newDst[1] = 0;
        return newDst;
    }
    /**
     * transform Vec2 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional Vec2 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(2));
        const x = v[0];
        const y = v[1];
        newDst[0] = x * m[0] + y * m[4] + m[12];
        newDst[1] = x * m[1] + y * m[5] + m[13];
        return newDst;
    }
    /**
     * Transforms vec4 by 3x3 matrix
     *
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional Vec2 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat3(v, m, dst) {
        const newDst = (dst ?? new Ctor(2));
        const x = v[0];
        const y = v[1];
        newDst[0] = m[0] * x + m[4] * y + m[8];
        newDst[1] = m[1] * x + m[5] * y + m[9];
        return newDst;
    }
    /**
     * Rotate a 2D vector
     *
     * @param a The vec2 point to rotate
     * @param b The origin of the rotation
     * @param rad The angle of rotation in radians
     * @returns the rotated vector
     */
    function rotate(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(2));
        // Translate point to the origin
        const p0 = a[0] - b[0];
        const p1 = a[1] - b[1];
        const sinC = Math.sin(rad);
        const cosC = Math.cos(rad);
        //perform rotation and translate to correct position
        newDst[0] = p0 * cosC - p1 * sinC + b[0];
        newDst[1] = p0 * sinC + p1 * cosC + b[1];
        return newDst;
    }
    /**
     * Treat a 2D vector as a direction and set it's length
     *
     * @param a The vec2 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(2));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec2 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(2));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(2));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        angle,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        cross,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        random,
        zero,
        transformMat4,
        transformMat3,
        rotate,
        setLength,
        truncate,
        midpoint,
    };
}
const cache$5 = new Map();
function getAPI$5(Ctor) {
    let api = cache$5.get(Ctor);
    if (!api) {
        api = getAPIImpl$5(Ctor);
        cache$5.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates a typed API for Mat3
 * */
function getAPIImpl$4(Ctor) {
    const vec2 = getAPI$5(Ctor);
    /**
     * Create a Mat3 from values
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Mat3's specified type
     * it would be faster to use
     *
     * ```
     * const m = mat3.clone(someJSArray);
     * ```
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @returns matrix created from values.
     */
    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8) {
        const newDst = new Ctor(12);
        // to make the array homogenous
        newDst[3] = 0;
        newDst[7] = 0;
        newDst[11] = 0;
        if (v0 !== undefined) {
            newDst[0] = v0;
            if (v1 !== undefined) {
                newDst[1] = v1;
                if (v2 !== undefined) {
                    newDst[2] = v2;
                    if (v3 !== undefined) {
                        newDst[4] = v3;
                        if (v4 !== undefined) {
                            newDst[5] = v4;
                            if (v5 !== undefined) {
                                newDst[6] = v5;
                                if (v6 !== undefined) {
                                    newDst[8] = v6;
                                    if (v7 !== undefined) {
                                        newDst[9] = v7;
                                        if (v8 !== undefined) {
                                            newDst[10] = v8;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Sets the values of a Mat3
     * Also see {@link mat3.create} and {@link mat3.copy}
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 set from values.
     */
    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = v0;
        newDst[1] = v1;
        newDst[2] = v2;
        newDst[3] = 0;
        newDst[4] = v3;
        newDst[5] = v4;
        newDst[6] = v5;
        newDst[7] = 0;
        newDst[8] = v6;
        newDst[9] = v7;
        newDst[10] = v8;
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Creates a Mat3 from the upper left 3x3 part of a Mat4
     * @param m4 - source matrix
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 made from m4
     */
    function fromMat4(m4, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = m4[0];
        newDst[1] = m4[1];
        newDst[2] = m4[2];
        newDst[3] = 0;
        newDst[4] = m4[4];
        newDst[5] = m4[5];
        newDst[6] = m4[6];
        newDst[7] = 0;
        newDst[8] = m4[8];
        newDst[9] = m4[9];
        newDst[10] = m4[10];
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Creates a Mat3 rotation matrix from a quaternion
     * @param q - quaternion to create matrix from
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat3 made from q
     */
    function fromQuat(q, dst) {
        const newDst = (dst ?? new Ctor(12));
        const x = q[0];
        const y = q[1];
        const z = q[2];
        const w = q[3];
        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;
        const xx = x * x2;
        const yx = y * x2;
        const yy = y * y2;
        const zx = z * x2;
        const zy = z * y2;
        const zz = z * z2;
        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;
        newDst[0] = 1 - yy - zz;
        newDst[1] = yx + wz;
        newDst[2] = zx - wy;
        newDst[3] = 0;
        newDst[4] = yx - wz;
        newDst[5] = 1 - xx - zz;
        newDst[6] = zy + wx;
        newDst[7] = 0;
        newDst[8] = zx + wy;
        newDst[9] = zy - wx;
        newDst[10] = 1 - xx - yy;
        newDst[11] = 0;
        return newDst;
    }
    /**
     * Negates a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns -m.
     */
    function negate(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = -m[0];
        newDst[1] = -m[1];
        newDst[2] = -m[2];
        newDst[4] = -m[4];
        newDst[5] = -m[5];
        newDst[6] = -m[6];
        newDst[8] = -m[8];
        newDst[9] = -m[9];
        newDst[10] = -m[10];
        return newDst;
    }
    /**
     * Copies a matrix. (same as {@link mat3.clone})
     * Also see {@link mat3.create} and {@link mat3.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    function copy(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = m[0];
        newDst[1] = m[1];
        newDst[2] = m[2];
        newDst[4] = m[4];
        newDst[5] = m[5];
        newDst[6] = m[6];
        newDst[8] = m[8];
        newDst[9] = m[9];
        newDst[10] = m[10];
        return newDst;
    }
    /**
     * Copies a matrix (same as {@link mat3.copy})
     * Also see {@link mat3.create} and {@link mat3.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    const clone = copy;
    /**
     * Check if 2 matrices are approximately equal
     * @param a Operand matrix.
     * @param b Operand matrix.
     * @returns true if matrices are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[4] - b[4]) < EPSILON &&
            Math.abs(a[5] - b[5]) < EPSILON &&
            Math.abs(a[6] - b[6]) < EPSILON &&
            Math.abs(a[8] - b[8]) < EPSILON &&
            Math.abs(a[9] - b[9]) < EPSILON &&
            Math.abs(a[10] - b[10]) < EPSILON;
    }
    /**
     * Check if 2 matrices are exactly equal
     * @param a Operand matrix.
     * @param b Operand matrix.
     * @returns true if matrices are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] &&
            a[1] === b[1] &&
            a[2] === b[2] &&
            a[4] === b[4] &&
            a[5] === b[5] &&
            a[6] === b[6] &&
            a[8] === b[8] &&
            a[9] === b[9] &&
            a[10] === b[10];
    }
    /**
     * Creates a 3-by-3 identity matrix.
     *
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A 3-by-3 identity matrix.
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Takes the transpose of a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The transpose of m.
     */
    function transpose(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        if (newDst === m) {
            let t;
            // 0 1 2
            // 4 5 6
            // 8 9 10
            t = m[1];
            m[1] = m[4];
            m[4] = t;
            t = m[2];
            m[2] = m[8];
            m[8] = t;
            t = m[6];
            m[6] = m[9];
            m[9] = t;
            return newDst;
        }
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        newDst[0] = m00;
        newDst[1] = m10;
        newDst[2] = m20;
        newDst[4] = m01;
        newDst[5] = m11;
        newDst[6] = m21;
        newDst[8] = m02;
        newDst[9] = m12;
        newDst[10] = m22;
        return newDst;
    }
    /**
     * Computes the inverse of a 3-by-3 matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    function inverse(m, dst) {
        const newDst = (dst ?? new Ctor(12));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const b01 = m22 * m11 - m12 * m21;
        const b11 = -m22 * m10 + m12 * m20;
        const b21 = m21 * m10 - m11 * m20;
        const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);
        newDst[0] = b01 * invDet;
        newDst[1] = (-m22 * m01 + m02 * m21) * invDet;
        newDst[2] = (m12 * m01 - m02 * m11) * invDet;
        newDst[4] = b11 * invDet;
        newDst[5] = (m22 * m00 - m02 * m20) * invDet;
        newDst[6] = (-m12 * m00 + m02 * m10) * invDet;
        newDst[8] = b21 * invDet;
        newDst[9] = (-m21 * m00 + m01 * m20) * invDet;
        newDst[10] = (m11 * m00 - m01 * m10) * invDet;
        return newDst;
    }
    /**
     * Compute the determinant of a matrix
     * @param m - the matrix
     * @returns the determinant
     */
    function determinant(m) {
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        return m00 * (m11 * m22 - m21 * m12) -
            m10 * (m01 * m22 - m21 * m02) +
            m20 * (m01 * m12 - m11 * m02);
    }
    /**
     * Computes the inverse of a 3-by-3 matrix. (same as inverse)
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    const invert = inverse;
    /**
     * Multiplies two 3-by-3 matrices with a on the left and b on the right
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(12));
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a10 = a[4 + 0];
        const a11 = a[4 + 1];
        const a12 = a[4 + 2];
        const a20 = a[8 + 0];
        const a21 = a[8 + 1];
        const a22 = a[8 + 2];
        const b00 = b[0];
        const b01 = b[1];
        const b02 = b[2];
        const b10 = b[4 + 0];
        const b11 = b[4 + 1];
        const b12 = b[4 + 2];
        const b20 = b[8 + 0];
        const b21 = b[8 + 1];
        const b22 = b[8 + 2];
        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02;
        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02;
        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02;
        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12;
        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12;
        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12;
        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22;
        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22;
        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22;
        return newDst;
    }
    /**
     * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    const mul = multiply;
    /**
     * Sets the translation component of a 3-by-3 matrix to the given
     * vector.
     * @param a - The matrix.
     * @param v - The vector.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix with translation set.
     */
    function setTranslation(a, v, dst) {
        const newDst = (dst ?? identity());
        if (a !== newDst) {
            newDst[0] = a[0];
            newDst[1] = a[1];
            newDst[2] = a[2];
            newDst[4] = a[4];
            newDst[5] = a[5];
            newDst[6] = a[6];
        }
        newDst[8] = v[0];
        newDst[9] = v[1];
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Returns the translation component of a 3-by-3 matrix as a vector with 3
     * entries.
     * @param m - The matrix.
     * @param dst - vector to hold result. If not passed a new one is created.
     * @returns The translation component of m.
     */
    function getTranslation(m, dst) {
        const newDst = (dst ?? vec2.create());
        newDst[0] = m[8];
        newDst[1] = m[9];
        return newDst;
    }
    /**
     * Returns an axis of a 3x3 matrix as a vector with 2 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y,
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? vec2.create());
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        return newDst;
    }
    /**
     * Sets an axis of a 3x3 matrix as a vector with 2 entries
     * @param m - The matrix.
     * @param v - the axis vector
     * @param axis - The axis  0 = x, 1 = y;
     * @param dst - The matrix to set. If not passed a new one is created.
     * @returns The matrix with axis set.
     */
    function setAxis(m, v, axis, dst) {
        const newDst = (dst === m ? m : copy(m, dst));
        const off = axis * 4;
        newDst[off + 0] = v[0];
        newDst[off + 1] = v[1];
        return newDst;
    }
    ///**
    // * Returns the scaling component of the matrix
    // * @param m - The Matrix
    // * @param dst - The vector to set. If not passed a new one is created.
    // */
    function getScaling(m, dst) {
        const newDst = (dst ?? vec2.create());
        const xx = m[0];
        const xy = m[1];
        const yx = m[4];
        const yy = m[5];
        newDst[0] = Math.sqrt(xx * xx + xy * xy);
        newDst[1] = Math.sqrt(yx * yx + yy * yy);
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which translates by the given vector v.
     * @param v - The vector by which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translation matrix.
     */
    function translation(v, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[8] = v[0];
        newDst[9] = v[1];
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Translates the given 3-by-3 matrix by the given vector v.
     * @param m - The matrix.
     * @param v - The vector by which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translated matrix.
     */
    function translate(m, v, dst) {
        const newDst = (dst ?? new Ctor(12));
        const v0 = v[0];
        const v1 = v[1];
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        if (m !== newDst) {
            newDst[0] = m00;
            newDst[1] = m01;
            newDst[2] = m02;
            newDst[4] = m10;
            newDst[5] = m11;
            newDst[6] = m12;
        }
        newDst[8] = m00 * v0 + m10 * v1 + m20;
        newDst[9] = m01 * v0 + m11 * v1 + m21;
        newDst[10] = m02 * v0 + m12 * v1 + m22;
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which rotates  by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotation(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(12));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = s;
        newDst[2] = 0;
        newDst[4] = -s;
        newDst[5] = c;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Rotates the given 3-by-3 matrix  by the given angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotate(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(12));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 + s * m10;
        newDst[1] = c * m01 + s * m11;
        newDst[2] = c * m02 + s * m12;
        newDst[4] = c * m10 - s * m00;
        newDst[5] = c * m11 - s * m01;
        newDst[6] = c * m12 - s * m02;
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which scales in each dimension by an amount given by
     * the corresponding entry in the given vector; assumes the vector has three
     * entries.
     * @param v - A vector of
     *     2 entries specifying the factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function scaling(v, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = v[0];
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = v[1];
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Scales the given 3-by-3 matrix in each dimension by an amount
     * given by the corresponding entry in the given vector; assumes the vector has
     * three entries.
     * @param m - The matrix to be modified.
     * @param v - A vector of 2 entries specifying the
     *     factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function scale(m, v, dst) {
        const newDst = (dst ?? new Ctor(12));
        const v0 = v[0];
        const v1 = v[1];
        newDst[0] = v0 * m[0 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2];
        newDst[4] = v1 * m[1 * 4 + 0];
        newDst[5] = v1 * m[1 * 4 + 1];
        newDst[6] = v1 * m[1 * 4 + 2];
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    /**
     * Creates a 3-by-3 matrix which scales uniformly in each dimension
     * @param s - Amount to scale
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function uniformScaling(s, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = s;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[4] = 0;
        newDst[5] = s;
        newDst[6] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        return newDst;
    }
    /**
     * Scales the given 3-by-3 matrix in each dimension by an amount
     * given.
     * @param m - The matrix to be modified.
     * @param s - Amount to scale.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function uniformScale(m, s, dst) {
        const newDst = (dst ?? new Ctor(12));
        newDst[0] = s * m[0 * 4 + 0];
        newDst[1] = s * m[0 * 4 + 1];
        newDst[2] = s * m[0 * 4 + 2];
        newDst[4] = s * m[1 * 4 + 0];
        newDst[5] = s * m[1 * 4 + 1];
        newDst[6] = s * m[1 * 4 + 2];
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
        }
        return newDst;
    }
    return {
        clone,
        create,
        set,
        fromMat4,
        fromQuat,
        negate,
        copy,
        equalsApproximately,
        equals,
        identity,
        transpose,
        inverse,
        invert,
        determinant,
        mul,
        multiply,
        setTranslation,
        getTranslation,
        getAxis,
        setAxis,
        getScaling,
        translation,
        translate,
        rotation,
        rotate,
        scaling,
        scale,
        uniformScaling,
        uniformScale,
    };
}
const cache$4 = new Map();
function getAPI$4(Ctor) {
    let api = cache$4.get(Ctor);
    if (!api) {
        api = getAPIImpl$4(Ctor);
        cache$4.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec3
 * */
function getAPIImpl$3(Ctor) {
    /**
     * Creates a vec3; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @returns the created vector
     */
    function create(x, y, z) {
        const newDst = new Ctor(3);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a vec3; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec3
     * Also see {@link vec3.create} and {@link vec3.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        newDst[2] = Math.ceil(v[2]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        newDst[2] = Math.floor(v[2]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        newDst[2] = Math.round(v[2]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        newDst[2] = Math.min(max, Math.max(min, v[2]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        newDst[2] = a[2] + b[2] * scale;
        return newDst;
    }
    /**
     * Returns the angle in radians between two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns The angle in radians between the 2 vectors.
     */
    function angle(a, b) {
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const bx = b[0];
        const by = b[1];
        const bz = b[2];
        const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);
        const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);
        const mag = mag1 * mag2;
        const cosine = mag && dot(a, b) / mag;
        return Math.acos(cosine);
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        newDst[2] = a[2] + t[2] * (b[2] - a[2]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        newDst[2] = Math.max(a[2], b[2]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        newDst[2] = Math.min(a[2], b[2]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        newDst[2] = 1 / v[2];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the cross product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of a cross b.
     */
    function cross(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        const t1 = a[2] * b[0] - a[0] * b[2];
        const t2 = a[0] * b[1] - a[1] * b[0];
        newDst[0] = a[1] * b[2] - a[2] * b[1];
        newDst[1] = t1;
        newDst[2] = t2;
        return newDst;
    }
    /**
     * Computes the dot product of two vectors; assumes both vectors have
     * three entries.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        return v0 * v0 + v1 * v1 + v2 * v2;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        return dx * dx + dy * dy + dz * dz;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        newDst[2] = -v[2];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec3.clone})
     * Also see {@link vec3.create} and {@link vec3.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = v[0];
        newDst[1] = v[1];
        newDst[2] = v[2];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec3.copy})
     * Also see {@link vec3.create} and {@link vec3.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        newDst[2] = a[2] * b[2];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        newDst[2] = a[2] / b[2];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Creates a random vector
     * @param scale - Default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The random vector.
     */
    function random(scale = 1, dst) {
        const newDst = (dst ?? new Ctor(3));
        const angle = Math.random() * 2 * Math.PI;
        const z = Math.random() * 2 - 1;
        const zScale = Math.sqrt(1 - z * z) * scale;
        newDst[0] = Math.cos(angle) * zScale;
        newDst[1] = Math.sin(angle) * zScale;
        newDst[2] = z * scale;
        return newDst;
    }
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        return newDst;
    }
    /**
     * transform vec3 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;
        newDst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        newDst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        newDst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        return newDst;
    }
    /**
     * Transform vec3 by upper 3x3 matrix inside 4x4 matrix.
     * @param v - The direction.
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns The transformed vector.
     */
    function transformMat4Upper3x3(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        newDst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
        return newDst;
    }
    /**
     * Transforms vec3 by 3x3 matrix
     *
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat3(v, m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        newDst[0] = x * m[0] + y * m[4] + z * m[8];
        newDst[1] = x * m[1] + y * m[5] + z * m[9];
        newDst[2] = x * m[2] + y * m[6] + z * m[10];
        return newDst;
    }
    /**
     * Transforms vec3 by Quaternion
     * @param v - the vector to transform
     * @param q - the quaternion to transform by
     * @param dst - optional vec3 to store result. If not passed a new one is created.
     * @returns the transformed
     */
    function transformQuat(v, q, dst) {
        const newDst = (dst ?? new Ctor(3));
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const w2 = q[3] * 2;
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const uvX = qy * z - qz * y;
        const uvY = qz * x - qx * z;
        const uvZ = qx * y - qy * x;
        newDst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;
        newDst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;
        newDst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;
        return newDst;
    }
    /**
     * Returns the translation component of a 4-by-4 matrix as a vector with 3
     * entries.
     * @param m - The matrix.
     * @param dst - vector to hold result. If not passed a new one is created.
     * @returns The translation component of m.
     */
    function getTranslation(m, dst) {
        const newDst = (dst ?? new Ctor(3));
        newDst[0] = m[12];
        newDst[1] = m[13];
        newDst[2] = m[14];
        return newDst;
    }
    /**
     * Returns an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y, 2 = z;
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? new Ctor(3));
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        newDst[2] = m[off + 2];
        return newDst;
    }
    /**
     * Returns the scaling component of the matrix
     * @param m - The Matrix
     * @param dst - The vector to set. If not passed a new one is created.
     */
    function getScaling(m, dst) {
        const newDst = (dst ?? new Ctor(3));
        const xx = m[0];
        const xy = m[1];
        const xz = m[2];
        const yx = m[4];
        const yy = m[5];
        const yz = m[6];
        const zx = m[8];
        const zy = m[9];
        const zz = m[10];
        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
        return newDst;
    }
    /**
     * Rotate a 3D vector around the x-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns the rotated vector
     */
    function rotateX(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        //Translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        //perform rotation
        r[0] = p[0];
        r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
        r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
        //translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Rotate a 3D vector around the y-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns the rotated vector
     */
    function rotateY(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        // translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        // perform rotation
        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
        r[1] = p[1];
        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
        // translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Rotate a 3D vector around the z-axis
     *
     * @param {ReadonlyVec3} a The vec3 point to rotate
     * @param {ReadonlyVec3} b The origin of the rotation
     * @param {Number} rad The angle of rotation in radians
     * @param dst - The vector to set. If not passed a new one is created.
     * @returns {vec3} out
     */
    function rotateZ(a, b, rad, dst) {
        const newDst = (dst ?? new Ctor(3));
        const p = [];
        const r = [];
        // translate point to the origin
        p[0] = a[0] - b[0];
        p[1] = a[1] - b[1];
        p[2] = a[2] - b[2];
        // perform rotation
        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
        r[2] = p[2];
        // translate to correct position
        newDst[0] = r[0] + b[0];
        newDst[1] = r[1] + b[1];
        newDst[2] = r[2] + b[2];
        return newDst;
    }
    /**
     * Treat a 3D vector as a direction and set it's length
     *
     * @param a The vec3 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(3));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec3 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(3));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(3));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        angle,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        cross,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        random,
        zero,
        transformMat4,
        transformMat4Upper3x3,
        transformMat3,
        transformQuat,
        getTranslation,
        getAxis,
        getScaling,
        rotateX,
        rotateY,
        rotateZ,
        setLength,
        truncate,
        midpoint,
    };
}
const cache$3 = new Map();
function getAPI$3(Ctor) {
    let api = cache$3.get(Ctor);
    if (!api) {
        api = getAPIImpl$3(Ctor);
        cache$3.set(Ctor, api);
    }
    return api;
}

/**
 * Generates a typed API for Mat4
 * */
function getAPIImpl$2(Ctor) {
    const vec3 = getAPI$3(Ctor);
    /**
     * 4x4 Matrix math math functions.
     *
     * Almost all functions take an optional `newDst` argument. If it is not passed in the
     * functions will create a new matrix. In other words you can do this
     *
     *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix
     *
     * or
     *
     *     const mat = mat4.create();
     *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
     *
     * The first style is often easier but depending on where it's used it generates garbage where
     * as there is almost never allocation with the second style.
     *
     * It is always save to pass any matrix as the destination. So for example
     *
     *     const mat = mat4.identity();
     *     const trans = mat4.translation([1, 2, 3]);
     *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
     *
     */
    /**
     * Create a Mat4 from values
     *
     * Note: Since passing in a raw JavaScript array
     * is valid in all circumstances, if you want to
     * force a JavaScript array into a Mat4's specified type
     * it would be faster to use
     *
     * ```
     * const m = mat4.clone(someJSArray);
     * ```
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param v9 - value for element 9
     * @param v10 - value for element 10
     * @param v11 - value for element 11
     * @param v12 - value for element 12
     * @param v13 - value for element 13
     * @param v14 - value for element 14
     * @param v15 - value for element 15
     * @returns created from values.
     */
    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
        const newDst = new Ctor(16);
        if (v0 !== undefined) {
            newDst[0] = v0;
            if (v1 !== undefined) {
                newDst[1] = v1;
                if (v2 !== undefined) {
                    newDst[2] = v2;
                    if (v3 !== undefined) {
                        newDst[3] = v3;
                        if (v4 !== undefined) {
                            newDst[4] = v4;
                            if (v5 !== undefined) {
                                newDst[5] = v5;
                                if (v6 !== undefined) {
                                    newDst[6] = v6;
                                    if (v7 !== undefined) {
                                        newDst[7] = v7;
                                        if (v8 !== undefined) {
                                            newDst[8] = v8;
                                            if (v9 !== undefined) {
                                                newDst[9] = v9;
                                                if (v10 !== undefined) {
                                                    newDst[10] = v10;
                                                    if (v11 !== undefined) {
                                                        newDst[11] = v11;
                                                        if (v12 !== undefined) {
                                                            newDst[12] = v12;
                                                            if (v13 !== undefined) {
                                                                newDst[13] = v13;
                                                                if (v14 !== undefined) {
                                                                    newDst[14] = v14;
                                                                    if (v15 !== undefined) {
                                                                        newDst[15] = v15;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Sets the values of a Mat4
     * Also see {@link mat4.create} and {@link mat4.copy}
     *
     * @param v0 - value for element 0
     * @param v1 - value for element 1
     * @param v2 - value for element 2
     * @param v3 - value for element 3
     * @param v4 - value for element 4
     * @param v5 - value for element 5
     * @param v6 - value for element 6
     * @param v7 - value for element 7
     * @param v8 - value for element 8
     * @param v9 - value for element 9
     * @param v10 - value for element 10
     * @param v11 - value for element 11
     * @param v12 - value for element 12
     * @param v13 - value for element 13
     * @param v14 - value for element 14
     * @param v15 - value for element 15
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 created from values.
     */
    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = v0;
        newDst[1] = v1;
        newDst[2] = v2;
        newDst[3] = v3;
        newDst[4] = v4;
        newDst[5] = v5;
        newDst[6] = v6;
        newDst[7] = v7;
        newDst[8] = v8;
        newDst[9] = v9;
        newDst[10] = v10;
        newDst[11] = v11;
        newDst[12] = v12;
        newDst[13] = v13;
        newDst[14] = v14;
        newDst[15] = v15;
        return newDst;
    }
    /**
     * Creates a Mat4 from a Mat3
     * @param m3 - source matrix
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 made from m3
     */
    function fromMat3(m3, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = m3[0];
        newDst[1] = m3[1];
        newDst[2] = m3[2];
        newDst[3] = 0;
        newDst[4] = m3[4];
        newDst[5] = m3[5];
        newDst[6] = m3[6];
        newDst[7] = 0;
        newDst[8] = m3[8];
        newDst[9] = m3[9];
        newDst[10] = m3[10];
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a Mat4 rotation matrix from a quaternion
     * @param q - quaternion to create matrix from
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns Mat4 made from q
     */
    function fromQuat(q, dst) {
        const newDst = (dst ?? new Ctor(16));
        const x = q[0];
        const y = q[1];
        const z = q[2];
        const w = q[3];
        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;
        const xx = x * x2;
        const yx = y * x2;
        const yy = y * y2;
        const zx = z * x2;
        const zy = z * y2;
        const zz = z * z2;
        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;
        newDst[0] = 1 - yy - zz;
        newDst[1] = yx + wz;
        newDst[2] = zx - wy;
        newDst[3] = 0;
        newDst[4] = yx - wz;
        newDst[5] = 1 - xx - zz;
        newDst[6] = zy + wx;
        newDst[7] = 0;
        newDst[8] = zx + wy;
        newDst[9] = zy - wx;
        newDst[10] = 1 - xx - yy;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Negates a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns -m.
     */
    function negate(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = -m[0];
        newDst[1] = -m[1];
        newDst[2] = -m[2];
        newDst[3] = -m[3];
        newDst[4] = -m[4];
        newDst[5] = -m[5];
        newDst[6] = -m[6];
        newDst[7] = -m[7];
        newDst[8] = -m[8];
        newDst[9] = -m[9];
        newDst[10] = -m[10];
        newDst[11] = -m[11];
        newDst[12] = -m[12];
        newDst[13] = -m[13];
        newDst[14] = -m[14];
        newDst[15] = -m[15];
        return newDst;
    }
    /**
     * Copies a matrix. (same as {@link mat4.clone})
     * Also see {@link mat4.create} and {@link mat4.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    function copy(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = m[0];
        newDst[1] = m[1];
        newDst[2] = m[2];
        newDst[3] = m[3];
        newDst[4] = m[4];
        newDst[5] = m[5];
        newDst[6] = m[6];
        newDst[7] = m[7];
        newDst[8] = m[8];
        newDst[9] = m[9];
        newDst[10] = m[10];
        newDst[11] = m[11];
        newDst[12] = m[12];
        newDst[13] = m[13];
        newDst[14] = m[14];
        newDst[15] = m[15];
        return newDst;
    }
    /**
     * Copies a matrix (same as {@link mat4.copy})
     * Also see {@link mat4.create} and {@link mat4.set}
     * @param m - The matrix.
     * @param dst - The matrix. If not passed a new one is created.
     * @returns A copy of m.
     */
    const clone = copy;
    /**
     * Check if 2 matrices are approximately equal
     * @param a - Operand matrix.
     * @param b - Operand matrix.
     * @returns true if matrices are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON &&
            Math.abs(a[4] - b[4]) < EPSILON &&
            Math.abs(a[5] - b[5]) < EPSILON &&
            Math.abs(a[6] - b[6]) < EPSILON &&
            Math.abs(a[7] - b[7]) < EPSILON &&
            Math.abs(a[8] - b[8]) < EPSILON &&
            Math.abs(a[9] - b[9]) < EPSILON &&
            Math.abs(a[10] - b[10]) < EPSILON &&
            Math.abs(a[11] - b[11]) < EPSILON &&
            Math.abs(a[12] - b[12]) < EPSILON &&
            Math.abs(a[13] - b[13]) < EPSILON &&
            Math.abs(a[14] - b[14]) < EPSILON &&
            Math.abs(a[15] - b[15]) < EPSILON;
    }
    /**
     * Check if 2 matrices are exactly equal
     * @param a - Operand matrix.
     * @param b - Operand matrix.
     * @returns true if matrices are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] &&
            a[1] === b[1] &&
            a[2] === b[2] &&
            a[3] === b[3] &&
            a[4] === b[4] &&
            a[5] === b[5] &&
            a[6] === b[6] &&
            a[7] === b[7] &&
            a[8] === b[8] &&
            a[9] === b[9] &&
            a[10] === b[10] &&
            a[11] === b[11] &&
            a[12] === b[12] &&
            a[13] === b[13] &&
            a[14] === b[14] &&
            a[15] === b[15];
    }
    /**
     * Creates a 4-by-4 identity matrix.
     *
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A 4-by-4 identity matrix.
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Takes the transpose of a matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The transpose of m.
     */
    function transpose(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        if (newDst === m) {
            let t;
            t = m[1];
            m[1] = m[4];
            m[4] = t;
            t = m[2];
            m[2] = m[8];
            m[8] = t;
            t = m[3];
            m[3] = m[12];
            m[12] = t;
            t = m[6];
            m[6] = m[9];
            m[9] = t;
            t = m[7];
            m[7] = m[13];
            m[13] = t;
            t = m[11];
            m[11] = m[14];
            m[14] = t;
            return newDst;
        }
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        newDst[0] = m00;
        newDst[1] = m10;
        newDst[2] = m20;
        newDst[3] = m30;
        newDst[4] = m01;
        newDst[5] = m11;
        newDst[6] = m21;
        newDst[7] = m31;
        newDst[8] = m02;
        newDst[9] = m12;
        newDst[10] = m22;
        newDst[11] = m32;
        newDst[12] = m03;
        newDst[13] = m13;
        newDst[14] = m23;
        newDst[15] = m33;
        return newDst;
    }
    /**
     * Computes the inverse of a 4-by-4 matrix.
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    function inverse(m, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        const tmp0 = m22 * m33;
        const tmp1 = m32 * m23;
        const tmp2 = m12 * m33;
        const tmp3 = m32 * m13;
        const tmp4 = m12 * m23;
        const tmp5 = m22 * m13;
        const tmp6 = m02 * m33;
        const tmp7 = m32 * m03;
        const tmp8 = m02 * m23;
        const tmp9 = m22 * m03;
        const tmp10 = m02 * m13;
        const tmp11 = m12 * m03;
        const tmp12 = m20 * m31;
        const tmp13 = m30 * m21;
        const tmp14 = m10 * m31;
        const tmp15 = m30 * m11;
        const tmp16 = m10 * m21;
        const tmp17 = m20 * m11;
        const tmp18 = m00 * m31;
        const tmp19 = m30 * m01;
        const tmp20 = m00 * m21;
        const tmp21 = m20 * m01;
        const tmp22 = m00 * m11;
        const tmp23 = m10 * m01;
        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
        const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
        newDst[0] = d * t0;
        newDst[1] = d * t1;
        newDst[2] = d * t2;
        newDst[3] = d * t3;
        newDst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -
            (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));
        newDst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -
            (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));
        newDst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -
            (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));
        newDst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -
            (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));
        newDst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -
            (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));
        newDst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -
            (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));
        newDst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -
            (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));
        newDst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -
            (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));
        newDst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -
            (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));
        newDst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -
            (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));
        newDst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -
            (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));
        newDst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -
            (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));
        return newDst;
    }
    /**
     * Compute the determinant of a matrix
     * @param m - the matrix
     * @returns the determinant
     */
    function determinant(m) {
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        const tmp0 = m22 * m33;
        const tmp1 = m32 * m23;
        const tmp2 = m12 * m33;
        const tmp3 = m32 * m13;
        const tmp4 = m12 * m23;
        const tmp5 = m22 * m13;
        const tmp6 = m02 * m33;
        const tmp7 = m32 * m03;
        const tmp8 = m02 * m23;
        const tmp9 = m22 * m03;
        const tmp10 = m02 * m13;
        const tmp11 = m12 * m03;
        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
        return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;
    }
    /**
     * Computes the inverse of a 4-by-4 matrix. (same as inverse)
     * @param m - The matrix.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The inverse of m.
     */
    const invert = inverse;
    /**
     * Multiplies two 4-by-4 matrices with a on the left and b on the right
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(16));
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a03 = a[3];
        const a10 = a[4 + 0];
        const a11 = a[4 + 1];
        const a12 = a[4 + 2];
        const a13 = a[4 + 3];
        const a20 = a[8 + 0];
        const a21 = a[8 + 1];
        const a22 = a[8 + 2];
        const a23 = a[8 + 3];
        const a30 = a[12 + 0];
        const a31 = a[12 + 1];
        const a32 = a[12 + 2];
        const a33 = a[12 + 3];
        const b00 = b[0];
        const b01 = b[1];
        const b02 = b[2];
        const b03 = b[3];
        const b10 = b[4 + 0];
        const b11 = b[4 + 1];
        const b12 = b[4 + 2];
        const b13 = b[4 + 3];
        const b20 = b[8 + 0];
        const b21 = b[8 + 1];
        const b22 = b[8 + 2];
        const b23 = b[8 + 3];
        const b30 = b[12 + 0];
        const b31 = b[12 + 1];
        const b32 = b[12 + 2];
        const b33 = b[12 + 3];
        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
        newDst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
        newDst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
        newDst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
        newDst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
        newDst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
        newDst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
        newDst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
        return newDst;
    }
    /**
     * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)
     * @param a - The matrix on the left.
     * @param b - The matrix on the right.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix product of a and b.
     */
    const mul = multiply;
    /**
     * Sets the translation component of a 4-by-4 matrix to the given
     * vector.
     * @param a - The matrix.
     * @param v - The vector.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The matrix with translation set.
     */
    function setTranslation(a, v, dst) {
        const newDst = (dst ?? identity());
        if (a !== newDst) {
            newDst[0] = a[0];
            newDst[1] = a[1];
            newDst[2] = a[2];
            newDst[3] = a[3];
            newDst[4] = a[4];
            newDst[5] = a[5];
            newDst[6] = a[6];
            newDst[7] = a[7];
            newDst[8] = a[8];
            newDst[9] = a[9];
            newDst[10] = a[10];
            newDst[11] = a[11];
        }
        newDst[12] = v[0];
        newDst[13] = v[1];
        newDst[14] = v[2];
        newDst[15] = 1;
        return newDst;
    }
    ///**
    // * Returns the translation component of a 4-by-4 matrix as a vector with 3
    // * entries.
    // * @param m - The matrix.
    // * @param dst - vector to hold result. If not passed a new one is created.
    // * @returns The translation component of m.
    // */
    function getTranslation(m, dst) {
        const newDst = (dst ?? vec3.create());
        newDst[0] = m[12];
        newDst[1] = m[13];
        newDst[2] = m[14];
        return newDst;
    }
    /**
     * Returns an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param axis - The axis 0 = x, 1 = y, 2 = z;
     * @returns The axis component of m.
     */
    function getAxis(m, axis, dst) {
        const newDst = (dst ?? vec3.create());
        const off = axis * 4;
        newDst[0] = m[off + 0];
        newDst[1] = m[off + 1];
        newDst[2] = m[off + 2];
        return newDst;
    }
    /**
     * Sets an axis of a 4x4 matrix as a vector with 3 entries
     * @param m - The matrix.
     * @param v - the axis vector
     * @param axis - The axis  0 = x, 1 = y, 2 = z;
     * @param dst - The matrix to set. If not passed a new one is created.
     * @returns The matrix with axis set.
     */
    function setAxis(m, v, axis, dst) {
        const newDst = (dst === m) ? dst : copy(m, dst);
        const off = axis * 4;
        newDst[off + 0] = v[0];
        newDst[off + 1] = v[1];
        newDst[off + 2] = v[2];
        return newDst;
    }
    ///**
    // * Returns the scaling component of the matrix
    // * @param m - The Matrix
    // * @param dst - The vector to set. If not passed a new one is created.
    // */
    function getScaling(m, dst) {
        const newDst = (dst ?? vec3.create());
        const xx = m[0];
        const xy = m[1];
        const xz = m[2];
        const yx = m[4];
        const yy = m[5];
        const yz = m[6];
        const zx = m[8];
        const zy = m[9];
        const zz = m[10];
        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);
        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);
        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);
        return newDst;
    }
    /**
     * Computes a 4-by-4 perspective transformation matrix given the angular height
     * of the frustum, the aspect ratio, and the near and far clipping planes.  The
     * arguments define a frustum extending in the negative z direction.  The given
     * angle is the vertical angle of the frustum, and the horizontal angle is
     * determined to produce the given aspect ratio.  The arguments near and far are
     * the distances to the near and far clipping planes.  Note that near and far
     * are not z coordinates, but rather they are distances along the negative
     * z-axis.  The matrix generated sends the viewing frustum to the unit box.
     * We assume a unit box extending from -1 to 1 in the x and y dimensions and
     * from 0 to 1 in the z dimension.
     *
     * Note: If you pass `Infinity` for zFar then it will produce a projection matrix
     * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z
     * otherwise.
     *
     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).
     * @param aspect - The aspect ratio width / height.
     * @param zNear - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param zFar - The depth (negative z coordinate)
     *     of the far clipping plane.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The perspective matrix.
     */
    function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
        const newDst = (dst ?? new Ctor(16));
        const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
        newDst[0] = f / aspect;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = f;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (Number.isFinite(zFar)) {
            const rangeInv = 1 / (zNear - zFar);
            newDst[10] = zFar * rangeInv;
            newDst[14] = zFar * zNear * rangeInv;
        }
        else {
            newDst[10] = -1;
            newDst[14] = -zNear;
        }
        return newDst;
    }
    /**
     * Computes a 4-by-4 reverse-z perspective transformation matrix given the angular height
     * of the frustum, the aspect ratio, and the near and far clipping planes.  The
     * arguments define a frustum extending in the negative z direction.  The given
     * angle is the vertical angle of the frustum, and the horizontal angle is
     * determined to produce the given aspect ratio.  The arguments near and far are
     * the distances to the near and far clipping planes.  Note that near and far
     * are not z coordinates, but rather they are distances along the negative
     * z-axis.  The matrix generated sends the viewing frustum to the unit box.
     * We assume a unit box extending from -1 to 1 in the x and y dimensions and
     * from 1 (at -zNear) to 0 (at -zFar) in the z dimension.
     *
     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).
     * @param aspect - The aspect ratio width / height.
     * @param zNear - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param zFar - The depth (negative z coordinate)
     *     of the far clipping plane. (default = Infinity)
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The perspective matrix.
     */ function perspectiveReverseZ(fieldOfViewYInRadians, aspect, zNear, zFar = Infinity, dst) {
        const newDst = (dst ?? new Ctor(16));
        const f = 1 / Math.tan(fieldOfViewYInRadians * 0.5);
        newDst[0] = f / aspect;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = f;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (zFar === Infinity) {
            newDst[10] = 0;
            newDst[14] = zNear;
        }
        else {
            const rangeInv = 1 / (zFar - zNear);
            newDst[10] = zNear * rangeInv;
            newDst[14] = zFar * zNear * rangeInv;
        }
        return newDst;
    }
    /**
     * Computes a 4-by-4 orthogonal transformation matrix that transforms from
     * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y
     * and 0 to +1 in z.
     * @param left - Left side of the near clipping plane viewport.
     * @param right - Right side of the near clipping plane viewport.
     * @param bottom - Bottom of the near clipping plane viewport.
     * @param top - Top of the near clipping plane viewport.
     * @param near - The depth (negative z coordinate)
     *     of the near clipping plane.
     * @param far - The depth (negative z coordinate)
     *     of the far clipping plane.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The orthographic projection matrix.
     */
    function ortho(left, right, bottom, top, near, far, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 2 / (right - left);
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 / (top - bottom);
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1 / (near - far);
        newDst[11] = 0;
        newDst[12] = (right + left) / (left - right);
        newDst[13] = (top + bottom) / (bottom - top);
        newDst[14] = near / (near - far);
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 perspective transformation matrix given the left, right,
     * top, bottom, near and far clipping planes. The arguments define a frustum
     * extending in the negative z direction. The arguments near and far are the
     * distances to the near and far clipping planes. Note that near and far are not
     * z coordinates, but rather they are distances along the negative z-axis. The
     * matrix generated sends the viewing frustum to the unit box. We assume a unit
     * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
     * dimension.
     * @param left - The x coordinate of the left plane of the box.
     * @param right - The x coordinate of the right plane of the box.
     * @param bottom - The y coordinate of the bottom plane of the box.
     * @param top - The y coordinate of the right plane of the box.
     * @param near - The negative z coordinate of the near plane of the box.
     * @param far - The negative z coordinate of the far plane of the box.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The perspective projection matrix.
     */
    function frustum(left, right, bottom, top, near, far, dst) {
        const newDst = (dst ?? new Ctor(16));
        const dx = (right - left);
        const dy = (top - bottom);
        const dz = (near - far);
        newDst[0] = 2 * near / dx;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 * near / dy;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = (left + right) / dx;
        newDst[9] = (top + bottom) / dy;
        newDst[10] = far / dz;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = near * far / dz;
        newDst[15] = 0;
        return newDst;
    }
    /**
     * Computes a 4-by-4 reverse-z perspective transformation matrix given the left, right,
     * top, bottom, near and far clipping planes. The arguments define a frustum
     * extending in the negative z direction. The arguments near and far are the
     * distances to the near and far clipping planes. Note that near and far are not
     * z coordinates, but rather they are distances along the negative z-axis. The
     * matrix generated sends the viewing frustum to the unit box. We assume a unit
     * box extending from -1 to 1 in the x and y dimensions and from 1 (-near) to 0 (-far) in the z
     * dimension.
     * @param left - The x coordinate of the left plane of the box.
     * @param right - The x coordinate of the right plane of the box.
     * @param bottom - The y coordinate of the bottom plane of the box.
     * @param top - The y coordinate of the right plane of the box.
     * @param near - The negative z coordinate of the near plane of the box.
     * @param far - The negative z coordinate of the far plane of the box.
     * @param dst - Output matrix. If not passed a new one is created.
     * @returns The perspective projection matrix.
     */
    function frustumReverseZ(left, right, bottom, top, near, far = Infinity, dst) {
        const newDst = (dst ?? new Ctor(16));
        const dx = (right - left);
        const dy = (top - bottom);
        newDst[0] = 2 * near / dx;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 2 * near / dy;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = (left + right) / dx;
        newDst[9] = (top + bottom) / dy;
        newDst[11] = -1;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[15] = 0;
        if (far === Infinity) {
            newDst[10] = 0;
            newDst[14] = near;
        }
        else {
            const rangeInv = 1 / (far - near);
            newDst[10] = near * rangeInv;
            newDst[14] = far * near * rangeInv;
        }
        return newDst;
    }
    const xAxis = vec3.create();
    const yAxis = vec3.create();
    const zAxis = vec3.create();
    /**
     * Computes a 4-by-4 aim transformation.
     *
     * This is a matrix which positions an object aiming down positive Z.
     * toward the target.
     *
     * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.
     *
     * @param position - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The aim matrix.
     */
    function aim(position, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(target, position, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = xAxis[1];
        newDst[2] = xAxis[2];
        newDst[3] = 0;
        newDst[4] = yAxis[0];
        newDst[5] = yAxis[1];
        newDst[6] = yAxis[2];
        newDst[7] = 0;
        newDst[8] = zAxis[0];
        newDst[9] = zAxis[1];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = position[0];
        newDst[13] = position[1];
        newDst[14] = position[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 camera aim transformation.
     *
     * This is a matrix which positions an object aiming down negative Z.
     * toward the target.
     *
     * Note: this is the inverse of `lookAt`
     *
     * @param eye - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The aim matrix.
     */
    function cameraAim(eye, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = xAxis[1];
        newDst[2] = xAxis[2];
        newDst[3] = 0;
        newDst[4] = yAxis[0];
        newDst[5] = yAxis[1];
        newDst[6] = yAxis[2];
        newDst[7] = 0;
        newDst[8] = zAxis[0];
        newDst[9] = zAxis[1];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = eye[0];
        newDst[13] = eye[1];
        newDst[14] = eye[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Computes a 4-by-4 view transformation.
     *
     * This is a view matrix which transforms all other objects
     * to be in the space of the view defined by the parameters.
     *
     * @param eye - The position of the object.
     * @param target - The position meant to be aimed at.
     * @param up - A vector pointing up.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The look-at matrix.
     */
    function lookAt(eye, target, up, dst) {
        const newDst = (dst ?? new Ctor(16));
        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);
        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);
        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);
        newDst[0] = xAxis[0];
        newDst[1] = yAxis[0];
        newDst[2] = zAxis[0];
        newDst[3] = 0;
        newDst[4] = xAxis[1];
        newDst[5] = yAxis[1];
        newDst[6] = zAxis[1];
        newDst[7] = 0;
        newDst[8] = xAxis[2];
        newDst[9] = yAxis[2];
        newDst[10] = zAxis[2];
        newDst[11] = 0;
        newDst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);
        newDst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);
        newDst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which translates by the given vector v.
     * @param v - The vector by
     *     which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translation matrix.
     */
    function translation(v, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = v[0];
        newDst[13] = v[1];
        newDst[14] = v[2];
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Translates the given 4-by-4 matrix by the given vector v.
     * @param m - The matrix.
     * @param v - The vector by
     *     which to translate.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The translated matrix.
     */
    function translate(m, v, dst) {
        const newDst = (dst ?? new Ctor(16));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m03 = m[3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const m30 = m[3 * 4 + 0];
        const m31 = m[3 * 4 + 1];
        const m32 = m[3 * 4 + 2];
        const m33 = m[3 * 4 + 3];
        if (m !== newDst) {
            newDst[0] = m00;
            newDst[1] = m01;
            newDst[2] = m02;
            newDst[3] = m03;
            newDst[4] = m10;
            newDst[5] = m11;
            newDst[6] = m12;
            newDst[7] = m13;
            newDst[8] = m20;
            newDst[9] = m21;
            newDst[10] = m22;
            newDst[11] = m23;
        }
        newDst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
        newDst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
        newDst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
        newDst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationX(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = 1;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = c;
        newDst[6] = s;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = -s;
        newDst[10] = c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the x-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateX(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m10 = m[4];
        const m11 = m[5];
        const m12 = m[6];
        const m13 = m[7];
        const m20 = m[8];
        const m21 = m[9];
        const m22 = m[10];
        const m23 = m[11];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[4] = c * m10 + s * m20;
        newDst[5] = c * m11 + s * m21;
        newDst[6] = c * m12 + s * m22;
        newDst[7] = c * m13 + s * m23;
        newDst[8] = c * m20 - s * m10;
        newDst[9] = c * m21 - s * m11;
        newDst[10] = c * m22 - s * m12;
        newDst[11] = c * m23 - s * m13;
        if (m !== newDst) {
            newDst[0] = m[0];
            newDst[1] = m[1];
            newDst[2] = m[2];
            newDst[3] = m[3];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationY(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = 0;
        newDst[2] = -s;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = 1;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = s;
        newDst[9] = 0;
        newDst[10] = c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the y-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateY(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m20 = m[2 * 4 + 0];
        const m21 = m[2 * 4 + 1];
        const m22 = m[2 * 4 + 2];
        const m23 = m[2 * 4 + 3];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 - s * m20;
        newDst[1] = c * m01 - s * m21;
        newDst[2] = c * m02 - s * m22;
        newDst[3] = c * m03 - s * m23;
        newDst[8] = c * m20 + s * m00;
        newDst[9] = c * m21 + s * m01;
        newDst[10] = c * m22 + s * m02;
        newDst[11] = c * m23 + s * m03;
        if (m !== newDst) {
            newDst[4] = m[4];
            newDst[5] = m[5];
            newDst[6] = m[6];
            newDst[7] = m[7];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotation matrix.
     */
    function rotationZ(angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c;
        newDst[1] = s;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = -s;
        newDst[5] = c;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = 1;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the z-axis by the given
     * angle.
     * @param m - The matrix.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function rotateZ(m, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        const m00 = m[0 * 4 + 0];
        const m01 = m[0 * 4 + 1];
        const m02 = m[0 * 4 + 2];
        const m03 = m[0 * 4 + 3];
        const m10 = m[1 * 4 + 0];
        const m11 = m[1 * 4 + 1];
        const m12 = m[1 * 4 + 2];
        const m13 = m[1 * 4 + 3];
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        newDst[0] = c * m00 + s * m10;
        newDst[1] = c * m01 + s * m11;
        newDst[2] = c * m02 + s * m12;
        newDst[3] = c * m03 + s * m13;
        newDst[4] = c * m10 - s * m00;
        newDst[5] = c * m11 - s * m01;
        newDst[6] = c * m12 - s * m02;
        newDst[7] = c * m13 - s * m03;
        if (m !== newDst) {
            newDst[8] = m[8];
            newDst[9] = m[9];
            newDst[10] = m[10];
            newDst[11] = m[11];
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the given axis by the given
     * angle.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A matrix which rotates angle radians
     *     around the axis.
     */
    function axisRotation(axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        let x = axis[0];
        let y = axis[1];
        let z = axis[2];
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        const oneMinusCosine = 1 - c;
        newDst[0] = xx + (1 - xx) * c;
        newDst[1] = x * y * oneMinusCosine + z * s;
        newDst[2] = x * z * oneMinusCosine - y * s;
        newDst[3] = 0;
        newDst[4] = x * y * oneMinusCosine - z * s;
        newDst[5] = yy + (1 - yy) * c;
        newDst[6] = y * z * oneMinusCosine + x * s;
        newDst[7] = 0;
        newDst[8] = x * z * oneMinusCosine + y * s;
        newDst[9] = y * z * oneMinusCosine - x * s;
        newDst[10] = zz + (1 - zz) * c;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which rotates around the given axis by the given
     * angle. (same as axisRotation)
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns A matrix which rotates angle radians
     *     around the axis.
     */
    const rotation = axisRotation;
    /**
     * Rotates the given 4-by-4 matrix around the given axis by the
     * given angle.
     * @param m - The matrix.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    function axisRotate(m, axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(16));
        let x = axis[0];
        let y = axis[1];
        let z = axis[2];
        const n = Math.sqrt(x * x + y * y + z * z);
        x /= n;
        y /= n;
        z /= n;
        const xx = x * x;
        const yy = y * y;
        const zz = z * z;
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        const oneMinusCosine = 1 - c;
        const r00 = xx + (1 - xx) * c;
        const r01 = x * y * oneMinusCosine + z * s;
        const r02 = x * z * oneMinusCosine - y * s;
        const r10 = x * y * oneMinusCosine - z * s;
        const r11 = yy + (1 - yy) * c;
        const r12 = y * z * oneMinusCosine + x * s;
        const r20 = x * z * oneMinusCosine + y * s;
        const r21 = y * z * oneMinusCosine - x * s;
        const r22 = zz + (1 - zz) * c;
        const m00 = m[0];
        const m01 = m[1];
        const m02 = m[2];
        const m03 = m[3];
        const m10 = m[4];
        const m11 = m[5];
        const m12 = m[6];
        const m13 = m[7];
        const m20 = m[8];
        const m21 = m[9];
        const m22 = m[10];
        const m23 = m[11];
        newDst[0] = r00 * m00 + r01 * m10 + r02 * m20;
        newDst[1] = r00 * m01 + r01 * m11 + r02 * m21;
        newDst[2] = r00 * m02 + r01 * m12 + r02 * m22;
        newDst[3] = r00 * m03 + r01 * m13 + r02 * m23;
        newDst[4] = r10 * m00 + r11 * m10 + r12 * m20;
        newDst[5] = r10 * m01 + r11 * m11 + r12 * m21;
        newDst[6] = r10 * m02 + r11 * m12 + r12 * m22;
        newDst[7] = r10 * m03 + r11 * m13 + r12 * m23;
        newDst[8] = r20 * m00 + r21 * m10 + r22 * m20;
        newDst[9] = r20 * m01 + r21 * m11 + r22 * m21;
        newDst[10] = r20 * m02 + r21 * m12 + r22 * m22;
        newDst[11] = r20 * m03 + r21 * m13 + r22 * m23;
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Rotates the given 4-by-4 matrix around the given axis by the
     * given angle. (same as rotate)
     * @param m - The matrix.
     * @param axis - The axis
     *     about which to rotate.
     * @param angleInRadians - The angle by which to rotate (in radians).
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The rotated matrix.
     */
    const rotate = axisRotate;
    /**
     * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
     * the corresponding entry in the given vector; assumes the vector has three
     * entries.
     * @param v - A vector of
     *     three entries specifying the factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function scaling(v, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = v[0];
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = v[1];
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = v[2];
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Scales the given 4-by-4 matrix in each dimension by an amount
     * given by the corresponding entry in the given vector; assumes the vector has
     * three entries.
     * @param m - The matrix to be modified.
     * @param v - A vector of three entries specifying the
     *     factor by which to scale in each dimension.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function scale(m, v, dst) {
        const newDst = (dst ?? new Ctor(16));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        newDst[0] = v0 * m[0 * 4 + 0];
        newDst[1] = v0 * m[0 * 4 + 1];
        newDst[2] = v0 * m[0 * 4 + 2];
        newDst[3] = v0 * m[0 * 4 + 3];
        newDst[4] = v1 * m[1 * 4 + 0];
        newDst[5] = v1 * m[1 * 4 + 1];
        newDst[6] = v1 * m[1 * 4 + 2];
        newDst[7] = v1 * m[1 * 4 + 3];
        newDst[8] = v2 * m[2 * 4 + 0];
        newDst[9] = v2 * m[2 * 4 + 1];
        newDst[10] = v2 * m[2 * 4 + 2];
        newDst[11] = v2 * m[2 * 4 + 3];
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    /**
     * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.
     * @param s - the amount to scale
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaling matrix.
     */
    function uniformScaling(s, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = s;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        newDst[4] = 0;
        newDst[5] = s;
        newDst[6] = 0;
        newDst[7] = 0;
        newDst[8] = 0;
        newDst[9] = 0;
        newDst[10] = s;
        newDst[11] = 0;
        newDst[12] = 0;
        newDst[13] = 0;
        newDst[14] = 0;
        newDst[15] = 1;
        return newDst;
    }
    /**
     * Scales the given 4-by-4 matrix in each dimension by a uniform scale.
     * @param m - The matrix to be modified.
     * @param s - The amount to scale.
     * @param dst - matrix to hold result. If not passed a new one is created.
     * @returns The scaled matrix.
     */
    function uniformScale(m, s, dst) {
        const newDst = (dst ?? new Ctor(16));
        newDst[0] = s * m[0 * 4 + 0];
        newDst[1] = s * m[0 * 4 + 1];
        newDst[2] = s * m[0 * 4 + 2];
        newDst[3] = s * m[0 * 4 + 3];
        newDst[4] = s * m[1 * 4 + 0];
        newDst[5] = s * m[1 * 4 + 1];
        newDst[6] = s * m[1 * 4 + 2];
        newDst[7] = s * m[1 * 4 + 3];
        newDst[8] = s * m[2 * 4 + 0];
        newDst[9] = s * m[2 * 4 + 1];
        newDst[10] = s * m[2 * 4 + 2];
        newDst[11] = s * m[2 * 4 + 3];
        if (m !== newDst) {
            newDst[12] = m[12];
            newDst[13] = m[13];
            newDst[14] = m[14];
            newDst[15] = m[15];
        }
        return newDst;
    }
    return {
        create,
        set,
        fromMat3,
        fromQuat,
        negate,
        copy,
        clone,
        equalsApproximately,
        equals,
        identity,
        transpose,
        inverse,
        determinant,
        invert,
        multiply,
        mul,
        setTranslation,
        getTranslation,
        getAxis,
        setAxis,
        getScaling,
        perspective,
        perspectiveReverseZ,
        ortho,
        frustum,
        frustumReverseZ,
        aim,
        cameraAim,
        lookAt,
        translation,
        translate,
        rotationX,
        rotateX,
        rotationY,
        rotateY,
        rotationZ,
        rotateZ,
        axisRotation,
        rotation,
        axisRotate,
        rotate,
        scaling,
        scale,
        uniformScaling,
        uniformScale,
    };
}
const cache$2 = new Map();
function getAPI$2(Ctor) {
    let api = cache$2.get(Ctor);
    if (!api) {
        api = getAPIImpl$2(Ctor);
        cache$2.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Qud
 * */
function getAPIImpl$1(Ctor) {
    const vec3 = getAPI$3(Ctor);
    /**
     * Creates a quat4; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param w - Initial w value.
     * @returns the created vector
     */
    function create(x, y, z, w) {
        const newDst = new Ctor(4);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                    if (w !== undefined) {
                        newDst[3] = w;
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a Quat; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param z - Initial w value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Quat
     * Also see {@link quat.create} and {@link quat.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param w fourth value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, w, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        newDst[3] = w;
        return newDst;
    }
    /**
     * Sets a quaternion from the given angle and  axis,
     * then returns it.
     *
     * @param axis - the axis to rotate around
     * @param angleInRadians - the angle
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The quaternion that represents the given axis and angle
     **/
    function fromAxisAngle(axis, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const s = Math.sin(halfAngle);
        newDst[0] = s * axis[0];
        newDst[1] = s * axis[1];
        newDst[2] = s * axis[2];
        newDst[3] = Math.cos(halfAngle);
        return newDst;
    }
    /**
     * Gets the rotation axis and angle
     * @param q - quaternion to compute from
     * @param dst - Vec3 to hold result. If not passed in a new one is created.
     * @return angle and axis
     */
    function toAxisAngle(q, dst) {
        const newDst = (dst ?? vec3.create(3));
        const angle = Math.acos(q[3]) * 2;
        const s = Math.sin(angle * 0.5);
        if (s > EPSILON) {
            newDst[0] = q[0] / s;
            newDst[1] = q[1] / s;
            newDst[2] = q[2] / s;
        }
        else {
            newDst[0] = 1;
            newDst[1] = 0;
            newDst[2] = 0;
        }
        return { angle, axis: newDst };
    }
    /**
     * Returns the angle in degrees between two rotations a and b.
     * @param a - quaternion a
     * @param b - quaternion b
     * @return angle in radians between the two quaternions
     */
    function angle(a, b) {
        const d = dot(a, b);
        return Math.acos(2 * d * d - 1);
    }
    /**
     * Multiplies two quaternions
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const aw = a[3];
        const bx = b[0];
        const by = b[1];
        const bz = b[2];
        const bw = b[3];
        newDst[0] = ax * bw + aw * bx + ay * bz - az * by;
        newDst[1] = ay * bw + aw * by + az * bx - ax * bz;
        newDst[2] = az * bw + aw * bz + ax * by - ay * bx;
        newDst[3] = aw * bw - ax * bx - ay * by - az * bz;
        return newDst;
    }
    /**
     * Multiplies two quaternions
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    const mul = multiply;
    /**
     * Rotates the given quaternion around the X axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateX(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const bx = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw + qw * bx;
        newDst[1] = qy * bw + qz * bx;
        newDst[2] = qz * bw - qy * bx;
        newDst[3] = qw * bw - qx * bx;
        return newDst;
    }
    /**
     * Rotates the given quaternion around the Y axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateY(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const by = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw - qz * by;
        newDst[1] = qy * bw + qw * by;
        newDst[2] = qz * bw + qx * by;
        newDst[3] = qw * bw - qy * by;
        return newDst;
    }
    /**
     * Rotates the given quaternion around the Z axis by the given angle.
     * @param q - quaternion to rotate
     * @param angleInRadians - The angle by which to rotate
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function rotateZ(q, angleInRadians, dst) {
        const newDst = (dst ?? new Ctor(4));
        const halfAngle = angleInRadians * 0.5;
        const qx = q[0];
        const qy = q[1];
        const qz = q[2];
        const qw = q[3];
        const bz = Math.sin(halfAngle);
        const bw = Math.cos(halfAngle);
        newDst[0] = qx * bw + qy * bz;
        newDst[1] = qy * bw - qx * bz;
        newDst[2] = qz * bw + qw * bz;
        newDst[3] = qw * bw - qz * bz;
        return newDst;
    }
    /**
     * Spherically linear interpolate between two quaternions
     *
     * @param a - starting value
     * @param b - ending value
     * @param t - value where 0 = a and 1 = b
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the result of a * b
     */
    function slerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        const ax = a[0];
        const ay = a[1];
        const az = a[2];
        const aw = a[3];
        let bx = b[0];
        let by = b[1];
        let bz = b[2];
        let bw = b[3];
        let cosOmega = ax * bx + ay * by + az * bz + aw * bw;
        if (cosOmega < 0) {
            cosOmega = -cosOmega;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
        }
        let scale0;
        let scale1;
        if (1.0 - cosOmega > EPSILON) {
            const omega = Math.acos(cosOmega);
            const sinOmega = Math.sin(omega);
            scale0 = Math.sin((1 - t) * omega) / sinOmega;
            scale1 = Math.sin(t * omega) / sinOmega;
        }
        else {
            scale0 = 1.0 - t;
            scale1 = t;
        }
        newDst[0] = scale0 * ax + scale1 * bx;
        newDst[1] = scale0 * ay + scale1 * by;
        newDst[2] = scale0 * az + scale1 * bz;
        newDst[3] = scale0 * aw + scale1 * bw;
        return newDst;
    }
    /**
     * Compute the inverse of a quaternion
     *
     * @param q - quaternion to compute the inverse of
     * @returns A quaternion that is the result of a * b
     */
    function inverse(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        const a0 = q[0];
        const a1 = q[1];
        const a2 = q[2];
        const a3 = q[3];
        const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
        const invDot = dot ? 1 / dot : 0;
        newDst[0] = -a0 * invDot;
        newDst[1] = -a1 * invDot;
        newDst[2] = -a2 * invDot;
        newDst[3] = a3 * invDot;
        return newDst;
    }
    /**
     * Compute the conjugate of a quaternion
     * For quaternions with a magnitude of 1 (a unit quaternion)
     * this returns the same as the inverse but is faster to calculate.
     *
     * @param q - quaternion to compute the conjugate of.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The conjugate of q
     */
    function conjugate(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = -q[0];
        newDst[1] = -q[1];
        newDst[2] = -q[2];
        newDst[3] = q[3];
        return newDst;
    }
    /**
     * Creates a quaternion from the given rotation matrix.
     *
     * The created quaternion is not normalized.
     *
     * @param m - rotation matrix
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns the result
     */
    function fromMat(m, dst) {
        const newDst = (dst ?? new Ctor(4));
        /*
        0 1 2
        3 4 5
        6 7 8
      
        0 1 2
        4 5 6
        8 9 10
         */
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".
        const trace = m[0] + m[5] + m[10];
        if (trace > 0.0) {
            // |w| > 1/2, may as well choose w > 1/2
            const root = Math.sqrt(trace + 1); // 2w
            newDst[3] = 0.5 * root;
            const invRoot = 0.5 / root; // 1/(4w)
            newDst[0] = (m[6] - m[9]) * invRoot;
            newDst[1] = (m[8] - m[2]) * invRoot;
            newDst[2] = (m[1] - m[4]) * invRoot;
        }
        else {
            // |w| <= 1/2
            let i = 0;
            if (m[5] > m[0]) {
                i = 1;
            }
            if (m[10] > m[i * 4 + i]) {
                i = 2;
            }
            const j = (i + 1) % 3;
            const k = (i + 2) % 3;
            const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);
            newDst[i] = 0.5 * root;
            const invRoot = 0.5 / root;
            newDst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;
            newDst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;
            newDst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;
        }
        return newDst;
    }
    /**
     * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.
     *
     * @param xAngleInRadians - angle to rotate around X axis in radians.
     * @param yAngleInRadians - angle to rotate around Y axis in radians.
     * @param zAngleInRadians - angle to rotate around Z axis in radians.
     * @param order - order to apply euler angles
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion representing the same rotation as the euler angles applied in the given order
     */
    function fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {
        const newDst = (dst ?? new Ctor(4));
        const xHalfAngle = xAngleInRadians * 0.5;
        const yHalfAngle = yAngleInRadians * 0.5;
        const zHalfAngle = zAngleInRadians * 0.5;
        const sx = Math.sin(xHalfAngle);
        const cx = Math.cos(xHalfAngle);
        const sy = Math.sin(yHalfAngle);
        const cy = Math.cos(yHalfAngle);
        const sz = Math.sin(zHalfAngle);
        const cz = Math.cos(zHalfAngle);
        switch (order) {
            case 'xyz':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'xzy':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            case 'yxz':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz - sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            case 'yzx':
                newDst[0] = sx * cy * cz + cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'zxy':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz + sx * sy * cz;
                newDst[3] = cx * cy * cz - sx * sy * sz;
                break;
            case 'zyx':
                newDst[0] = sx * cy * cz - cx * sy * sz;
                newDst[1] = cx * sy * cz + sx * cy * sz;
                newDst[2] = cx * cy * sz - sx * sy * cz;
                newDst[3] = cx * cy * cz + sx * sy * sz;
                break;
            default:
                throw new Error(`Unknown rotation order: ${order}`);
        }
        return newDst;
    }
    /**
     * Copies a quaternion. (same as {@link quat.clone})
     * Also see {@link quat.create} and {@link quat.set}
     * @param q - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is a copy of q
     */
    function copy(q, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = q[0];
        newDst[1] = q[1];
        newDst[2] = q[2];
        newDst[3] = q[3];
        return newDst;
    }
    /**
     * Clones a quaternion. (same as {@link quat.copy})
     * Also see {@link quat.create} and {@link quat.set}
     * @param q - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A copy of q.
     */
    const clone = copy;
    /**
     * Adds two quaternions; assumes a and b have the same dimension.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        newDst[3] = a[3] + b[3];
        return newDst;
    }
    /**
     * Subtracts two quaternions.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        newDst[3] = a[3] - b[3];
        return newDst;
    }
    /**
     * Subtracts two quaternions.
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns A quaternion that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Multiplies a quaternion by a scalar.
     * @param v - The quaternion.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        newDst[3] = v[3] * k;
        return newDst;
    }
    /**
     * Multiplies a quaternion by a scalar. (same as mulScalar)
     * @param v - The quaternion.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The scaled quaternion.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        newDst[3] = v[3] / k;
        return newDst;
    }
    /**
     * Computes the dot product of two quaternions
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);
    }
    /**
     * Performs linear interpolation on two quaternions.
     * Given quaternions a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @param t - Interpolation coefficient.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        newDst[3] = a[3] + t * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Computes the length of quaternion
     * @param v - quaternion.
     * @returns length of quaternion.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
    }
    /**
     * Computes the length of quaternion (same as length)
     * @param v - quaternion.
     * @returns length of quaternion.
     */
    const len = length;
    /**
     * Computes the square of the length of quaternion
     * @param v - quaternion.
     * @returns square of the length of quaternion.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
    }
    /**
     * Computes the square of the length of quaternion (same as lengthSq)
     * @param v - quaternion.
     * @returns square of the length of quaternion.
     */
    const lenSq = lengthSq;
    /**
     * Divides a quaternion by its Euclidean length and returns the quotient.
     * @param v - The quaternion.
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns The normalized quaternion.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
            newDst[3] = v3 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 0;
        }
        return newDst;
    }
    /**
     * Check if 2 quaternions are approximately equal
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns true if quaternions are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON;
    }
    /**
     * Check if 2 quaternions are exactly equal
     * @param a - Operand quaternion.
     * @param b - Operand quaternion.
     * @returns true if quaternions are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    }
    /**
     * Creates an identity quaternion
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns an identity quaternion
     */
    function identity(dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 1;
        return newDst;
    }
    const tempVec3 = vec3.create();
    const xUnitVec3 = vec3.create();
    const yUnitVec3 = vec3.create();
    /**
     * Computes a quaternion to represent the shortest rotation from one vector to another.
     *
     * @param aUnit - the start vector
     * @param bUnit - the end vector
     * @param dst - quaternion to hold result. If not passed in a new one is created.
     * @returns the result
     */
    function rotationTo(aUnit, bUnit, dst) {
        const newDst = (dst ?? new Ctor(4));
        const dot = vec3.dot(aUnit, bUnit);
        if (dot < -0.999999) {
            vec3.cross(xUnitVec3, aUnit, tempVec3);
            if (vec3.len(tempVec3) < 0.000001) {
                vec3.cross(yUnitVec3, aUnit, tempVec3);
            }
            vec3.normalize(tempVec3, tempVec3);
            fromAxisAngle(tempVec3, Math.PI, newDst);
            return newDst;
        }
        else if (dot > 0.999999) {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 1;
            return newDst;
        }
        else {
            vec3.cross(aUnit, bUnit, tempVec3);
            newDst[0] = tempVec3[0];
            newDst[1] = tempVec3[1];
            newDst[2] = tempVec3[2];
            newDst[3] = 1 + dot;
            return normalize(newDst, newDst);
        }
    }
    const tempQuat1 = new Ctor(4);
    const tempQuat2 = new Ctor(4);
    /**
     * Performs a spherical linear interpolation with two control points
     *
     * @param a - the first quaternion
     * @param b - the second quaternion
     * @param c - the third quaternion
     * @param d - the fourth quaternion
     * @param t - Interpolation coefficient 0 to 1
     * @returns result
     */
    function sqlerp(a, b, c, d, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        slerp(a, d, t, tempQuat1);
        slerp(b, c, t, tempQuat2);
        slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), newDst);
        return newDst;
    }
    return {
        create,
        fromValues,
        set,
        fromAxisAngle,
        toAxisAngle,
        angle,
        multiply,
        mul,
        rotateX,
        rotateY,
        rotateZ,
        slerp,
        inverse,
        conjugate,
        fromMat,
        fromEuler,
        copy,
        clone,
        add,
        subtract,
        sub,
        mulScalar,
        scale,
        divScalar,
        dot,
        lerp,
        length,
        len,
        lengthSq,
        lenSq,
        normalize,
        equalsApproximately,
        equals,
        identity,
        rotationTo,
        sqlerp,
    };
}
const cache$1 = new Map();
/**
 *
 * Quat4 math functions.
 *
 * Almost all functions take an optional `newDst` argument. If it is not passed in the
 * functions will create a new `Quat4`. In other words you can do this
 *
 *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = quat4.create();
 *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
function getAPI$1(Ctor) {
    let api = cache$1.get(Ctor);
    if (!api) {
        api = getAPIImpl$1(Ctor);
        cache$1.set(Ctor, api);
    }
    return api;
}

/*
 * Copyright 2022 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/**
 * Generates am typed API for Vec4
 * */
function getAPIImpl(Ctor) {
    /**
     * Creates a vec4; may be called with x, y, z to set initial values.
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param w - Initial w value.
     * @returns the created vector
     */
    function create(x, y, z, w) {
        const newDst = new Ctor(4);
        if (x !== undefined) {
            newDst[0] = x;
            if (y !== undefined) {
                newDst[1] = y;
                if (z !== undefined) {
                    newDst[2] = z;
                    if (w !== undefined) {
                        newDst[3] = w;
                    }
                }
            }
        }
        return newDst;
    }
    /**
     * Creates a vec4; may be called with x, y, z to set initial values. (same as create)
     * @param x - Initial x value.
     * @param y - Initial y value.
     * @param z - Initial z value.
     * @param z - Initial w value.
     * @returns the created vector
     */
    const fromValues = create;
    /**
     * Sets the values of a Vec4
     * Also see {@link vec4.create} and {@link vec4.copy}
     *
     * @param x first value
     * @param y second value
     * @param z third value
     * @param w fourth value
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector with its elements set.
     */
    function set(x, y, z, w, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = x;
        newDst[1] = y;
        newDst[2] = z;
        newDst[3] = w;
        return newDst;
    }
    /**
     * Applies Math.ceil to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the ceil of each element of v.
     */
    function ceil(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.ceil(v[0]);
        newDst[1] = Math.ceil(v[1]);
        newDst[2] = Math.ceil(v[2]);
        newDst[3] = Math.ceil(v[3]);
        return newDst;
    }
    /**
     * Applies Math.floor to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the floor of each element of v.
     */
    function floor(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.floor(v[0]);
        newDst[1] = Math.floor(v[1]);
        newDst[2] = Math.floor(v[2]);
        newDst[3] = Math.floor(v[3]);
        return newDst;
    }
    /**
     * Applies Math.round to each element of vector
     * @param v - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the round of each element of v.
     */
    function round(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.round(v[0]);
        newDst[1] = Math.round(v[1]);
        newDst[2] = Math.round(v[2]);
        newDst[3] = Math.round(v[3]);
        return newDst;
    }
    /**
     * Clamp each element of vector between min and max
     * @param v - Operand vector.
     * @param max - Min value, default 0
     * @param min - Max value, default 1
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that the clamped value of each element of v.
     */
    function clamp(v, min = 0, max = 1, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.min(max, Math.max(min, v[0]));
        newDst[1] = Math.min(max, Math.max(min, v[1]));
        newDst[2] = Math.min(max, Math.max(min, v[2]));
        newDst[3] = Math.min(max, Math.max(min, v[3]));
        return newDst;
    }
    /**
     * Adds two vectors; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a and b.
     */
    function add(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0];
        newDst[1] = a[1] + b[1];
        newDst[2] = a[2] + b[2];
        newDst[3] = a[3] + b[3];
        return newDst;
    }
    /**
     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param scale - Amount to scale b
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the sum of a + b * scale.
     */
    function addScaled(a, b, scale, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + b[0] * scale;
        newDst[1] = a[1] + b[1] * scale;
        newDst[2] = a[2] + b[2] * scale;
        newDst[3] = a[3] + b[3] * scale;
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    function subtract(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] - b[0];
        newDst[1] = a[1] - b[1];
        newDst[2] = a[2] - b[2];
        newDst[3] = a[3] - b[3];
        return newDst;
    }
    /**
     * Subtracts two vectors.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A vector that is the difference of a and b.
     */
    const sub = subtract;
    /**
     * Check if 2 vectors are approximately equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are approximately equal
     */
    function equalsApproximately(a, b) {
        return Math.abs(a[0] - b[0]) < EPSILON &&
            Math.abs(a[1] - b[1]) < EPSILON &&
            Math.abs(a[2] - b[2]) < EPSILON &&
            Math.abs(a[3] - b[3]) < EPSILON;
    }
    /**
     * Check if 2 vectors are exactly equal
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns true if vectors are exactly equal
     */
    function equals(a, b) {
        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficient.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The linear interpolated result.
     */
    function lerp(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t * (b[0] - a[0]);
        newDst[1] = a[1] + t * (b[1] - a[1]);
        newDst[2] = a[2] + t * (b[2] - a[2]);
        newDst[3] = a[3] + t * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Performs linear interpolation on two vectors.
     * Given vectors a and b and interpolation coefficient vector t, returns
     * a + t * (b - a).
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param t - Interpolation coefficients vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns the linear interpolated result.
     */
    function lerpV(a, b, t, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] + t[0] * (b[0] - a[0]);
        newDst[1] = a[1] + t[1] * (b[1] - a[1]);
        newDst[2] = a[2] + t[2] * (b[2] - a[2]);
        newDst[3] = a[3] + t[3] * (b[3] - a[3]);
        return newDst;
    }
    /**
     * Return max values of two vectors.
     * Given vectors a and b returns
     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The max components vector.
     */
    function max(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.max(a[0], b[0]);
        newDst[1] = Math.max(a[1], b[1]);
        newDst[2] = Math.max(a[2], b[2]);
        newDst[3] = Math.max(a[3], b[3]);
        return newDst;
    }
    /**
     * Return min values of two vectors.
     * Given vectors a and b returns
     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The min components vector.
     */
    function min(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = Math.min(a[0], b[0]);
        newDst[1] = Math.min(a[1], b[1]);
        newDst[2] = Math.min(a[2], b[2]);
        newDst[3] = Math.min(a[3], b[3]);
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function mulScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] * k;
        newDst[1] = v[1] * k;
        newDst[2] = v[2] * k;
        newDst[3] = v[3] * k;
        return newDst;
    }
    /**
     * Multiplies a vector by a scalar. (same as mulScalar)
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    const scale = mulScalar;
    /**
     * Divides a vector by a scalar.
     * @param v - The vector.
     * @param k - The scalar.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The scaled vector.
     */
    function divScalar(v, k, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0] / k;
        newDst[1] = v[1] / k;
        newDst[2] = v[2] / k;
        newDst[3] = v[3] / k;
        return newDst;
    }
    /**
     * Inverse a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    function inverse(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 1 / v[0];
        newDst[1] = 1 / v[1];
        newDst[2] = 1 / v[2];
        newDst[3] = 1 / v[3];
        return newDst;
    }
    /**
     * Invert a vector. (same as inverse)
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The inverted vector.
     */
    const invert = inverse;
    /**
     * Computes the dot product of two vectors
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @returns dot product
     */
    function dot(a, b) {
        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);
    }
    /**
     * Computes the length of vector
     * @param v - vector.
     * @returns length of vector.
     */
    function length(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
    }
    /**
     * Computes the length of vector (same as length)
     * @param v - vector.
     * @returns length of vector.
     */
    const len = length;
    /**
     * Computes the square of the length of vector
     * @param v - vector.
     * @returns square of the length of vector.
     */
    function lengthSq(v) {
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;
    }
    /**
     * Computes the square of the length of vector (same as lengthSq)
     * @param v - vector.
     * @returns square of the length of vector.
     */
    const lenSq = lengthSq;
    /**
     * Computes the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    function distance(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        const dw = a[3] - b[3];
        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);
    }
    /**
     * Computes the distance between 2 points (same as distance)
     * @param a - vector.
     * @param b - vector.
     * @returns distance between a and b
     */
    const dist = distance;
    /**
     * Computes the square of the distance between 2 points
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    function distanceSq(a, b) {
        const dx = a[0] - b[0];
        const dy = a[1] - b[1];
        const dz = a[2] - b[2];
        const dw = a[3] - b[3];
        return dx * dx + dy * dy + dz * dz + dw * dw;
    }
    /**
     * Computes the square of the distance between 2 points (same as distanceSq)
     * @param a - vector.
     * @param b - vector.
     * @returns square of the distance between a and b
     */
    const distSq = distanceSq;
    /**
     * Divides a vector by its Euclidean length and returns the quotient.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The normalized vector.
     */
    function normalize(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        const v0 = v[0];
        const v1 = v[1];
        const v2 = v[2];
        const v3 = v[3];
        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);
        if (len > 0.00001) {
            newDst[0] = v0 / len;
            newDst[1] = v1 / len;
            newDst[2] = v2 / len;
            newDst[3] = v3 / len;
        }
        else {
            newDst[0] = 0;
            newDst[1] = 0;
            newDst[2] = 0;
            newDst[3] = 0;
        }
        return newDst;
    }
    /**
     * Negates a vector.
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns -v.
     */
    function negate(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = -v[0];
        newDst[1] = -v[1];
        newDst[2] = -v[2];
        newDst[3] = -v[3];
        return newDst;
    }
    /**
     * Copies a vector. (same as {@link vec4.clone})
     * Also see {@link vec4.create} and {@link vec4.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    function copy(v, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = v[0];
        newDst[1] = v[1];
        newDst[2] = v[2];
        newDst[3] = v[3];
        return newDst;
    }
    /**
     * Clones a vector. (same as {@link vec4.copy})
     * Also see {@link vec4.create} and {@link vec4.set}
     * @param v - The vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns A copy of v.
     */
    const clone = copy;
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    function multiply(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] * b[0];
        newDst[1] = a[1] * b[1];
        newDst[2] = a[2] * b[2];
        newDst[3] = a[3] * b[3];
        return newDst;
    }
    /**
     * Multiplies a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as mul)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of products of entries of a and b.
     */
    const mul = multiply;
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length.
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    function divide(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = a[0] / b[0];
        newDst[1] = a[1] / b[1];
        newDst[2] = a[2] / b[2];
        newDst[3] = a[3] / b[3];
        return newDst;
    }
    /**
     * Divides a vector by another vector (component-wise); assumes a and
     * b have the same length. (same as divide)
     * @param a - Operand vector.
     * @param b - Operand vector.
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The vector of quotients of entries of a and b.
     */
    const div = divide;
    /**
     * Zero's a vector
     * @param dst - vector to hold result. If not passed in a new one is created.
     * @returns The zeroed vector.
     */
    function zero(dst) {
        const newDst = (dst ?? new Ctor(4));
        newDst[0] = 0;
        newDst[1] = 0;
        newDst[2] = 0;
        newDst[3] = 0;
        return newDst;
    }
    /**
     * transform vec4 by 4x4 matrix
     * @param v - the vector
     * @param m - The matrix.
     * @param dst - optional vec4 to store result. If not passed a new one is created.
     * @returns the transformed vector
     */
    function transformMat4(v, m, dst) {
        const newDst = (dst ?? new Ctor(4));
        const x = v[0];
        const y = v[1];
        const z = v[2];
        const w = v[3];
        newDst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
        newDst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
        newDst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
        newDst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
        return newDst;
    }
    /**
     * Treat a 4D vector as a direction and set it's length
     *
     * @param a The vec4 to lengthen
     * @param len The length of the resulting vector
     * @returns The lengthened vector
     */
    function setLength(a, len, dst) {
        const newDst = (dst ?? new Ctor(4));
        normalize(a, newDst);
        return mulScalar(newDst, len, newDst);
    }
    /**
     * Ensure a vector is not longer than a max length
     *
     * @param a The vec4 to limit
     * @param maxLen The longest length of the resulting vector
     * @returns The vector, shortened to maxLen if it's too long
     */
    function truncate(a, maxLen, dst) {
        const newDst = (dst ?? new Ctor(4));
        if (length(a) > maxLen) {
            return setLength(a, maxLen, newDst);
        }
        return copy(a, newDst);
    }
    /**
     * Return the vector exactly between 2 endpoint vectors
     *
     * @param a Endpoint 1
     * @param b Endpoint 2
     * @returns The vector exactly residing between endpoints 1 and 2
     */
    function midpoint(a, b, dst) {
        const newDst = (dst ?? new Ctor(4));
        return lerp(a, b, 0.5, newDst);
    }
    return {
        create,
        fromValues,
        set,
        ceil,
        floor,
        round,
        clamp,
        add,
        addScaled,
        subtract,
        sub,
        equalsApproximately,
        equals,
        lerp,
        lerpV,
        max,
        min,
        mulScalar,
        scale,
        divScalar,
        inverse,
        invert,
        dot,
        length,
        len,
        lengthSq,
        lenSq,
        distance,
        dist,
        distanceSq,
        distSq,
        normalize,
        negate,
        copy,
        clone,
        multiply,
        mul,
        divide,
        div,
        zero,
        transformMat4,
        setLength,
        truncate,
        midpoint,
    };
}
const cache = new Map();
/**
 *
 * Vec4 math functions.
 *
 * Almost all functions take an optional `newDst` argument. If it is not passed in the
 * functions will create a new `Vec4`. In other words you can do this
 *
 *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.
 *
 * or
 *
 *     const v = vec4.create();
 *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always safe to pass any vector as the destination. So for example
 *
 *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 */
function getAPI(Ctor) {
    let api = cache.get(Ctor);
    if (!api) {
        api = getAPIImpl(Ctor);
        cache.set(Ctor, api);
    }
    return api;
}

/**
 * Generate wgpu-matrix API for type
 */
function wgpuMatrixAPI(Mat3Ctor, Mat4Ctor, QuatCtor, Vec2Ctor, Vec3Ctor, Vec4Ctor) {
    return {
        /** @namespace mat4 */
        mat4: getAPI$2(Mat3Ctor),
        /** @namespace mat3 */
        mat3: getAPI$4(Mat4Ctor),
        /** @namespace quat */
        quat: getAPI$1(QuatCtor),
        /** @namespace vec2 */
        vec2: getAPI$5(Vec2Ctor),
        /** @namespace vec3 */
        vec3: getAPI$3(Vec3Ctor),
        /** @namespace vec4 */
        vec4: getAPI(Vec4Ctor),
    };
}
const { 
/** @namespace */
mat4, 
/** @namespace */
mat3, 
/** @namespace */
quat, 
/** @namespace */
vec2, 
/** @namespace */
vec3, 
/** @namespace */
vec4, } = wgpuMatrixAPI(Float32Array, Float32Array, Float32Array, Float32Array, Float32Array, Float32Array);
const { 
/** @namespace */
mat4: mat4d, 
/** @namespace */
mat3: mat3d, 
/** @namespace */
quat: quatd, 
/** @namespace */
vec2: vec2d, 
/** @namespace */
vec3: vec3d, 
/** @namespace */
vec4: vec4d, } = wgpuMatrixAPI(Float64Array, Float64Array, Float64Array, Float64Array, Float64Array, Float64Array);
const { 
/** @namespace */
mat4: mat4n, 
/** @namespace */
mat3: mat3n, 
/** @namespace */
quat: quatn, 
/** @namespace */
vec2: vec2n, 
/** @namespace */
vec3: vec3n, 
/** @namespace */
vec4: vec4n, } = wgpuMatrixAPI(ZeroArray, Array, Array, Array, Array, Array);


//# sourceMappingURL=wgpu-matrix.module.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/renderer */ "./src/renderer.ts");

var renderer = new _renderer__WEBPACK_IMPORTED_MODULE_0__["default"]();
try {
    renderer.render();
}
catch (err) {
    if (err instanceof Error) {
        console.error(err.message);
    }
}

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGFBQWEsb0NBQW9DO0FBQ2pELElBQUk7QUFDSixhQUFhLGdEQUFnRDtBQUM3RCxJQUFJO0FBQ0osYUFBYSxvQ0FBb0M7QUFDakQsSUFBSTtBQUNKLGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQVFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0tBQW9LLGdDQUFnQztBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFR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QUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0ZBQWdGLHVFQUF1RTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGVBQWUsQ0FBQztRQUMxQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7UUFFNUMsSUFBTSxPQUFPLEdBQUcsNkNBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSw4Q0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUV0RSxJQUFNLElBQUksR0FBRyw2Q0FBSSxDQUFDLFNBQVMsQ0FBQyw2Q0FBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzdELElBQUksQ0FBQyxLQUFLLEdBQUcsNkNBQUksQ0FBQyxhQUFhLENBQUMsNkNBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNwRSxJQUFNLFNBQVMsR0FBRyw2Q0FBSSxDQUFDLGFBQWEsQ0FDbEMsSUFBSSxDQUFDLEtBQUssRUFDViw4Q0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQzNCLENBQUM7UUFFRixJQUFNLFFBQVEsR0FBRyw2Q0FBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFFOUMsSUFBTSxPQUFPLEdBQUcsNkNBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxFQUFFLEdBQUcsNkNBQUksQ0FBQyxTQUFTLENBQUMsNkNBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFELElBQUksQ0FBQyxHQUFHLEdBQUcsNkNBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSw2Q0FBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsTUFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQsaUJBQWlCLG1CQUFtQixLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCxpQkFBaUIsbUJBQW1CLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xELGlCQUFpQixtQkFBbUIsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUUwSDtBQUN6STs7Ozs7OztVQ3o5S0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7QUNOa0M7QUFDbEMsSUFBTSxRQUFRLEdBQUcsSUFBSSxpREFBUSxFQUFFLENBQUM7QUFFaEMsSUFBSSxDQUFDO0lBQ0gsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3BCLENBQUM7QUFBQyxPQUFPLEdBQVEsRUFBRSxDQUFDO0lBQ2xCLElBQUksR0FBRyxZQUFZLEtBQUssRUFBRSxDQUFDO1FBQ3pCLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzdCLENBQUM7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2dwdS1yZW5kZXJlci8uL25vZGVfbW9kdWxlcy9kYXQuZ3VpL2J1aWxkL2RhdC5ndWkubW9kdWxlLmpzIiwid2VicGFjazovL3dncHUtcmVuZGVyZXIvLi9zcmMvc2hhZGVycy9lcXVpcmVjdGFuZ3VsYXIud2dzbCIsIndlYnBhY2s6Ly93Z3B1LXJlbmRlcmVyLy4vc3JjL3NoYWRlcnMvaXJyYWRpYW5jZW1hcC53Z3NsIiwid2VicGFjazovL3dncHUtcmVuZGVyZXIvLi9zcmMvc2hhZGVycy9taXBtYXAud2dzbCIsIndlYnBhY2s6Ly93Z3B1LXJlbmRlcmVyLy4vc3JjL3NoYWRlcnMvc2hhZGVyLndnc2wiLCJ3ZWJwYWNrOi8vd2dwdS1yZW5kZXJlci8uL3NyYy9zaGFkZXJzL3NreWJveC53Z3NsIiwid2VicGFjazovL3dncHUtcmVuZGVyZXIvLi9zcmMvY2FtZXJhLnRzIiwid2VicGFjazovL3dncHUtcmVuZGVyZXIvLi9zcmMvZ2xURi50cyIsIndlYnBhY2s6Ly93Z3B1LXJlbmRlcmVyLy4vc3JjL2hkci50cyIsIndlYnBhY2s6Ly93Z3B1LXJlbmRlcmVyLy4vc3JjL3JlbmRlcmVyLnRzIiwid2VicGFjazovL3dncHUtcmVuZGVyZXIvLi9zcmMvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vd2dwdS1yZW5kZXJlci8uL25vZGVfbW9kdWxlcy93Z3B1LW1hdHJpeC9kaXN0LzMueC93Z3B1LW1hdHJpeC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vd2dwdS1yZW5kZXJlci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly93Z3B1LXJlbmRlcmVyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly93Z3B1LXJlbmRlcmVyL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vd2dwdS1yZW5kZXJlci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3dncHUtcmVuZGVyZXIvLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGF0YWFydHMvZGF0Lmd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZ1bmN0aW9uIF9fXyRpbnNlcnRTdHlsZShjc3MpIHtcbiAgaWYgKCFjc3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICByZXR1cm4gY3NzO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvU3RyaW5nIChjb2xvciwgZm9yY2VDU1NIZXgpIHtcbiAgdmFyIGNvbG9yRm9ybWF0ID0gY29sb3IuX19zdGF0ZS5jb252ZXJzaW9uTmFtZS50b1N0cmluZygpO1xuICB2YXIgciA9IE1hdGgucm91bmQoY29sb3Iucik7XG4gIHZhciBnID0gTWF0aC5yb3VuZChjb2xvci5nKTtcbiAgdmFyIGIgPSBNYXRoLnJvdW5kKGNvbG9yLmIpO1xuICB2YXIgYSA9IGNvbG9yLmE7XG4gIHZhciBoID0gTWF0aC5yb3VuZChjb2xvci5oKTtcbiAgdmFyIHMgPSBjb2xvci5zLnRvRml4ZWQoMSk7XG4gIHZhciB2ID0gY29sb3Iudi50b0ZpeGVkKDEpO1xuICBpZiAoZm9yY2VDU1NIZXggfHwgY29sb3JGb3JtYXQgPT09ICdUSFJFRV9DSEFSX0hFWCcgfHwgY29sb3JGb3JtYXQgPT09ICdTSVhfQ0hBUl9IRVgnKSB7XG4gICAgdmFyIHN0ciA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCA2KSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiAnIycgKyBzdHI7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCJykge1xuICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCQScpIHtcbiAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIRVgnKSB7XG4gICAgcmV0dXJuICcweCcgKyBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnXSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JBX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX09CSicpIHtcbiAgICByZXR1cm4gJ3tyOicgKyByICsgJyxnOicgKyBnICsgJyxiOicgKyBiICsgJ30nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICcsYTonICsgYSArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVl9PQkonKSB7XG4gICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVkFfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH1cbiAgcmV0dXJuICd1bmtub3duIGZvcm1hdCc7XG59XG5cbnZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBDb21tb24gPSB7XG4gIEJSRUFLOiB7fSxcbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgY29tcG9zZTogZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRyLCBzY29wZSkge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHtcbiAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgIGZvciAoa2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtfa2V5XSwgX2tleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihmbmMpIHtcbiAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gIH0sXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB0aHJlc2hvbGQsIGNhbGxJbW1lZGlhdGVseSkge1xuICAgIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghY2FsbEltbWVkaWF0ZWx5KSBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgY2FsbE5vdyA9IGNhbGxJbW1lZGlhdGVseSB8fCAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHRocmVzaG9sZCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICB9LFxuICBpc1VuZGVmaW5lZDogZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9LFxuICBpc05hTjogZnVuY3Rpb24gKF9pc05hTikge1xuICAgIGZ1bmN0aW9uIGlzTmFOKF94KSB7XG4gICAgICByZXR1cm4gX2lzTmFOLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlzTmFOLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pc05hTi50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzTmFOO1xuICB9KGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gaXNOYU4ob2JqKTtcbiAgfSksXG4gIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH0sXG4gIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBvYmogKyAwO1xuICB9LFxuICBpc1N0cmluZzogZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgJyc7XG4gIH0sXG4gIGlzQm9vbGVhbjogZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgfSxcbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cbn07XG5cbnZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG57XG4gIGxpdG11czogQ29tbW9uLmlzU3RyaW5nLFxuICBjb252ZXJzaW9uczoge1xuICAgIFRIUkVFX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBTSVhfQ0hBUl9IRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKixcXHMqKFxcUyspXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCQToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqLFxccyooXFxTKylcXHMqXFwpLyk7XG4gICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pLFxuICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogY29sb3JUb1N0cmluZ1xuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNOdW1iZXIsXG4gIGNvbnZlcnNpb25zOiB7XG4gICAgSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgIGhleDogb3JpZ2luYWwsXG4gICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBjb2xvci5oZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc0FycmF5LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQl9BUlJBWToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgIGI6IG9yaWdpbmFsWzJdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYl07XG4gICAgICB9XG4gICAgfSxcbiAgICBSR0JBX0FSUkFZOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IDQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgYTogb3JpZ2luYWxbM11cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzT2JqZWN0LFxuICBjb252ZXJzaW9uczoge1xuICAgIFJHQkFfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgIGc6IG9yaWdpbmFsLmcsXG4gICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iLFxuICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFJHQl9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5yKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZBX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgIGg6IG9yaWdpbmFsLmgsXG4gICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBIU1ZfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnMpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgdjogY29sb3IudlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufV07XG52YXIgcmVzdWx0ID0gdm9pZCAwO1xudmFyIHRvUmV0dXJuID0gdm9pZCAwO1xudmFyIGludGVycHJldCA9IGZ1bmN0aW9uIGludGVycHJldCgpIHtcbiAgdG9SZXR1cm4gPSBmYWxzZTtcbiAgdmFyIG9yaWdpbmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBDb21tb24udG9BcnJheShhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuICBDb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcbiAgICAgIENvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24gKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0b1JldHVybiA9PT0gZmFsc2UgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uID0gY29udmVyc2lvbjtcbiAgICAgICAgICByZXR1cm4gQ29tbW9uLkJSRUFLO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21tb24uQlJFQUs7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufTtcblxudmFyIHRtcENvbXBvbmVudCA9IHZvaWQgMDtcbnZhciBDb2xvck1hdGggPSB7XG4gIGhzdl90b19yZ2I6IGZ1bmN0aW9uIGhzdl90b19yZ2IoaCwgcywgdikge1xuICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCAvIDYwKSAlIDY7XG4gICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgdmFyIHAgPSB2ICogKDEuMCAtIHMpO1xuICAgIHZhciBxID0gdiAqICgxLjAgLSBmICogcyk7XG4gICAgdmFyIHQgPSB2ICogKDEuMCAtICgxLjAgLSBmKSAqIHMpO1xuICAgIHZhciBjID0gW1t2LCB0LCBwXSwgW3EsIHYsIHBdLCBbcCwgdiwgdF0sIFtwLCBxLCB2XSwgW3QsIHAsIHZdLCBbdiwgcCwgcV1dW2hpXTtcbiAgICByZXR1cm4ge1xuICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgIGc6IGNbMV0gKiAyNTUsXG4gICAgICBiOiBjWzJdICogMjU1XG4gICAgfTtcbiAgfSxcbiAgcmdiX3RvX2hzdjogZnVuY3Rpb24gcmdiX3RvX2hzdihyLCBnLCBiKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgdmFyIGggPSB2b2lkIDA7XG4gICAgdmFyIHMgPSB2b2lkIDA7XG4gICAgaWYgKG1heCAhPT0gMCkge1xuICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBOYU4sXG4gICAgICAgIHM6IDAsXG4gICAgICAgIHY6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChyID09PSBtYXgpIHtcbiAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICB9XG4gICAgaCAvPSA2O1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaDogaCAqIDM2MCxcbiAgICAgIHM6IHMsXG4gICAgICB2OiBtYXggLyAyNTVcbiAgICB9O1xuICB9LFxuICByZ2JfdG9faGV4OiBmdW5jdGlvbiByZ2JfdG9faGV4KHIsIGcsIGIpIHtcbiAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAxLCBnKTtcbiAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgIHJldHVybiBoZXg7XG4gIH0sXG4gIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24gY29tcG9uZW50X2Zyb21faGV4KGhleCwgY29tcG9uZW50SW5kZXgpIHtcbiAgICByZXR1cm4gaGV4ID4+IGNvbXBvbmVudEluZGV4ICogOCAmIDB4RkY7XG4gIH0sXG4gIGhleF93aXRoX2NvbXBvbmVudDogZnVuY3Rpb24gaGV4X3dpdGhfY29tcG9uZW50KGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgaGV4ICYgfigweEZGIDw8IHRtcENvbXBvbmVudCk7XG4gIH1cbn07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbG9yKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yKTtcbiAgICB0aGlzLl9fc3RhdGUgPSBpbnRlcnByZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29sb3IsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBjb2xvclRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvSGV4U3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXhTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b09yaWdpbmFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PcmlnaW5hbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbG9yO1xufSgpO1xuZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICAgIH1cbiAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ1JHQicpIHtcbiAgICAgICAgQ29sb3IucmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICB9XG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgIENvbG9yLnJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSFNWJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcbiAgICB9XG4gIH0pO1xufVxuQ29sb3IucmVjYWxjdWxhdGVSR0IgPSBmdW5jdGlvbiAoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcbiAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG4gICAgY29sb3IuX19zdGF0ZVtjb21wb25lbnRdID0gQ29sb3JNYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG4gICAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCBDb2xvck1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3JydXB0ZWQgY29sb3Igc3RhdGUnKTtcbiAgfVxufTtcbkNvbG9yLnJlY2FsY3VsYXRlSFNWID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIHZhciByZXN1bHQgPSBDb2xvck1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgQ29tbW9uLmV4dGVuZChjb2xvci5fX3N0YXRlLCB7XG4gICAgczogcmVzdWx0LnMsXG4gICAgdjogcmVzdWx0LnZcbiAgfSk7XG4gIGlmICghQ29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgIGNvbG9yLl9fc3RhdGUuaCA9IHJlc3VsdC5oO1xuICB9IGVsc2UgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgfVxufTtcbkNvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCAnZycsICdiJywgJ2gnLCAncycsICd2JywgJ2hleCcsICdhJ107XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncicsIDIpO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICd2Jyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5hO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICB0aGlzLl9fc3RhdGUuaGV4ID0gQ29sb3JNYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICB0aGlzLl9fc3RhdGUuaGV4ID0gdjtcbiAgfVxufSk7XG5cbnZhciBDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sbGVyKTtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHRoaXMuX19vbkNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlKGZuYykge1xuICAgICAgdGhpcy5fX29uQ2hhbmdlID0gZm5jO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25GaW5pc2hDaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZpbmlzaENoYW5nZShmbmMpIHtcbiAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZSA9IGZuYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lzTW9kaWZpZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc01vZGlmaWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlICE9PSB0aGlzLmdldFZhbHVlKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb250cm9sbGVyO1xufSgpO1xuXG52YXIgRVZFTlRfTUFQID0ge1xuICBIVE1MRXZlbnRzOiBbJ2NoYW5nZSddLFxuICBNb3VzZUV2ZW50czogWydjbGljaycsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2VvdmVyJ10sXG4gIEtleWJvYXJkRXZlbnRzOiBbJ2tleWRvd24nXVxufTtcbnZhciBFVkVOVF9NQVBfSU5WID0ge307XG5Db21tb24uZWFjaChFVkVOVF9NQVAsIGZ1bmN0aW9uICh2LCBrKSB7XG4gIENvbW1vbi5lYWNoKHYsIGZ1bmN0aW9uIChlKSB7XG4gICAgRVZFTlRfTUFQX0lOVltlXSA9IGs7XG4gIH0pO1xufSk7XG52YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xuZnVuY3Rpb24gY3NzVmFsdWVUb1BpeGVscyh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gJzAnIHx8IENvbW1vbi5pc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKENTU19WQUxVRV9QSVhFTFMpO1xuICBpZiAoIUNvbW1vbi5pc051bGwobWF0Y2gpKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIGRvbSA9IHtcbiAgbWFrZVNlbGVjdGFibGU6IGZ1bmN0aW9uIG1ha2VTZWxlY3RhYmxlKGVsZW0sIHNlbGVjdGFibGUpIHtcbiAgICBpZiAoZWxlbSA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc3R5bGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGVsZW0ub25zZWxlY3RzdGFydCA9IHNlbGVjdGFibGUgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgZWxlbS5zdHlsZS5LaHRtbFVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIGVsZW0udW5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZSA/ICdvbicgOiAnb2ZmJztcbiAgfSxcbiAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIG1ha2VGdWxsc2NyZWVuKGVsZW0sIGhvciwgdmVydCkge1xuICAgIHZhciB2ZXJ0aWNhbCA9IHZlcnQ7XG4gICAgdmFyIGhvcml6b250YWwgPSBob3I7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChob3Jpem9udGFsKSkge1xuICAgICAgaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQodmVydGljYWwpKSB7XG4gICAgICB2ZXJ0aWNhbCA9IHRydWU7XG4gICAgfVxuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICBlbGVtLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5yaWdodCA9IDA7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgZWxlbS5zdHlsZS50b3AgPSAwO1xuICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSAwO1xuICAgIH1cbiAgfSxcbiAgZmFrZUV2ZW50OiBmdW5jdGlvbiBmYWtlRXZlbnQoZWxlbSwgZXZlbnRUeXBlLCBwYXJzLCBhdXgpIHtcbiAgICB2YXIgcGFyYW1zID0gcGFycyB8fCB7fTtcbiAgICB2YXIgY2xhc3NOYW1lID0gRVZFTlRfTUFQX0lOVltldmVudFR5cGVdO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHR5cGUgJyArIGV2ZW50VHlwZSArICcgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGNsYXNzTmFtZSk7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIGNhc2UgJ01vdXNlRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjbGllbnRYID0gcGFyYW1zLnggfHwgcGFyYW1zLmNsaWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgY2xpZW50WSA9IHBhcmFtcy55IHx8IHBhcmFtcy5jbGllbnRZIHx8IDA7XG4gICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlIHx8IHRydWUsIHdpbmRvdywgcGFyYW1zLmNsaWNrQ291bnQgfHwgMSwgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ0tleWJvYXJkRXZlbnRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbml0ID0gZXZ0LmluaXRLZXlib2FyZEV2ZW50IHx8IGV2dC5pbml0S2V5RXZlbnQ7XG4gICAgICAgICAgQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGN0cmxLZXk6IGZhbHNlLFxuICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAga2V5Q29kZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhckNvZGU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGluaXQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdywgcGFyYW1zLmN0cmxLZXksIHBhcmFtcy5hbHRLZXksIHBhcmFtcy5zaGlmdEtleSwgcGFyYW1zLm1ldGFLZXksIHBhcmFtcy5rZXlDb2RlLCBwYXJhbXMuY2hhckNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb21tb24uZGVmYXVsdHMoZXZ0LCBhdXgpO1xuICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9LFxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsZW0sIGV2ZW50LCBmdW5jLCBuZXdCb29sKSB7XG4gICAgdmFyIGJvb2wgPSBuZXdCb29sIHx8IGZhbHNlO1xuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID09PSAtMSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gY2xhc3NOYW1lKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmNsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfSxcbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzK3wkKScpLnRlc3QoZWxlbS5jbGFzc05hbWUpIHx8IGZhbHNlO1xuICB9LFxuICBnZXRXaWR0aDogZnVuY3Rpb24gZ2V0V2lkdGgoZWxlbSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1yaWdodCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUud2lkdGgpO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIGdldEhlaWdodChlbGVtKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXRvcCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZS5oZWlnaHQpO1xuICB9LFxuICBnZXRPZmZzZXQ6IGZ1bmN0aW9uIGdldE9mZnNldChlbCkge1xuICAgIHZhciBlbGVtID0gZWw7XG4gICAgdmFyIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgICBkbyB7XG4gICAgICAgIG9mZnNldC5sZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcbiAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH0sXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZShlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYpO1xuICB9XG59O1xuXG52YXIgQm9vbGVhbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoQm9vbGVhbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQm9vbGVhbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJvb2xlYW5Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQm9vbGVhbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19wcmV2ID0gX3RoaXMyLmdldFZhbHVlKCk7XG4gICAgX3RoaXMyLl9fY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoIV90aGlzLl9fcHJldik7XG4gICAgfVxuICAgIGRvbS5iaW5kKF90aGlzMi5fX2NoZWNrYm94LCAnY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19jaGVja2JveCk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKEJvb2xlYW5Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIHRvUmV0dXJuID0gZ2V0KEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcHJldiA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIGlmICh0aGlzLmdldFZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX3ByZXYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG52YXIgT3B0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhPcHRpb25Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgb3B0cykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPcHRpb25Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgaWYgKENvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBtYXBbZWxlbWVudF0gPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBvcHRpb25zID0gbWFwO1xuICAgIH1cbiAgICBDb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0LmlubmVySFRNTCA9IGtleTtcbiAgICAgIG9wdC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgX3RoaXMuX19zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZXNpcmVkVmFsdWUgPSB0aGlzLm9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIF90aGlzLnNldFZhbHVlKGRlc2lyZWRWYWx1ZSk7XG4gICAgfSk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE9wdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgdG9SZXR1cm4gPSBnZXQoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZSksICdzZXRWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgdik7XG4gICAgICBpZiAodGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoZG9tLmlzQWN0aXZlKHRoaXMuX19zZWxlY3QpKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX19zZWxlY3QudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gZ2V0KE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBPcHRpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIFN0cmluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoU3RyaW5nQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpbmdDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyaW5nQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0NvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIF90aGlzMi5fX2lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXl1cCcsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKFN0cmluZ0NvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAoIWRvbS5pc0FjdGl2ZSh0aGlzLl9faW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXQoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xuXG5mdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG4gIHZhciBfeCA9IHgudG9TdHJpbmcoKTtcbiAgaWYgKF94LmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIF94Lmxlbmd0aCAtIF94LmluZGV4T2YoJy4nKSAtIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3BhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBfdGhpcy5fX21pbiA9IF9wYXJhbXMubWluO1xuICAgIF90aGlzLl9fbWF4ID0gX3BhcmFtcy5tYXg7XG4gICAgX3RoaXMuX19zdGVwID0gX3BhcmFtcy5zdGVwO1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoX3RoaXMuX19zdGVwKSkge1xuICAgICAgaWYgKF90aGlzLmluaXRpYWxWYWx1ZSA9PT0gMCkge1xuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyhfdGhpcy5pbml0aWFsVmFsdWUpKSAvIE1hdGguTE4xMCkpIC8gMTA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLl9faW1wbGllZFN0ZXAgPSBfdGhpcy5fX3N0ZXA7XG4gICAgfVxuICAgIF90aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoX3RoaXMuX19pbXBsaWVkU3RlcCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2KSB7XG4gICAgICB2YXIgX3YgPSB2O1xuICAgICAgaWYgKHRoaXMuX19taW4gIT09IHVuZGVmaW5lZCAmJiBfdiA8IHRoaXMuX19taW4pIHtcbiAgICAgICAgX3YgPSB0aGlzLl9fbWluO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbWF4ICE9PSB1bmRlZmluZWQgJiYgX3YgPiB0aGlzLl9fbWF4KSB7XG4gICAgICAgIF92ID0gdGhpcy5fX21heDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fc3RlcCAhPT0gdW5kZWZpbmVkICYmIF92ICUgdGhpcy5fX3N0ZXAgIT09IDApIHtcbiAgICAgICAgX3YgPSBNYXRoLnJvdW5kKF92IC8gdGhpcy5fX3N0ZXApICogdGhpcy5fX3N0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIF92KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4obWluVmFsdWUpIHtcbiAgICAgIHRoaXMuX19taW4gPSBtaW5WYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21heCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heChtYXhWYWx1ZSkge1xuICAgICAgdGhpcy5fX21heCA9IG1heFZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RlcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXAoc3RlcFZhbHVlKSB7XG4gICAgICB0aGlzLl9fc3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IHN0ZXBWYWx1ZTtcbiAgICAgIHRoaXMuX19wcmVjaXNpb24gPSBudW1EZWNpbWFscyhzdGVwVmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gcm91bmRUb0RlY2ltYWwodmFsdWUsIGRlY2ltYWxzKSB7XG4gIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogdGVuVG8pIC8gdGVuVG87XG59XG52YXIgTnVtYmVyQ29udHJvbGxlckJveCA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyQm94LCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlckJveCk7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXJCb3guX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyQm94KSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpKTtcbiAgICBfdGhpczIuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIHZhciBwcmV2WSA9IHZvaWQgMDtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHZhciBhdHRlbXB0ZWQgPSBwYXJzZUZsb2F0KF90aGlzLl9faW5wdXQudmFsdWUpO1xuICAgICAgaWYgKCFDb21tb24uaXNOYU4oYXR0ZW1wdGVkKSkge1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShhdHRlbXB0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEcmFnKGUpIHtcbiAgICAgIHZhciBkaWZmID0gcHJldlkgLSBlLmNsaWVudFk7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5nZXRWYWx1ZSgpICsgZGlmZiAqIF90aGlzLl9faW1wbGllZFN0ZXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgcHJldlkgPSBlLmNsaWVudFk7XG4gICAgfVxuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgb25GaW5pc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2lucHV0KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKE51bWJlckNvbnRyb2xsZXJCb3gsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveC5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94O1xufShOdW1iZXJDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gbWFwKHYsIGkxLCBpMiwgbzEsIG8yKSB7XG4gIHJldHVybiBvMSArIChvMiAtIG8xKSAqICgodiAtIGkxKSAvIChpMiAtIGkxKSk7XG59XG52YXIgTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IGZ1bmN0aW9uIChfTnVtYmVyQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBfTnVtYmVyQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgbWluLCBtYXgsIHN0ZXApIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJDb250cm9sbGVyU2xpZGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29udHJvbGxlclNsaWRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJTbGlkZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiBzdGVwIH0pKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2ZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2JhY2tncm91bmQsICd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19mb3JlZ3JvdW5kLCAnc2xpZGVyLWZnJyk7XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIG9uTW91c2VEcmFnKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGUuY2xpZW50WCwgYmdSZWN0LmxlZnQsIGJnUmVjdC5yaWdodCwgX3RoaXMuX19taW4sIF90aGlzLl9fbWF4KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgICAgb25Ub3VjaE1vdmUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICAgIHZhciBjbGllbnRYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICB2YXIgYmdSZWN0ID0gX3RoaXMuX19iYWNrZ3JvdW5kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgX3RoaXMuc2V0VmFsdWUobWFwKGNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIF90aGlzMi5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fZm9yZWdyb3VuZCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fYmFja2dyb3VuZCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdmFyIHBjdCA9ICh0aGlzLmdldFZhbHVlKCkgLSB0aGlzLl9fbWluKSAvICh0aGlzLl9fbWF4IC0gdGhpcy5fX21pbik7XG4gICAgICB0aGlzLl9fZm9yZWdyb3VuZC5zdHlsZS53aWR0aCA9IHBjdCAqIDEwMCArICclJztcbiAgICAgIHJldHVybiBnZXQoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XG59KE51bWJlckNvbnRyb2xsZXIpO1xuXG52YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKEZ1bmN0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZ1bmN0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZ1bmN0aW9uQ29udHJvbGxlcikpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSkpO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICBfdGhpczIuX19idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19idXR0b24uaW5uZXJIVE1MID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gJ0ZpcmUnIDogdGV4dDtcbiAgICBkb20uYmluZChfdGhpczIuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5maXJlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2J1dHRvbiwgJ2J1dHRvbicpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2J1dHRvbik7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhGdW5jdGlvbkNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZmlyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX19vbkNoYW5nZS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRWYWx1ZSgpLmNhbGwodGhpcy5vYmplY3QpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRnVuY3Rpb25Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIENvbG9yQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhDb2xvckNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvckNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvckNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICBfdGhpczIuX19jb2xvciA9IG5ldyBDb2xvcihfdGhpczIuZ2V0VmFsdWUoKSk7XG4gICAgX3RoaXMyLl9fdGVtcCA9IG5ldyBDb2xvcigwKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20ubWFrZVNlbGVjdGFibGUoX3RoaXMyLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBfdGhpczIuX19zZWxlY3RvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmNsYXNzTmFtZSA9ICdzZWxlY3Rvcic7XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xuICAgIF90aGlzMi5fX2ZpZWxkX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19maWVsZF9rbm9iLmNsYXNzTmFtZSA9ICdmaWVsZC1rbm9iJztcbiAgICBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciA9ICcycHggc29saWQgJztcbiAgICBfdGhpczIuX19odWVfa25vYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2h1ZV9rbm9iLmNsYXNzTmFtZSA9ICdodWUta25vYic7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkLmNsYXNzTmFtZSA9ICdodWUtZmllbGQnO1xuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIF90aGlzMi5fX2lucHV0X3RleHRTaGFkb3cgPSAnMCAxcHggMXB4ICc7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIG9uQmx1ci5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnYmx1cicsIG9uQmx1cik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcywgJ2RyYWcnKS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMsICdkcmFnJykuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdmFsdWVGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2VsZWN0b3Iuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTIycHgnLFxuICAgICAgaGVpZ2h0OiAnMTAycHgnLFxuICAgICAgcGFkZGluZzogJzNweCcsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjIyJyxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2ZpZWxkX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMnB4JyxcbiAgICAgIGhlaWdodDogJzEycHgnLFxuICAgICAgYm9yZGVyOiBfdGhpczIuX19maWVsZF9rbm9iX2JvcmRlciArIChfdGhpczIuX19jb2xvci52IDwgMC41ID8gJyNmZmYnIDogJyMwMDAnKSxcbiAgICAgIGJveFNoYWRvdzogJzBweCAxcHggM3B4IHJnYmEoMCwwLDAsMC41KScsXG4gICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZCh2YWx1ZUZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZUZpZWxkLCAndG9wJywgJ3JnYmEoMCwwLDAsMCknLCAnIzAwMCcpO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9faHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAnM3B4JyxcbiAgICAgIHJpZ2h0OiAnM3B4J1xuICAgIH0pO1xuICAgIGh1ZUdyYWRpZW50KF90aGlzMi5fX2h1ZV9maWVsZCk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICB0ZXh0U2hhZG93OiBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fZmllbGRfa25vYiwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ21vdXNlZG93bicsIGZpZWxkRG93bkgpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2h1ZV9maWVsZCwgJ3RvdWNoc3RhcnQnLCBmaWVsZERvd25IKTtcbiAgICBmdW5jdGlvbiBmaWVsZERvd24oZSkge1xuICAgICAgc2V0U1YoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGREb3duSChlKSB7XG4gICAgICBzZXRIKGUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgc2V0SCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIGZpZWxkVXBIKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGRVcFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcFNWKTtcbiAgICAgIG9uRmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpZWxkVXBIKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0SCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwSCk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgdmFyIGkgPSBpbnRlcnByZXQodGhpcy52YWx1ZSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXMuX19jb2xvci5fX3N0YXRlID0gaTtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF90aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLl9fc2F0dXJhdGlvbl9maWVsZC5hcHBlbmRDaGlsZCh2YWx1ZUZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19maWVsZF9rbm9iKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfZmllbGQpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZChfdGhpczIuX19odWVfa25vYik7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9faW5wdXQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdG9yKTtcbiAgICBfdGhpczIudXBkYXRlRGlzcGxheSgpO1xuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBfcmVmID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgICAgIHZhciBzID0gKGNsaWVudFggLSBmaWVsZFJlY3QubGVmdCkgLyAoZmllbGRSZWN0LnJpZ2h0IC0gZmllbGRSZWN0LmxlZnQpO1xuICAgICAgdmFyIHYgPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAodiA+IDEpIHtcbiAgICAgICAgdiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHMgPiAxKSB7XG4gICAgICAgIHMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzIDwgMCkge1xuICAgICAgICBzID0gMDtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRIKGUpIHtcbiAgICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gLTEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkUmVjdCA9IF90aGlzLl9faHVlX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIF9yZWYyID0gZS50b3VjaGVzICYmIGUudG91Y2hlc1swXSB8fCBlLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmMi5jbGllbnRZO1xuICAgICAgdmFyIGggPSAxIC0gKGNsaWVudFkgLSBmaWVsZFJlY3QudG9wKSAvIChmaWVsZFJlY3QuYm90dG9tIC0gZmllbGRSZWN0LnRvcCk7XG4gICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgaCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGggPCAwKSB7XG4gICAgICAgIGggPSAwO1xuICAgICAgfVxuICAgICAgX3RoaXMuX19jb2xvci5oID0gaCAqIDM2MDtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLl9fY29sb3IudG9PcmlnaW5hbCgpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhDb2xvckNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgaWYgKGkgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuICAgICAgICBDb21tb24uZWFjaChDb2xvci5DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQoaVtjb21wb25lbnRdKSAmJiAhQ29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmIGlbY29tcG9uZW50XSAhPT0gdGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2NvbG9yLl9fc3RhdGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX190ZW1wLl9fc3RhdGUsIHRoaXMuX19jb2xvci5fX3N0YXRlKTtcbiAgICAgIHRoaXMuX190ZW1wLmEgPSAxO1xuICAgICAgdmFyIGZsaXAgPSB0aGlzLl9fY29sb3IudiA8IDAuNSB8fCB0aGlzLl9fY29sb3IucyA+IDAuNSA/IDI1NSA6IDA7XG4gICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICBtYXJnaW5MZWZ0OiAxMDAgKiB0aGlzLl9fY29sb3IucyAtIDcgKyAncHgnLFxuICAgICAgICBtYXJnaW5Ub3A6IDEwMCAqICgxIC0gdGhpcy5fX2NvbG9yLnYpIC0gNyArICdweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgYm9yZGVyOiB0aGlzLl9fZmllbGRfa25vYl9ib3JkZXIgKyAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2h1ZV9rbm9iLnN0eWxlLm1hcmdpblRvcCA9ICgxIC0gdGhpcy5fX2NvbG9yLmggLyAzNjApICogMTAwICsgJ3B4JztcbiAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgdGhpcy5fX3RlbXAudiA9IDE7XG4gICAgICBsaW5lYXJHcmFkaWVudCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZCwgJ2xlZnQnLCAnI2ZmZicsIHRoaXMuX190ZW1wLnRvSGV4U3RyaW5nKCkpO1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19jb2xvci50b0hleFN0cmluZygpLFxuICAgICAgICBjb2xvcjogJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJyknLFxuICAgICAgICB0ZXh0U2hhZG93OiB0aGlzLl9faW5wdXRfdGV4dFNoYWRvdyArICdyZ2JhKCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLC43KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sb3JDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcbnZhciB2ZW5kb3JzID0gWyctbW96LScsICctby0nLCAnLXdlYmtpdC0nLCAnLW1zLScsICcnXTtcbmZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KGVsZW0sIHgsIGEsIGIpIHtcbiAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gIENvbW1vbi5lYWNoKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3IpIHtcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcgKyB4ICsgJywgJyArIGEgKyAnIDAlLCAnICsgYiArICcgMTAwJSk7ICc7XG4gIH0pO1xufVxuZnVuY3Rpb24gaHVlR3JhZGllbnQoZWxlbSkge1xuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG4gIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOyc7XG59XG5cbnZhciBjc3MgPSB7XG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsLCBpbmRvYykge1xuICAgIHZhciBkb2MgPSBpbmRvYyB8fCBkb2N1bWVudDtcbiAgICB2YXIgbGluayA9IGRvYy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gIH0sXG4gIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KGNzc0NvbnRlbnQsIGluZG9jKSB7XG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xuICAgIHZhciBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgaW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcbiAgICB2YXIgaGVhZCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHRyeSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKGluamVjdGVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2F2ZURpYWxvZ0NvbnRlbnRzID0gXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuXFxuICAgIDwvZGl2PlxcblxcbiAgPC9kaXY+XFxuXFxuPC9kaXY+XCI7XG5cbnZhciBDb250cm9sbGVyRmFjdG9yeSA9IGZ1bmN0aW9uIENvbnRyb2xsZXJGYWN0b3J5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gIGlmIChDb21tb24uaXNBcnJheShhcmd1bWVudHNbMl0pIHx8IENvbW1vbi5pc09iamVjdChhcmd1bWVudHNbMl0pKSB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc051bWJlcihpbml0aWFsVmFsdWUpKSB7XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbMl0pICYmIENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbM10pKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLCBhcmd1bWVudHNbNF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICB9XG4gICAgaWYgKENvbW1vbi5pc051bWJlcihhcmd1bWVudHNbNF0pKSB7XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10sIHN0ZXA6IGFyZ3VtZW50c1s0XSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuICB9XG4gIGlmIChDb21tb24uaXNTdHJpbmcoaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzQm9vbGVhbihpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sZWFuQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xufVxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIENlbnRlcmVkRGl2ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZW50ZXJlZERpdigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDZW50ZXJlZERpdik7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIENvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcicsXG4gICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcbiAgICBkb20ubWFrZUZ1bGxzY3JlZW4odGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgekluZGV4OiAnMTAwMScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJy13ZWJraXQtdHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInLFxuICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENlbnRlcmVkRGl2LCBbe1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgICAgdGhpcy5sYXlvdXQoKTtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICBfdGhpcy5kb21FbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICB9O1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xheW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gZG9tLmdldFdpZHRoKHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDZW50ZXJlZERpdjtcbn0oKTtcblxudmFyIHN0eWxlU2hlZXQgPSBfX18kaW5zZXJ0U3R5bGUoXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcn0uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3d7b3ZlcmZsb3cteTphdXRvfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvdyAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MTttYXJnaW4tdG9wOi0xcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgIzJjMmMyY30uZGcubWFpbiB1bC5jbG9zZWQgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjEgIWltcG9ydGFudH0uZGcubWFpbjpob3ZlciAuY2xvc2UtYnV0dG9uLC5kZy5tYWluIC5jbG9zZS1idXR0b24uZHJhZ3tvcGFjaXR5OjF9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbnstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7Ym9yZGVyOjA7bGluZS1oZWlnaHQ6MTlweDtoZWlnaHQ6MjBweDtjdXJzb3I6cG9pbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS10b3B7cG9zaXRpb246cmVsYXRpdmV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5jbG9zZS1ib3R0b217cG9zaXRpb246YWJzb2x1dGV9LmRnLm1haW4gLmNsb3NlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LmRnLmF7ZmxvYXQ6cmlnaHQ7bWFyZ2luLXJpZ2h0OjE1cHg7b3ZlcmZsb3cteTp2aXNpYmxlfS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlLXRvcHttYXJnaW4tdG9wOjB9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtYm90dG9te21hcmdpbi10b3A6MjdweH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZWR7bWFyZ2luLXRvcDowfS5kZy5hIC5zYXZlLXJvd3t0b3A6MDt6LWluZGV4OjEwMDJ9LmRnLmEgLnNhdmUtcm93LmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtYm90dG9te3Bvc2l0aW9uOmZpeGVkfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstby10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXJ9LmRnIGxpOm5vdCguZm9sZGVyKXtjdXJzb3I6YXV0bztoZWlnaHQ6MjdweDtsaW5lLWhlaWdodDoyN3B4O3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGk+KntoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjB9LmRnIC5jcntjbGVhcjpib3RoO3BhZGRpbmctbGVmdDozcHg7aGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVufS5kZyAucHJvcGVydHktbmFtZXtjdXJzb3I6ZGVmYXVsdDtmbG9hdDpsZWZ0O2NsZWFyOmxlZnQ7d2lkdGg6NDAlO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWV7d2lkdGg6MTAwJX0uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCU7cG9zaXRpb246cmVsYXRpdmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjdweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuY3IuY29sb3J7b3ZlcmZsb3c6dmlzaWJsZX0uZGcgLnNlbGVjdG9ye2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW4tbGVmdDotOXB4O21hcmdpbi10b3A6MjNweDt6LWluZGV4OjEwfS5kZyAuYzpob3ZlciAuc2VsZWN0b3IsLmRnIC5zZWxlY3Rvci5kcmFne2Rpc3BsYXk6YmxvY2t9LmRnIGxpLnNhdmUtcm93e3BhZGRpbmc6MH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjBweCA2cHh9LmRnLmRpYWxvZ3Vle2JhY2tncm91bmQtY29sb3I6IzIyMjt3aWR0aDo0NjBweDtwYWRkaW5nOjE1cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTVweH0jZGctbmV3LWNvbnN0cnVjdG9ye3BhZGRpbmc6MTBweDtjb2xvcjojMjIyO2ZvbnQtZmFtaWx5Ok1vbmFjbywgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxMHB4O2JvcmRlcjowO3Jlc2l6ZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMXB4IDFweCAxcHggIzg4ODt3b3JkLXdyYXA6YnJlYWstd29yZDttYXJnaW46MTJweCAwO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NDQwcHg7b3ZlcmZsb3cteTpzY3JvbGw7aGVpZ2h0OjEwMHB4O3Bvc2l0aW9uOnJlbGF0aXZlfSNkZy1sb2NhbC1leHBsYWlue2Rpc3BsYXk6bm9uZTtmb250LXNpemU6MTFweDtsaW5lLWhlaWdodDoxN3B4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjhweDttYXJnaW4tdG9wOjEwcHh9I2RnLWxvY2FsLWV4cGxhaW4gY29kZXtmb250LXNpemU6MTBweH0jZGF0LWd1aS1zYXZlLWxvY2FsbHl7ZGlzcGxheTpub25lfS5kZ3tjb2xvcjojZWVlO2ZvbnQ6MTFweCAnTHVjaWRhIEdyYW5kZScsIHNhbnMtc2VyaWY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgIzExMX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NXB4O2JhY2tncm91bmQ6IzFhMWExYX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVye2hlaWdodDowO2Rpc3BsYXk6bm9uZX0uZGcubWFpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDojNjc2NzY3fS5kZyBsaTpub3QoLmZvbGRlcil7YmFja2dyb3VuZDojMWExYTFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyYzJjMmN9LmRnIGxpLnNhdmUtcm93e2xpbmUtaGVpZ2h0OjI1cHg7YmFja2dyb3VuZDojZGFkNWNiO2JvcmRlcjowfS5kZyBsaS5zYXZlLXJvdyBzZWxlY3R7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjEwOHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue21hcmdpbi1sZWZ0OjVweDttYXJnaW4tdG9wOjFweDtib3JkZXItcmFkaXVzOjJweDtmb250LXNpemU6OXB4O2xpbmUtaGVpZ2h0OjdweDtwYWRkaW5nOjRweCA0cHggNXB4IDRweDtiYWNrZ3JvdW5kOiNjNWJkYWQ7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIDFweCAwICNiMGE1OGY7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmO2N1cnNvcjpwb2ludGVyfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uLmdlYXJze2JhY2tncm91bmQ6I2M1YmRhZCB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBc0FBQUFOQ0FZQUFBQi85WlE3QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVlLQVUvUC8vUHdHSUMvQXBDQUJpQlNBVytJOEFDbEFjZ0t4UTRUOWhvTUFFVXJ4eDJRU0dONitlZ0RYKy92V1Q0ZTdOODJBTVlvUEF4L2V2d1dvWW9TWWJBQ1gyczdLeEN4emNzZXpEaDNldkZvREVCWVRFRXF5Y2dnV0F6QTlBdVVTUVFnZVlQYTlmUHY2L1lXbS9BY3g1SVBiN3R5L2Z3K1FaYmx3Njd2RHM4UjBZSHlRaGdPYngreUFKa0JxbUc1ZFBQRGgxYVBPR1IvZXVnVzBHNHZsSW9USWZ5RmNBK1Fla2hoSEpoUGRReGJpQUlndU1CVFFaclBENzEwOE02cm9XWURGUWlJQUF2NkFvdy8xYkZ3WGdpcytmMkxVQXlud29JYU5jejhYTngzRGw3TUVKVURHUXB4OWd0UThZQ3VlQitEMjZPRUNBQVFEYWR0N2U0NkQ0MlFBQUFBQkpSVTVFcmtKZ2dnPT0pIDJweCAxcHggbm8tcmVwZWF0O2hlaWdodDo3cHg7d2lkdGg6OHB4fS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2JhYjE5ZTtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGZ9LmRnIGxpLmZvbGRlcntib3JkZXItYm90dG9tOjB9LmRnIGxpLnRpdGxle3BhZGRpbmctbGVmdDoxNnB4O2JhY2tncm91bmQ6IzAwMCB1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxJK2hLZ0Z4b0NnQU93PT0pIDZweCAxMHB4IG5vLXJlcGVhdDtjdXJzb3I6cG9pbnRlcjtib3JkZXItYm90dG9tOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMil9LmRnIC5jbG9zZWQgbGkudGl0bGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQlFBRkFKRUFBUC8vLy9QejgvLy8vLy8vL3lINUJBRUFBQUlBTEFBQUFBQUZBQVVBQUFJSWxHSVdxTUNiV0FFQU93PT0pfS5kZyAuY3IuYm9vbGVhbntib3JkZXItbGVmdDozcHggc29saWQgIzgwNjc4N30uZGcgLmNyLmNvbG9ye2JvcmRlci1sZWZ0OjNweCBzb2xpZH0uZGcgLmNyLmZ1bmN0aW9ue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjZTYxZDVmfS5kZyAuY3IubnVtYmVye2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMkZBMUQ2fS5kZyAuY3IubnVtYmVyIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzJGQTFENn0uZGcgLmNyLnN0cmluZ3tib3JkZXItbGVmdDozcHggc29saWQgIzFlZDM2Zn0uZGcgLmNyLnN0cmluZyBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMxZWQzNmZ9LmRnIC5jci5mdW5jdGlvbjpob3ZlciwuZGcgLmNyLmJvb2xlYW46aG92ZXJ7YmFja2dyb3VuZDojMTExfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JhY2tncm91bmQ6IzMwMzAzMDtvdXRsaW5lOm5vbmV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmZvY3Vze2JhY2tncm91bmQ6IzQ5NDk0OTtjb2xvcjojZmZmfS5kZyAuYyAuc2xpZGVye2JhY2tncm91bmQ6IzMwMzAzMDtjdXJzb3I6ZXctcmVzaXplfS5kZyAuYyAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzJGQTFENjttYXgtd2lkdGg6MTAwJX0uZGcgLmMgLnNsaWRlcjpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIC5zbGlkZXI6aG92ZXIgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiM0NGFiZGF9XFxuXCIpO1xuXG5jc3MuaW5qZWN0KHN0eWxlU2hlZXQpO1xudmFyIENTU19OQU1FU1BBQ0UgPSAnZGcnO1xudmFyIEhJREVfS0VZX0NPREUgPSA3MjtcbnZhciBDTE9TRV9CVVRUT05fSEVJR0hUID0gMjA7XG52YXIgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FID0gJ0RlZmF1bHQnO1xudmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSgpO1xudmFyIFNBVkVfRElBTE9HVUUgPSB2b2lkIDA7XG52YXIgYXV0b1BsYWNlVmlyZ2luID0gdHJ1ZTtcbnZhciBhdXRvUGxhY2VDb250YWluZXIgPSB2b2lkIDA7XG52YXIgaGlkZSA9IGZhbHNlO1xudmFyIGhpZGVhYmxlR3VpcyA9IFtdO1xudmFyIEdVSSA9IGZ1bmN0aW9uIEdVSShwYXJzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBwYXJhbXMgPSBwYXJzIHx8IHt9O1xuICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5fX3VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX191bCk7XG4gIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIENTU19OQU1FU1BBQ0UpO1xuICB0aGlzLl9fZm9sZGVycyA9IHt9O1xuICB0aGlzLl9fY29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzID0gW107XG4gIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnMgPSBbXTtcbiAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xuICBwYXJhbXMgPSBDb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgY2xvc2VPblRvcDogZmFsc2UsXG4gICAgYXV0b1BsYWNlOiB0cnVlLFxuICAgIHdpZHRoOiBHVUkuREVGQVVMVF9XSURUSFxuICB9KTtcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgIHJlc2l6YWJsZTogcGFyYW1zLmF1dG9QbGFjZSxcbiAgICBoaWRlYWJsZTogcGFyYW1zLmF1dG9QbGFjZVxuICB9KTtcbiAgaWYgKCFDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLmxvYWQpKSB7XG4gICAgaWYgKHBhcmFtcy5wcmVzZXQpIHtcbiAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHBhcmFtcy5wcmVzZXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xuICB9XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLmhpZGVhYmxlKSB7XG4gICAgaGlkZWFibGVHdWlzLnB1c2godGhpcyk7XG4gIH1cbiAgcGFyYW1zLnJlc2l6YWJsZSA9IENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMucmVzaXphYmxlO1xuICBpZiAocGFyYW1zLmF1dG9QbGFjZSAmJiBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnNjcm9sbGFibGUpKSB7XG4gICAgcGFyYW1zLnNjcm9sbGFibGUgPSB0cnVlO1xuICB9XG4gIHZhciB1c2VMb2NhbFN0b3JhZ2UgPSBTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2godGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJztcbiAgdmFyIHNhdmVUb0xvY2FsU3RvcmFnZSA9IHZvaWQgMDtcbiAgdmFyIHRpdGxlUm93ID0gdm9pZCAwO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLFxuICB7XG4gICAgcGFyZW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXJlbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBzY3JvbGxhYmxlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5zY3JvbGxhYmxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXV0b1BsYWNlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5hdXRvUGxhY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZU9uVG9wOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZU9uVG9wO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlc2V0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRSb290KCkucHJlc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZC5wcmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgX3RoaXMuZ2V0Um9vdCgpLnByZXNldCA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLmxvYWQucHJlc2V0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVzZXRTZWxlY3RJbmRleCh0aGlzKTtcbiAgICAgICAgX3RoaXMucmV2ZXJ0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMud2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMud2lkdGggPSB2O1xuICAgICAgICBzZXRXaWR0aChfdGhpcywgdik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5uYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLm5hbWUgPSB2O1xuICAgICAgICBpZiAodGl0bGVSb3cpIHtcbiAgICAgICAgICB0aXRsZVJvdy5pbm5lckhUTUwgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgICAgICBwYXJhbXMuY2xvc2VkID0gdjtcbiAgICAgICAgaWYgKHBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2FkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlTG9jYWxTdG9yYWdlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShib29sKSB7XG4gICAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlID0gYm9vbDtcbiAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgZG9tLmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnaXNMb2NhbCcpLCBib29sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHBhcmFtcy5jbG9zZWQgfHwgZmFsc2U7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX01BSU4pO1xuICAgIGRvbS5tYWtlU2VsZWN0YWJsZSh0aGlzLmRvbUVsZW1lbnQsIGZhbHNlKTtcbiAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgaWYgKHVzZUxvY2FsU3RvcmFnZSkge1xuICAgICAgICBfdGhpcy51c2VMb2NhbFN0b3JhZ2UgPSB0cnVlO1xuICAgICAgICB2YXIgc2F2ZWRHdWkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdndWknKSk7XG4gICAgICAgIGlmIChzYXZlZEd1aSkge1xuICAgICAgICAgIHBhcmFtcy5sb2FkID0gSlNPTi5wYXJzZShzYXZlZEd1aSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IEdVSS5URVhUX0NMT1NFRDtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OKTtcbiAgICBpZiAocGFyYW1zLmNsb3NlT25Ub3ApIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9UT1ApO1xuICAgICAgdGhpcy5kb21FbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9fY2xvc2VCdXR0b24sIHRoaXMuZG9tRWxlbWVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JPVFRPTSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2Nsb3NlQnV0dG9uKTtcbiAgICB9XG4gICAgZG9tLmJpbmQodGhpcy5fX2Nsb3NlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbXMuY2xvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdGl0bGVSb3dOYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFyYW1zLm5hbWUpO1xuICAgIGRvbS5hZGRDbGFzcyh0aXRsZVJvd05hbWUsICdjb250cm9sbGVyLW5hbWUnKTtcbiAgICB0aXRsZVJvdyA9IGFkZFJvdyhfdGhpcywgdGl0bGVSb3dOYW1lKTtcbiAgICB2YXIgb25DbGlja1RpdGxlID0gZnVuY3Rpb24gb25DbGlja1RpdGxlKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBkb20uYWRkQ2xhc3ModGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICBkb20uYWRkQ2xhc3ModGl0bGVSb3csICd0aXRsZScpO1xuICAgIGRvbS5iaW5kKHRpdGxlUm93LCAnY2xpY2snLCBvbkNsaWNrVGl0bGUpO1xuICAgIGlmICghcGFyYW1zLmNsb3NlZCkge1xuICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5hdXRvUGxhY2UpIHtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG4gICAgICBpZiAoYXV0b1BsYWNlVmlyZ2luKSB7XG4gICAgICAgIGF1dG9QbGFjZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXV0b1BsYWNlQ29udGFpbmVyLCBDU1NfTkFNRVNQQUNFKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhdXRvUGxhY2VDb250YWluZXIpO1xuICAgICAgICBhdXRvUGxhY2VWaXJnaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX0FVVE9fUExBQ0UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBzZXRXaWR0aChfdGhpcywgcGFyYW1zLndpZHRoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMub25SZXNpemVEZWJvdW5jZWQoKTtcbiAgfTtcbiAgZG9tLmJpbmQod2luZG93LCAncmVzaXplJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICd0cmFuc2l0aW9uZW5kJywgdGhpcy5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgdGhpcy5vblJlc2l6ZSgpO1xuICBpZiAocGFyYW1zLnJlc2l6YWJsZSkge1xuICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcbiAgfVxuICBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSkgPT09ICd0cnVlJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2d1aScpLCBKU09OLnN0cmluZ2lmeShfdGhpcy5nZXRTYXZlT2JqZWN0KCkpKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSA9IHNhdmVUb0xvY2FsU3RvcmFnZTtcbiAgZnVuY3Rpb24gcmVzZXRXaWR0aCgpIHtcbiAgICB2YXIgcm9vdCA9IF90aGlzLmdldFJvb3QoKTtcbiAgICByb290LndpZHRoICs9IDE7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJvb3Qud2lkdGggLT0gMTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcbiAgICByZXNldFdpZHRoKCk7XG4gIH1cbn07XG5HVUkudG9nZ2xlSGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgaGlkZSA9ICFoaWRlO1xuICBDb21tb24uZWFjaChoaWRlYWJsZUd1aXMsIGZ1bmN0aW9uIChndWkpIHtcbiAgICBndWkuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaGlkZSA/ICdub25lJyA6ICcnO1xuICB9KTtcbn07XG5HVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcbkdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUiA9ICdhYyc7XG5HVUkuQ0xBU1NfTUFJTiA9ICdtYWluJztcbkdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG5HVUkuQ0xBU1NfVE9PX1RBTEwgPSAndGFsbGVyLXRoYW4td2luZG93JztcbkdVSS5DTEFTU19DTE9TRUQgPSAnY2xvc2VkJztcbkdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcbkdVSS5DTEFTU19DTE9TRV9UT1AgPSAnY2xvc2UtdG9wJztcbkdVSS5DTEFTU19DTE9TRV9CT1RUT00gPSAnY2xvc2UtYm90dG9tJztcbkdVSS5DTEFTU19EUkFHID0gJ2RyYWcnO1xuR1VJLkRFRkFVTFRfV0lEVEggPSAyNDU7XG5HVUkuVEVYVF9DTE9TRUQgPSAnQ2xvc2UgQ29udHJvbHMnO1xuR1VJLlRFWFRfT1BFTiA9ICdPcGVuIENvbnRyb2xzJztcbkdVSS5fa2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50eXBlICE9PSAndGV4dCcgJiYgKGUud2hpY2ggPT09IEhJREVfS0VZX0NPREUgfHwgZS5rZXlDb2RlID09PSBISURFX0tFWV9DT0RFKSkge1xuICAgIEdVSS50b2dnbGVIaWRlKCk7XG4gIH1cbn07XG5kb20uYmluZCh3aW5kb3csICdrZXlkb3duJywgR1VJLl9rZXlkb3duSGFuZGxlciwgZmFsc2UpO1xuQ29tbW9uLmV4dGVuZChHVUkucHJvdG90eXBlLFxue1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgZmFjdG9yeUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICB9KTtcbiAgfSxcbiAgYWRkQ29sb3I6IGZ1bmN0aW9uIGFkZENvbG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gX2FkZCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICBjb2xvcjogdHJ1ZVxuICAgIH0pO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb250cm9sbGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNwbGljZSh0aGlzLl9fY29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSwgMSk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSB0aGUgcm9vdCBHVUkgc2hvdWxkIGJlIHJlbW92ZWQgd2l0aCAuZGVzdHJveSgpLiAnICsgJ0ZvciBzdWJmb2xkZXJzLCB1c2UgZ3VpLnJlbW92ZUZvbGRlcihmb2xkZXIpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgYXV0b1BsYWNlQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIF90aGlzLnJlbW92ZUZvbGRlcihzdWJmb2xkZXIpO1xuICAgIH0pO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcbiAgICByZW1vdmVMaXN0ZW5lcnModGhpcyk7XG4gIH0sXG4gIGFkZEZvbGRlcjogZnVuY3Rpb24gYWRkRm9sZGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fX2ZvbGRlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYWxyZWFkeSBoYXZlIGEgZm9sZGVyIGluIHRoaXMgR1VJIGJ5IHRoZScgKyAnIG5hbWUgXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cbiAgICB2YXIgbmV3R3VpUGFyYW1zID0geyBuYW1lOiBuYW1lLCBwYXJlbnQ6IHRoaXMgfTtcbiAgICBuZXdHdWlQYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0pIHtcbiAgICAgIG5ld0d1aVBhcmFtcy5jbG9zZWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXS5jbG9zZWQ7XG4gICAgICBuZXdHdWlQYXJhbXMubG9hZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdO1xuICAgIH1cbiAgICB2YXIgZ3VpID0gbmV3IEdVSShuZXdHdWlQYXJhbXMpO1xuICAgIHRoaXMuX19mb2xkZXJzW25hbWVdID0gZ3VpO1xuICAgIHZhciBsaSA9IGFkZFJvdyh0aGlzLCBndWkuZG9tRWxlbWVudCk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnZm9sZGVyJyk7XG4gICAgcmV0dXJuIGd1aTtcbiAgfSxcbiAgcmVtb3ZlRm9sZGVyOiBmdW5jdGlvbiByZW1vdmVGb2xkZXIoZm9sZGVyKSB7XG4gICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGZvbGRlci5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgIGRlbGV0ZSB0aGlzLl9fZm9sZGVyc1tmb2xkZXIubmFtZV07XG4gICAgaWYgKHRoaXMubG9hZCAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzICYmXG4gICAgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdKSB7XG4gICAgICBkZWxldGUgdGhpcy5sb2FkLmZvbGRlcnNbZm9sZGVyLm5hbWVdO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcnMoZm9sZGVyKTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKGZvbGRlci5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChzdWJmb2xkZXIpIHtcbiAgICAgIGZvbGRlci5yZW1vdmVGb2xkZXIoc3ViZm9sZGVyKTtcbiAgICB9KTtcbiAgICBDb21tb24uZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZXNpemUoKTtcbiAgICB9KTtcbiAgfSxcbiAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9LFxuICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH0sXG4gIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Um9vdCgpO1xuICAgIGlmIChyb290LnNjcm9sbGFibGUpIHtcbiAgICAgIHZhciB0b3AgPSBkb20uZ2V0T2Zmc2V0KHJvb3QuX191bCkudG9wO1xuICAgICAgdmFyIGggPSAwO1xuICAgICAgQ29tbW9uLmVhY2gocm9vdC5fX3VsLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghKHJvb3QuYXV0b1BsYWNlICYmIG5vZGUgPT09IHJvb3QuX19zYXZlX3JvdykpIHtcbiAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb290Ll9fcmVzaXplX2hhbmRsZSkge1xuICAgICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUuaGVpZ2h0ID0gcm9vdC5fX3VsLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJvb3QuX19jbG9zZUJ1dHRvbikge1xuICAgICAgcm9vdC5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gcm9vdC53aWR0aCArICdweCc7XG4gICAgfVxuICB9LFxuICBvblJlc2l6ZURlYm91bmNlZDogQ29tbW9uLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gIH0sIDUwKSxcbiAgcmVtZW1iZXI6IGZ1bmN0aW9uIHJlbWVtYmVyKCkge1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUgPSBuZXcgQ2VudGVyZWREaXYoKTtcbiAgICAgIFNBVkVfRElBTE9HVUUuZG9tRWxlbWVudC5pbm5lckhUTUwgPSBzYXZlRGlhbG9nQ29udGVudHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG9ubHkgY2FsbCByZW1lbWJlciBvbiBhIHRvcCBsZXZlbCBHVUkuJyk7XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmVhY2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFkZFNhdmVNZW51KF90aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICBzZXRXaWR0aCh0aGlzLCB0aGlzLndpZHRoKTtcbiAgICB9XG4gIH0sXG4gIGdldFJvb3Q6IGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgdmFyIGd1aSA9IHRoaXM7XG4gICAgd2hpbGUgKGd1aS5wYXJlbnQpIHtcbiAgICAgIGd1aSA9IGd1aS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBndWk7XG4gIH0sXG4gIGdldFNhdmVPYmplY3Q6IGZ1bmN0aW9uIGdldFNhdmVPYmplY3QoKSB7XG4gICAgdmFyIHRvUmV0dXJuID0gdGhpcy5sb2FkO1xuICAgIHRvUmV0dXJuLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuICAgIGlmICh0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgdG9SZXR1cm4ucHJlc2V0ID0gdGhpcy5wcmVzZXQ7XG4gICAgICBpZiAoIXRvUmV0dXJuLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgfVxuICAgICAgdG9SZXR1cm4ucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIH1cbiAgICB0b1JldHVybi5mb2xkZXJzID0ge307XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcbiAgICAgIHRvUmV0dXJuLmZvbGRlcnNba2V5XSA9IGVsZW1lbnQuZ2V0U2F2ZU9iamVjdCgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b1JldHVybjtcbiAgfSxcbiAgc2F2ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XG4gICAgdGhpcy5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKCk7XG4gIH0sXG4gIHNhdmVBczogZnVuY3Rpb24gc2F2ZUFzKHByZXNldE5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZCA9IHt9O1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW3ByZXNldE5hbWVdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICB0aGlzLnByZXNldCA9IHByZXNldE5hbWU7XG4gICAgYWRkUHJlc2V0T3B0aW9uKHRoaXMsIHByZXNldE5hbWUsIHRydWUpO1xuICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuICB9LFxuICByZXZlcnQ6IGZ1bmN0aW9uIHJldmVydChndWkpIHtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250cm9sbGVyLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlLmNhbGwoY29udHJvbGxlciwgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuICAgICAgZm9sZGVyLnJldmVydChmb2xkZXIpO1xuICAgIH0pO1xuICAgIGlmICghZ3VpKSB7XG4gICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcy5nZXRSb290KCksIGZhbHNlKTtcbiAgICB9XG4gIH0sXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGNvbnRyb2xsZXIpIHtcbiAgICB2YXIgaW5pdCA9IHRoaXMuX19saXN0ZW5pbmcubGVuZ3RoID09PSAwO1xuICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcbiAgICBpZiAoaW5pdCkge1xuICAgICAgdXBkYXRlRGlzcGxheXModGhpcy5fX2xpc3RlbmluZyk7XG4gICAgfVxuICB9LFxuICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19jb250cm9sbGVycywgZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZm9sZGVyKSB7XG4gICAgICBmb2xkZXIudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuICB9XG59KTtcbmZ1bmN0aW9uIGFkZFJvdyhndWksIG5ld0RvbSwgbGlCZWZvcmUpIHtcbiAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgaWYgKG5ld0RvbSkge1xuICAgIGxpLmFwcGVuZENoaWxkKG5ld0RvbSk7XG4gIH1cbiAgaWYgKGxpQmVmb3JlKSB7XG4gICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGxpLCBsaUJlZm9yZSk7XG4gIH0gZWxzZSB7XG4gICAgZ3VpLl9fdWwuYXBwZW5kQ2hpbGQobGkpO1xuICB9XG4gIGd1aS5vblJlc2l6ZSgpO1xuICByZXR1cm4gbGk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZ3VpKSB7XG4gIGRvbS51bmJpbmQod2luZG93LCAncmVzaXplJywgZ3VpLl9fcmVzaXplSGFuZGxlcik7XG4gIGlmIChndWkuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSkge1xuICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUHJlc2V0TW9kaWZpZWQoZ3VpLCBtb2RpZmllZCkge1xuICB2YXIgb3B0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuICBpZiAobW9kaWZpZWQpIHtcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgJyonO1xuICB9IGVsc2Uge1xuICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fX2xpID0gbGk7XG4gIGNvbnRyb2xsZXIuX19ndWkgPSBndWk7XG4gIENvbW1vbi5leHRlbmQoY29udHJvbGxlciwge1xuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoX29wdGlvbnMpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBuZXh0U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW0NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKENvbW1vbi5pc0FycmF5KF9vcHRpb25zKSB8fCBDb21tb24uaXNPYmplY3QoX29wdGlvbnMpKSB7XG4gICAgICAgIHZhciBfbmV4dFNpYmxpbmcgPSBjb250cm9sbGVyLl9fbGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gX2FkZChndWksIGNvbnRyb2xsZXIub2JqZWN0LCBjb250cm9sbGVyLnByb3BlcnR5LCB7XG4gICAgICAgICAgYmVmb3JlOiBfbmV4dFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtfb3B0aW9uc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBmdW5jdGlvbiBuYW1lKF9uYW1lKSB7XG4gICAgICBjb250cm9sbGVyLl9fbGkuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID0gX25hbWU7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJTbGlkZXIpIHtcbiAgICB2YXIgYm94ID0gbmV3IE51bWJlckNvbnRyb2xsZXJCb3goY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHsgbWluOiBjb250cm9sbGVyLl9fbWluLCBtYXg6IGNvbnRyb2xsZXIuX19tYXgsIHN0ZXA6IGNvbnRyb2xsZXIuX19zdGVwIH0pO1xuICAgIENvbW1vbi5lYWNoKFsndXBkYXRlRGlzcGxheScsICdvbkNoYW5nZScsICdvbkZpbmlzaENoYW5nZScsICdzdGVwJywgJ21pbicsICdtYXgnXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdmFyIHBjID0gY29udHJvbGxlclttZXRob2RdO1xuICAgICAgdmFyIHBiID0gYm94W21ldGhvZF07XG4gICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBwYi5hcHBseShib3gsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGMuYXBwbHkoY29udHJvbGxlciwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICBjb250cm9sbGVyLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJveC5kb21FbGVtZW50LCBjb250cm9sbGVyLmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyQm94KSB7XG4gICAgdmFyIHIgPSBmdW5jdGlvbiByKHJldHVybmVkKSB7XG4gICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19taW4pICYmIENvbW1vbi5pc051bWJlcihjb250cm9sbGVyLl9fbWF4KSkge1xuICAgICAgICB2YXIgb2xkTmFtZSA9IGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUw7XG4gICAgICAgIHZhciB3YXNMaXN0ZW5pbmcgPSBjb250cm9sbGVyLl9fZ3VpLl9fbGlzdGVuaW5nLmluZGV4T2YoY29udHJvbGxlcikgPiAtMTtcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcbiAgICAgICAgdmFyIG5ld0NvbnRyb2xsZXIgPSBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXIubmFtZShvbGROYW1lKTtcbiAgICAgICAgaWYgKHdhc0xpc3RlbmluZykgbmV3Q29udHJvbGxlci5saXN0ZW4oKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuZWQ7XG4gICAgfTtcbiAgICBjb250cm9sbGVyLm1pbiA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWluKTtcbiAgICBjb250cm9sbGVyLm1heCA9IENvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcbiAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmZha2VFdmVudChjb250cm9sbGVyLl9fY2hlY2tib3gsICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19idXR0b24sICdjbGljaycpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgbGkuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gY29udHJvbGxlci5fX2NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sIGNvbnRyb2xsZXIudXBkYXRlRGlzcGxheSk7XG4gICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KCk7XG4gIH1cbiAgY29udHJvbGxlci5zZXRWYWx1ZSA9IENvbW1vbi5jb21wb3NlKGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgIG1hcmtQcmVzZXRNb2RpZmllZChndWkuZ2V0Um9vdCgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG59XG5mdW5jdGlvbiByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcikge1xuICB2YXIgcm9vdCA9IGd1aS5nZXRSb290KCk7XG4gIHZhciBtYXRjaGVkSW5kZXggPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihjb250cm9sbGVyLm9iamVjdCk7XG4gIGlmIChtYXRjaGVkSW5kZXggIT09IC0xKSB7XG4gICAgdmFyIGNvbnRyb2xsZXJNYXAgPSByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF07XG4gICAgaWYgKGNvbnRyb2xsZXJNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udHJvbGxlck1hcCA9IHt9O1xuICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkSW5kZXhdID0gY29udHJvbGxlck1hcDtcbiAgICB9XG4gICAgY29udHJvbGxlck1hcFtjb250cm9sbGVyLnByb3BlcnR5XSA9IGNvbnRyb2xsZXI7XG4gICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdmFyIHByZXNldE1hcCA9IHJvb3QubG9hZC5yZW1lbWJlcmVkO1xuICAgICAgdmFyIHByZXNldCA9IHZvaWQgMDtcbiAgICAgIGlmIChwcmVzZXRNYXBbZ3VpLnByZXNldF0pIHtcbiAgICAgICAgcHJlc2V0ID0gcHJlc2V0TWFwW2d1aS5wcmVzZXRdO1xuICAgICAgfSBlbHNlIGlmIChwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXRbbWF0Y2hlZEluZGV4XSAmJiBwcmVzZXRbbWF0Y2hlZEluZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldO1xuICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcbiAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IFwiJyArIG9iamVjdCArICdcIiBoYXMgbm8gcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCInKTtcbiAgfVxuICB2YXIgY29udHJvbGxlciA9IHZvaWQgMDtcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIGNvbnRyb2xsZXIgPSBuZXcgQ29sb3JDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBmYWN0b3J5QXJncyA9IFtvYmplY3QsIHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICBjb250cm9sbGVyID0gQ29udHJvbGxlckZhY3RvcnkuYXBwbHkoZ3VpLCBmYWN0b3J5QXJncyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5iZWZvcmUgaW5zdGFuY2VvZiBDb250cm9sbGVyKSB7XG4gICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgfVxuICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG4gIGRvbS5hZGRDbGFzcyhjb250cm9sbGVyLmRvbUVsZW1lbnQsICdjJyk7XG4gIHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBkb20uYWRkQ2xhc3MobmFtZSwgJ3Byb3BlcnR5LW5hbWUnKTtcbiAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRyb2xsZXIuZG9tRWxlbWVudCk7XG4gIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG4gIGRvbS5hZGRDbGFzcyhsaSwgR1VJLkNMQVNTX0NPTlRST0xMRVJfUk9XKTtcbiAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBDb2xvckNvbnRyb2xsZXIpIHtcbiAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgX3R5cGVvZihjb250cm9sbGVyLmdldFZhbHVlKCkpKTtcbiAgfVxuICBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKTtcbiAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgcmV0dXJuIGNvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmICsgJy4nICsga2V5O1xufVxuZnVuY3Rpb24gYWRkUHJlc2V0T3B0aW9uKGd1aSwgbmFtZSwgc2V0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgb3B0LnZhbHVlID0gbmFtZTtcbiAgZ3VpLl9fcHJlc2V0X3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aCAtIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pIHtcbiAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG59XG5mdW5jdGlvbiBhZGRTYXZlTWVudShndWkpIHtcbiAgdmFyIGRpdiA9IGd1aS5fX3NhdmVfcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcbiAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGRpdiwgZ3VpLl9fdWwuZmlyc3RDaGlsZCk7XG4gIGRvbS5hZGRDbGFzcyhkaXYsICdzYXZlLXJvdycpO1xuICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGdlYXJzLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICBkb20uYWRkQ2xhc3MoZ2VhcnMsICdidXR0b24gZ2VhcnMnKTtcbiAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uLmlubmVySFRNTCA9ICdTYXZlJztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnc2F2ZScpO1xuICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgYnV0dG9uMi5pbm5lckhUTUwgPSAnTmV3JztcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdidXR0b24nKTtcbiAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG4gIHZhciBidXR0b24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMywgJ3JldmVydCcpO1xuICB2YXIgc2VsZWN0ID0gZ3VpLl9fcHJlc2V0X3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgIENvbW1vbi5lYWNoKGd1aS5sb2FkLnJlbWVtYmVyZWQsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBrZXksIGtleSA9PT0gZ3VpLnByZXNldCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gIH1cbiAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBndWkuX19wcmVzZXRfc2VsZWN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0uaW5uZXJIVE1MID0gZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIGd1aS5wcmVzZXQgPSB0aGlzLnZhbHVlO1xuICB9KTtcbiAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gIGRpdi5hcHBlbmRDaGlsZChnZWFycyk7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24zKTtcbiAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICB2YXIgZXhwbGFpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1sb2NhbC1leHBsYWluJyk7XG4gICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcbiAgICB2YXIgc2F2ZUxvY2FsbHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctc2F2ZS1sb2NhbGx5Jyk7XG4gICAgc2F2ZUxvY2FsbHkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2VDaGVja0JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgIH1cbiAgICBzaG93SGlkZUV4cGxhaW4oZ3VpLCBleHBsYWluKTtcbiAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGd1aS51c2VMb2NhbFN0b3JhZ2UgPSAhZ3VpLnVzZUxvY2FsU3RvcmFnZTtcbiAgICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuICAgIH0pO1xuICB9XG4gIHZhciBuZXdDb25zdHJ1Y3RvclRleHRBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLW5ldy1jb25zdHJ1Y3RvcicpO1xuICBkb20uYmluZChuZXdDb25zdHJ1Y3RvclRleHRBcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09PSA2NykpIHtcbiAgICAgIFNBVkVfRElBTE9HVUUuaGlkZSgpO1xuICAgIH1cbiAgfSk7XG4gIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShndWkuZ2V0U2F2ZU9iamVjdCgpLCB1bmRlZmluZWQsIDIpO1xuICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuZm9jdXMoKTtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLnNlbGVjdCgpO1xuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgZ3VpLnNhdmUoKTtcbiAgfSk7XG4gIGRvbS5iaW5kKGJ1dHRvbjIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgaWYgKHByZXNldE5hbWUpIHtcbiAgICAgIGd1aS5zYXZlQXMocHJlc2V0TmFtZSk7XG4gICAgfVxuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uMywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIGd1aS5yZXZlcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRSZXNpemVIYW5kbGUoZ3VpKSB7XG4gIHZhciBwbW91c2VYID0gdm9pZCAwO1xuICBndWkuX19yZXNpemVfaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIENvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuICAgIHdpZHRoOiAnNnB4JyxcbiAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgIGN1cnNvcjogJ2V3LXJlc2l6ZScsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgfSk7XG4gIGZ1bmN0aW9uIGRyYWcoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBndWkud2lkdGggKz0gcG1vdXNlWCAtIGUuY2xpZW50WDtcbiAgICBndWkub25SZXNpemUoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcbiAgICBkb20ucmVtb3ZlQ2xhc3MoZ3VpLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19EUkFHKTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcbiAgfVxuICBmdW5jdGlvbiBkcmFnU3RhcnQoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuICAgIGRvbS5hZGRDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRvbS5iaW5kKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuICBkb20uYmluZChndWkuX19jbG9zZUJ1dHRvbiwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gIGd1aS5kb21FbGVtZW50Lmluc2VydEJlZm9yZShndWkuX19yZXNpemVfaGFuZGxlLCBndWkuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG59XG5mdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgaWYgKGd1aS5fX3NhdmVfcm93ICYmIGd1aS5hdXRvUGxhY2UpIHtcbiAgICBndWkuX19zYXZlX3Jvdy5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICB9XG4gIGlmIChndWkuX19jbG9zZUJ1dHRvbikge1xuICAgIGd1aS5fX2Nsb3NlQnV0dG9uLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG4gIHZhciB0b1JldHVybiA9IHt9O1xuICBDb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICB2YXIgc2F2ZWRWYWx1ZXMgPSB7fTtcbiAgICB2YXIgY29udHJvbGxlck1hcCA9IGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG4gICAgQ29tbW9uLmVhY2goY29udHJvbGxlck1hcCwgZnVuY3Rpb24gKGNvbnRyb2xsZXIsIHByb3BlcnR5KSB7XG4gICAgICBzYXZlZFZhbHVlc1twcm9wZXJ0eV0gPSB1c2VJbml0aWFsVmFsdWVzID8gY29udHJvbGxlci5pbml0aWFsVmFsdWUgOiBjb250cm9sbGVyLmdldFZhbHVlKCk7XG4gICAgfSk7XG4gICAgdG9SZXR1cm5baW5kZXhdID0gc2F2ZWRWYWx1ZXM7XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59XG5mdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlID09PSBndWkucHJlc2V0KSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSkge1xuICBpZiAoY29udHJvbGxlckFycmF5Lmxlbmd0aCAhPT0gMCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgIH0pO1xuICB9XG4gIENvbW1vbi5lYWNoKGNvbnRyb2xsZXJBcnJheSwgZnVuY3Rpb24gKGMpIHtcbiAgICBjLnVwZGF0ZURpc3BsYXkoKTtcbiAgfSk7XG59XG5cbnZhciBjb2xvciA9IHtcbiAgQ29sb3I6IENvbG9yLFxuICBtYXRoOiBDb2xvck1hdGgsXG4gIGludGVycHJldDogaW50ZXJwcmV0XG59O1xudmFyIGNvbnRyb2xsZXJzID0ge1xuICBDb250cm9sbGVyOiBDb250cm9sbGVyLFxuICBCb29sZWFuQ29udHJvbGxlcjogQm9vbGVhbkNvbnRyb2xsZXIsXG4gIE9wdGlvbkNvbnRyb2xsZXI6IE9wdGlvbkNvbnRyb2xsZXIsXG4gIFN0cmluZ0NvbnRyb2xsZXI6IFN0cmluZ0NvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXI6IE51bWJlckNvbnRyb2xsZXIsXG4gIE51bWJlckNvbnRyb2xsZXJCb3g6IE51bWJlckNvbnRyb2xsZXJCb3gsXG4gIE51bWJlckNvbnRyb2xsZXJTbGlkZXI6IE51bWJlckNvbnRyb2xsZXJTbGlkZXIsXG4gIEZ1bmN0aW9uQ29udHJvbGxlcjogRnVuY3Rpb25Db250cm9sbGVyLFxuICBDb2xvckNvbnRyb2xsZXI6IENvbG9yQ29udHJvbGxlclxufTtcbnZhciBkb20kMSA9IHsgZG9tOiBkb20gfTtcbnZhciBndWkgPSB7IEdVSTogR1VJIH07XG52YXIgR1VJJDEgPSBHVUk7XG52YXIgaW5kZXggPSB7XG4gIGNvbG9yOiBjb2xvcixcbiAgY29udHJvbGxlcnM6IGNvbnRyb2xsZXJzLFxuICBkb206IGRvbSQxLFxuICBndWk6IGd1aSxcbiAgR1VJOiBHVUkkMVxufTtcblxuZXhwb3J0IHsgY29sb3IsIGNvbnRyb2xsZXJzLCBkb20kMSBhcyBkb20sIGd1aSwgR1VJJDEgYXMgR1VJIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdC5ndWkubW9kdWxlLmpzLm1hcFxuIiwiZXhwb3J0IGRlZmF1bHQgXCJjb25zdCBQSTogZjMyID0gMy4xNDE1OTI2NTM1OTtcXHJcXG5cXHJcXG5zdHJ1Y3QgRmFjZSB7XFxyXFxuICAgIGZvcndhcmQ6IHZlYzNmLFxcclxcbiAgICB1cDogdmVjM2YsXFxyXFxuICAgIHJpZ2h0OiB2ZWMzZixcXHJcXG59XFxyXFxuXFxyXFxuQGdyb3VwKDApXFxyXFxuQGJpbmRpbmcoMClcXHJcXG52YXIgc3JjOiB0ZXh0dXJlXzJkPGYzMj47XFxyXFxuXFxyXFxuQGdyb3VwKDApXFxyXFxuQGJpbmRpbmcoMSlcXHJcXG52YXIgZHN0OiB0ZXh0dXJlX3N0b3JhZ2VfMmRfYXJyYXk8cmdiYTMyZmxvYXQsIHdyaXRlPjtcXHJcXG5cXHJcXG5AY29tcHV0ZVxcclxcbkB3b3JrZ3JvdXBfc2l6ZSgxNiwgMTYsIDEpXFxyXFxuZm4gY29tcHV0ZV9tYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnaWQ6IHZlYzN1KSB7XFxyXFxuICAgIC8vIElmIHRleHR1cmUgc2l6ZSBpcyBub3QgZGl2aXNpYmxlIGJ5IDMyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCB0cnkgdG8gd3JpdGUgdG8gcGl4ZWxzIHRoYXQgZG9uJ3QgZXhpc3QuXFxyXFxuICAgIGlmIGdpZC54ID49IHUzMih0ZXh0dXJlRGltZW5zaW9ucyhkc3QpLngpIHtcXHJcXG4gICAgICAgIHJldHVybjtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBsZXQgZmFjZXM6IGFycmF5PEZhY2UsIDY+ID0gYXJyYXkoXFxyXFxuICAgICAgICAvLyBGQUNFUyArWFxcclxcbiAgICAgICAgRmFjZShcXHJcXG4gICAgICAgICAgICB2ZWMzKDEuMCwgMC4wLCAwLjApLCAgLy8gZm9yd2FyZFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAxLjAsIDAuMCksICAvLyB1cFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAwLjAsIC0xLjApLCAvLyByaWdodFxcclxcbiAgICAgICAgKSxcXHJcXG4gICAgICAgIC8vIEZBQ0VTIC1YXFxyXFxuICAgICAgICBGYWNlIChcXHJcXG4gICAgICAgICAgICB2ZWMzKC0xLjAsIDAuMCwgMC4wKSxcXHJcXG4gICAgICAgICAgICB2ZWMzKDAuMCwgMS4wLCAwLjApLFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAwLjAsIDEuMCksXFxyXFxuICAgICAgICApLFxcclxcbiAgICAgICAgLy8gRkFDRVMgK1lcXHJcXG4gICAgICAgIEZhY2UgKFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAtMS4wLCAwLjApLFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAwLjAsIDEuMCksXFxyXFxuICAgICAgICAgICAgdmVjMygxLjAsIDAuMCwgMC4wKSxcXHJcXG4gICAgICAgICksXFxyXFxuICAgICAgICAvLyBGQUNFUyAtWVxcclxcbiAgICAgICAgRmFjZSAoXFxyXFxuICAgICAgICAgICAgdmVjMygwLjAsIDEuMCwgMC4wKSxcXHJcXG4gICAgICAgICAgICB2ZWMzKDAuMCwgMC4wLCAtMS4wKSxcXHJcXG4gICAgICAgICAgICB2ZWMzKDEuMCwgMC4wLCAwLjApLFxcclxcbiAgICAgICAgKSxcXHJcXG4gICAgICAgIC8vIEZBQ0VTICtaXFxyXFxuICAgICAgICBGYWNlIChcXHJcXG4gICAgICAgICAgICB2ZWMzKDAuMCwgMC4wLCAxLjApLFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAxLjAsIDAuMCksXFxyXFxuICAgICAgICAgICAgdmVjMygxLjAsIDAuMCwgMC4wKSxcXHJcXG4gICAgICAgICksXFxyXFxuICAgICAgICAvLyBGQUNFUyAtWlxcclxcbiAgICAgICAgRmFjZSAoXFxyXFxuICAgICAgICAgICAgdmVjMygwLjAsIDAuMCwgLTEuMCksXFxyXFxuICAgICAgICAgICAgdmVjMygwLjAsIDEuMCwgMC4wKSxcXHJcXG4gICAgICAgICAgICB2ZWMzKC0xLjAsIDAuMCwgMC4wKSxcXHJcXG4gICAgICAgICksXFxyXFxuICAgICk7XFxyXFxuXFxyXFxuICAgIC8vIEdldCB0ZXh0dXJlIGNvb3JkcyByZWxhdGl2ZSB0byBjdWJlbWFwIGZhY2VcXHJcXG4gICAgbGV0IGRzdERpbWVuc2lvbnMgPSB2ZWMyPGYzMj4odGV4dHVyZURpbWVuc2lvbnMoZHN0KSk7XFxyXFxuICAgIGxldCBjdWJlVVYgPSB2ZWMyPGYzMj4oZ2lkLnh5KSAvIGRzdERpbWVuc2lvbnMgKiAyLjAgLSAxLjA7XFxyXFxuXFxyXFxuICAgIC8vIEdldCBzcGhlcmljYWwgY29vcmRpbmF0ZSBmcm9tIGN1YmVVVlxcclxcbiAgICBsZXQgZmFjZSA9IGZhY2VzW2dpZC56XTtcXHJcXG4gICAgbGV0IHNwaGVyaWNhbCA9IG5vcm1hbGl6ZShmYWNlLmZvcndhcmQgKyBmYWNlLnJpZ2h0ICogY3ViZVVWLnggKyBmYWNlLnVwICogY3ViZVVWLnkpO1xcclxcblxcclxcbiAgICAvLyBHZXQgY29vcmRpbmF0ZSBvbiB0aGUgZXF1aXJlY3Rhbmd1bGFyIHRleHR1cmVcXHJcXG4gICAgbGV0IGludkF0YW4gPSB2ZWMyKDAuMTU5MSwgMC4zMTgzKTtcXHJcXG4gICAgbGV0IGVxVVYgPSB2ZWMyKGF0YW4yKHNwaGVyaWNhbC56LCBzcGhlcmljYWwueCksIGFzaW4oc3BoZXJpY2FsLnkpKSAqIGludkF0YW4gKyAwLjU7XFxyXFxuICAgIGxldCBlcVBpeGVsID0gdmVjMjxpMzI+KGVxVVYgKiB2ZWMyPGYzMj4odGV4dHVyZURpbWVuc2lvbnMoc3JjKSkpO1xcclxcblxcclxcbiAgICAvLyBXZSB1c2UgdGV4dHVyZUxvYWQoKSBhcyB0ZXh0dXJlU2FtcGxlKCkgaXMgbm90IGFsbG93ZWQgaW4gY29tcHV0ZSBzaGFkZXJzXFxyXFxuICAgIGxldCBzYW1wbGUgPSB0ZXh0dXJlTG9hZChzcmMsIGVxUGl4ZWwsIDApO1xcclxcblxcclxcbiAgICB0ZXh0dXJlU3RvcmUoZHN0LCBnaWQueHksIGdpZC56LCBzYW1wbGUpO1xcclxcbn1cXHJcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcImNvbnN0IFBJOiBmMzIgPSAzLjE0MTU5MjY1MzU5O1xcclxcblxcclxcbnN0cnVjdCBGYWNlIHtcXHJcXG4gICAgZm9yd2FyZDogdmVjM2YsXFxyXFxuICAgIHVwOiB2ZWMzZixcXHJcXG4gICAgcmlnaHQ6IHZlYzNmLFxcclxcbn1cXHJcXG5cXHJcXG5AZ3JvdXAoMClcXHJcXG5AYmluZGluZygwKVxcclxcbnZhciBzcmM6IHRleHR1cmVfc3RvcmFnZV8yZF9hcnJheTxyZ2JhMzJmbG9hdCwgcmVhZD47XFxyXFxuXFxyXFxuQGdyb3VwKDApXFxyXFxuQGJpbmRpbmcoMSlcXHJcXG52YXIgZHN0OiB0ZXh0dXJlX3N0b3JhZ2VfMmRfYXJyYXk8cmdiYTMyZmxvYXQsIHdyaXRlPjtcXHJcXG5cXHJcXG5AY29tcHV0ZVxcclxcbkB3b3JrZ3JvdXBfc2l6ZSgxNiwgMTYsIDEpXFxyXFxuZm4gY29tcHV0ZV9tYWluKEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnaWQ6IHZlYzN1KSB7XFxyXFxuICAgIC8vIElmIHRleHR1cmUgc2l6ZSBpcyBub3QgZGl2aXNpYmxlIGJ5IDMyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCB0cnkgdG8gd3JpdGUgdG8gcGl4ZWxzIHRoYXQgZG9uJ3QgZXhpc3QuXFxyXFxuICAgIGlmIGdpZC54ID49IHUzMih0ZXh0dXJlRGltZW5zaW9ucyhkc3QpLngpIHtcXHJcXG4gICAgICAgIHJldHVybjtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBsZXQgZmFjZXM6IGFycmF5PEZhY2UsIDY+ID0gYXJyYXkoXFxyXFxuICAgICAgICAvLyBGQUNFUyArWFxcclxcbiAgICAgICAgRmFjZShcXHJcXG4gICAgICAgICAgICB2ZWMzKDEuMCwgMC4wLCAwLjApLCAgLy8gZm9yd2FyZFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAxLjAsIDAuMCksICAvLyB1cFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAwLjAsIC0xLjApLCAvLyByaWdodFxcclxcbiAgICAgICAgKSxcXHJcXG4gICAgICAgIC8vIEZBQ0VTIC1YXFxyXFxuICAgICAgICBGYWNlIChcXHJcXG4gICAgICAgICAgICB2ZWMzKC0xLjAsIDAuMCwgMC4wKSxcXHJcXG4gICAgICAgICAgICB2ZWMzKDAuMCwgMS4wLCAwLjApLFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAwLjAsIDEuMCksXFxyXFxuICAgICAgICApLFxcclxcbiAgICAgICAgLy8gRkFDRVMgK1lcXHJcXG4gICAgICAgIEZhY2UgKFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAtMS4wLCAwLjApLFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAwLjAsIDEuMCksXFxyXFxuICAgICAgICAgICAgdmVjMygxLjAsIDAuMCwgMC4wKSxcXHJcXG4gICAgICAgICksXFxyXFxuICAgICAgICAvLyBGQUNFUyAtWVxcclxcbiAgICAgICAgRmFjZSAoXFxyXFxuICAgICAgICAgICAgdmVjMygwLjAsIDEuMCwgMC4wKSxcXHJcXG4gICAgICAgICAgICB2ZWMzKDAuMCwgMC4wLCAtMS4wKSxcXHJcXG4gICAgICAgICAgICB2ZWMzKDEuMCwgMC4wLCAwLjApLFxcclxcbiAgICAgICAgKSxcXHJcXG4gICAgICAgIC8vIEZBQ0VTICtaXFxyXFxuICAgICAgICBGYWNlIChcXHJcXG4gICAgICAgICAgICB2ZWMzKDAuMCwgMC4wLCAxLjApLFxcclxcbiAgICAgICAgICAgIHZlYzMoMC4wLCAxLjAsIDAuMCksXFxyXFxuICAgICAgICAgICAgdmVjMygxLjAsIDAuMCwgMC4wKSxcXHJcXG4gICAgICAgICksXFxyXFxuICAgICAgICAvLyBGQUNFUyAtWlxcclxcbiAgICAgICAgRmFjZSAoXFxyXFxuICAgICAgICAgICAgdmVjMygwLjAsIDAuMCwgLTEuMCksXFxyXFxuICAgICAgICAgICAgdmVjMygwLjAsIDEuMCwgMC4wKSxcXHJcXG4gICAgICAgICAgICB2ZWMzKC0xLjAsIDAuMCwgMC4wKSxcXHJcXG4gICAgICAgICksXFxyXFxuICAgICk7XFxyXFxuXFxyXFxuICAgIC8vIEdldCB0ZXh0dXJlIGNvb3JkcyByZWxhdGl2ZSB0byBjdWJlbWFwIGZhY2VcXHJcXG4gICAgbGV0IGRzdERpbWVuc2lvbnMgPSB2ZWMyPGYzMj4odGV4dHVyZURpbWVuc2lvbnMoZHN0KSk7XFxyXFxuICAgIGxldCBjdWJlVVYgPSB2ZWMyPGYzMj4oZ2lkLnh5KSAvIGRzdERpbWVuc2lvbnMgKiAyLjAgLSAxLjA7XFxyXFxuXFxyXFxuICAgIC8vIEdldCBzcGhlcmljYWwgY29vcmRpbmF0ZSBmcm9tIGN1YmVVVlxcclxcbiAgICBsZXQgZmFjZSA9IGZhY2VzW2dpZC56XTtcXHJcXG4gICAgbGV0IHNwaGVyaWNhbCA9IG5vcm1hbGl6ZShmYWNlLmZvcndhcmQgKyBmYWNlLnJpZ2h0ICogY3ViZVVWLnggKyBmYWNlLnVwICogY3ViZVVWLnkpO1xcclxcblxcclxcbiAgICB2YXIgaXJyYWRpYW5jZSA9IHZlYzMoMC4wKTsgICBcXHJcXG4gICAgXFxyXFxuICAgIC8vIHRhbmdlbnQgc3BhY2UgY2FsY3VsYXRpb24gZnJvbSBvcmlnaW4gcG9pbnRcXHJcXG4gICAgdmFyIHVwICAgID0gdmVjMygwLjAsIDEuMCwgMC4wKTtcXHJcXG4gICAgbGV0IHJpZ2h0ID0gbm9ybWFsaXplKGNyb3NzKHVwLCBzcGhlcmljYWwpKTtcXHJcXG4gICAgdXAgPSBub3JtYWxpemUoY3Jvc3Moc3BoZXJpY2FsLCByaWdodCkpO1xcclxcblxcclxcbiAgICBsZXQgaW52QXRhbiA9IHZlYzIoMC4xNTkxLCAwLjMxODMpO1xcclxcblxcclxcbiAgICBsZXQgc2FtcGxlRGVsdGEgPSAwLjAyNTtcXHJcXG4gICAgdmFyIG5yU2FtcGxlcyA9IDA7XFxyXFxuICAgIGZvcih2YXIgcGhpID0gMC4wOyBwaGkgPCAyLjAgKiBQSTsgcGhpICs9IHNhbXBsZURlbHRhKVxcclxcbiAgICB7XFxyXFxuICAgICAgICBmb3IodmFyIHRoZXRhID0gMC4wOyB0aGV0YSA8IDAuNSAqIFBJOyB0aGV0YSArPSBzYW1wbGVEZWx0YSlcXHJcXG4gICAgICAgIHtcXHJcXG4gICAgICAgICAgICAvLyBzcGhlcmljYWwgdG8gY2FydGVzaWFuIChpbiB0YW5nZW50IHNwYWNlKVxcclxcbiAgICAgICAgICAgIGxldCB0YW5nZW50U2FtcGxlID0gdmVjM2Yoc2luKHRoZXRhKSAqIGNvcyhwaGkpLCAgc2luKHRoZXRhKSAqIHNpbihwaGkpLCBjb3ModGhldGEpKTtcXHJcXG4gICAgICAgICAgICAvLyB0YW5nZW50IHNwYWNlIHRvIHdvcmxkXFxyXFxuICAgICAgICAgICAgbGV0IHNhbXBsZVZlYyA9IHRhbmdlbnRTYW1wbGUueCAqIHJpZ2h0ICsgdGFuZ2VudFNhbXBsZS55ICogdXAgKyB0YW5nZW50U2FtcGxlLnogKiBzcGhlcmljYWw7XFxyXFxuICAgICAgICAgICAgbGV0IGVxVVYgPSB2ZWMyKGF0YW4yKHNhbXBsZVZlYy56LCBzYW1wbGVWZWMueCksIGFzaW4oc2FtcGxlVmVjLnkpKSAqIGludkF0YW4gKyAwLjU7XFxyXFxuICAgICAgICAgICAgbGV0IGVxUGl4ZWwgPSB2ZWMyPGkzMj4oZXFVViAqIHZlYzI8ZjMyPih0ZXh0dXJlRGltZW5zaW9ucyhzcmMpKSk7XFxyXFxuICAgICAgICAgICAgLy8gV2UgdXNlIHRleHR1cmVMb2FkKCkgYXMgdGV4dHVyZVNhbXBsZSgpIGlzIG5vdCBhbGxvd2VkIGluIGNvbXB1dGUgc2hhZGVyc1xcclxcbiAgICAgICAgICAgIGlycmFkaWFuY2UgKz0gdGV4dHVyZUxvYWQoc3JjLCBlcVBpeGVsLCBnaWQueikucmdiICogY29zKHRoZXRhKSAqIHNpbih0aGV0YSk7XFxyXFxuICAgICAgICAgICAgbnJTYW1wbGVzKys7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgaXJyYWRpYW5jZSA9IFBJICogaXJyYWRpYW5jZSAqICgxLjAgLyBmMzIobnJTYW1wbGVzKSk7XFxyXFxuXFxyXFxuICAgIHRleHR1cmVTdG9yZShkc3QsIGdpZC54eSwgZ2lkLnosIHZlYzRmKGlycmFkaWFuY2UsIDEuMCkpO1xcclxcbn1cXHJcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIlxcclxcbnN0cnVjdCBWZXJ0ZXhJbnB1dCB7XFxyXFxuICBAbG9jYXRpb24oMCkgcG9zaXRpb246IHZlYzRmLFxcclxcbiAgQGxvY2F0aW9uKDEpIHRleENvb3JkOiB2ZWMyZixcXHJcXG59O1xcclxcblxcclxcbnN0cnVjdCBWZXJ0ZXhPdXQge1xcclxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0ZixcXHJcXG4gIEBsb2NhdGlvbigwKSB0ZXhDb29yZDogdmVjMmYsXFxyXFxufTtcXHJcXG5cXHJcXG5AdmVydGV4XFxyXFxuZm4gdnNfbWFpbih2ZXJ0RGF0YTogVmVydGV4SW5wdXQpIC0+IFZlcnRleE91dCB7XFxyXFxuICB2YXIgb3V0OiBWZXJ0ZXhPdXQ7XFxyXFxuICBvdXQucG9zaXRpb24gPSB2ZWM0Zih2ZXJ0RGF0YS5wb3NpdGlvbik7XFxyXFxuICBvdXQudGV4Q29vcmQgPSB2ZXJ0RGF0YS50ZXhDb29yZDtcXHJcXG4gIHJldHVybiBvdXQ7XFxyXFxufVxcclxcblxcclxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXIgbXlTYW1wbGVyOiBzYW1wbGVyO1xcclxcbkBncm91cCgwKSBAYmluZGluZygxKSB2YXIgbXlUZXh0dXJlOiB0ZXh0dXJlXzJkPGYzMj47XFxyXFxuXFxyXFxuQGZyYWdtZW50IFxcclxcbmZuIGZzX21haW4oZnJhZ0RhdGE6IFZlcnRleE91dCkgLT4gQGxvY2F0aW9uKDApIHZlYzRmIHtcXHJcXG4gIHJldHVybiB0ZXh0dXJlU2FtcGxlKG15VGV4dHVyZSwgbXlTYW1wbGVyLCBmcmFnRGF0YS50ZXhDb29yZCk7XFxyXFxufVxcclxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwic3RydWN0IFZlcnRleElucHV0IHtcXHJcXG4gIEBsb2NhdGlvbigwKSBwb3NpdGlvbiA6IHZlYzNmLFxcclxcbiAgQGxvY2F0aW9uKDEpIHRleENvb3JkIDogdmVjMmYsXFxyXFxuICBAbG9jYXRpb24oMikgbm9ybWFsIDogdmVjM2ZcXHJcXG59O1xcclxcblxcclxcbnN0cnVjdCBWZXJ0ZXhPdXQge1xcclxcbiAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uIDogdmVjNGYsXFxyXFxuICBAbG9jYXRpb24oMCkgdGV4Q29vcmQgOiB2ZWMyZixcXHJcXG4gIEBsb2NhdGlvbigxKSBub3JtYWwgOiB2ZWMzZixcXHJcXG4gIEBsb2NhdGlvbigyKSBwb3M6IHZlYzNmLFxcclxcbn07XFxyXFxuXFxyXFxuc3RydWN0IFRyYW5zZm9ybSB7XFxyXFxuICBtb2RlbDogbWF0NHg0ZixcXHJcXG4gIG5vcm1hbDogbWF0NHg0ZixcXHJcXG4gIHZpZXc6IG1hdDR4NGYsXFxyXFxuICBwcm9qZWN0aW9uOiBtYXQ0eDRmLFxcclxcbn07XFxyXFxuXFxyXFxuQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjx1bmlmb3JtPiB0cmFuc2Zvcm06IFRyYW5zZm9ybTtcXHJcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHVuaWZvcm0+IHZpZXdQb3M6IHZlYzNmO1xcclxcbkBncm91cCgwKSBAYmluZGluZygyKSB2YXI8dW5pZm9ybT4gbGlnaHRQb3NpdGlvbnM6IGFycmF5PHZlYzNmLCA0PjtcXHJcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IGxpZ2h0Q29sb3JzOiBhcnJheTx2ZWMzZiwgND47XFxyXFxuQGdyb3VwKDEpIEBiaW5kaW5nKDApIHZhciBhbGJlZG9NYXA6IHRleHR1cmVfMmQ8ZjMyPjtcXHJcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMSkgdmFyIG1ldGFsbGljUm91Z2huZXNzTWFwOiB0ZXh0dXJlXzJkPGYzMj47XFxyXFxuQGdyb3VwKDEpIEBiaW5kaW5nKDIpIHZhciBub3JtYWxNYXA6IHRleHR1cmVfMmQ8ZjMyPjtcXHJcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IGVtaXNzaXZlRmFjdG9yOiB2ZWMzZjtcXHJcXG5AZ3JvdXAoMSkgQGJpbmRpbmcoNCkgdmFyIGVtaXNzaXZlTWFwOiB0ZXh0dXJlXzJkPGYzMj47XFxyXFxuQGdyb3VwKDEpIEBiaW5kaW5nKDUpIHZhciBvY2NsdXNpb25NYXA6IHRleHR1cmVfMmQ8ZjMyPjtcXHJcXG5AZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyIGlycmFkaWFuY2VNYXA6IHRleHR1cmVfY3ViZTxmMzI+O1xcclxcbkBncm91cCgzKSBAYmluZGluZygwKSB2YXIgc2FtcGxlcjJEOiBzYW1wbGVyO1xcclxcbkBncm91cCgzKSBAYmluZGluZygxKSB2YXIgc2FtcGxlckN1YmU6IHNhbXBsZXI7XFxyXFxuXFxyXFxuQHZlcnRleFxcclxcbmZuIHZzX21haW4odmVydERhdGE6IFZlcnRleElucHV0KSAtPiBWZXJ0ZXhPdXQge1xcclxcbiAgdmFyIG91dHB1dDogVmVydGV4T3V0O1xcclxcblxcclxcbiAgb3V0cHV0LnBvc2l0aW9uID0gdHJhbnNmb3JtLnByb2plY3Rpb24gKiB0cmFuc2Zvcm0udmlldyAqIHRyYW5zZm9ybS5tb2RlbCAqIHZlYzRmKHZlcnREYXRhLnBvc2l0aW9uLCAxLjApO1xcclxcbiAgb3V0cHV0LnRleENvb3JkID0gdmVydERhdGEudGV4Q29vcmQ7XFxyXFxuICBvdXRwdXQubm9ybWFsID0gKHRyYW5zZm9ybS5ub3JtYWwgKiB2ZWM0Zih2ZXJ0RGF0YS5ub3JtYWwsIDAuMCkpLnh5ejtcXHJcXG4gIG91dHB1dC5wb3MgPSAodHJhbnNmb3JtLm5vcm1hbCAqIHZlYzRmKHZlcnREYXRhLnBvc2l0aW9uLCAwLjApKS54eXo7XFxyXFxuXFxyXFxuICByZXR1cm4gb3V0cHV0O1xcclxcbn1cXHJcXG5cXHJcXG5jb25zdCBQSSA9IDMuMTQxNTkyNjUzNTk7XFxyXFxuXFxyXFxuLy8gRDogTm9ybWFsIERpc3RyaWJ1dGlvbiBGdW5jdGlvblxcclxcbmZuIFRyb3dicmlkZ2VSZWl0ekdHWChub3JtYWw6IHZlYzNmLCBoYWxmd2F5RGlyOiB2ZWMzZiwgcm91Z2huZXNzOiBmMzIpIC0+IGYzMiB7XFxyXFxuICBsZXQgYSA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcXHJcXG4gIGxldCBhMiA9IGEgKiBhO1xcclxcbiAgbGV0IE5kb3RIID0gbWF4KGRvdChub3JtYWwsIGhhbGZ3YXlEaXIpLCAwLjApO1xcclxcbiAgbGV0IE5kb3RIMiA9IE5kb3RIICogTmRvdEg7XFxyXFxuXFxyXFxuICBsZXQgbnVtZXJhdG9yID0gYTI7XFxyXFxuICB2YXIgZGVub21pbmF0b3IgPSAoTmRvdEgyICogKGEyIC0gMS4wKSArIDEuMCk7XFxyXFxuICBkZW5vbWluYXRvciA9IFBJICogZGVub21pbmF0b3IgKiBkZW5vbWluYXRvcjtcXHJcXG5cXHJcXG4gIHJldHVybiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjsgXFxyXFxufVxcclxcblxcclxcbi8vIEY6IEZyZXNuZWwgRXF1YXRpb25cXHJcXG5mbiBGcmVzbmVsU2NobGlja0FwcHJveGltYXRpb24oY29zVGhldGE6IGYzMiwgZjA6IHZlYzNmLCByb3VnaG5lc3M6IGYzMikgLT4gdmVjM2Yge1xcclxcbiAgcmV0dXJuIGYwICsgKG1heCh2ZWMzZigxLjAgLXJvdWdobmVzcyksIGYwKSAtIGYwKSAqIHBvdyhjbGFtcCgxLjAgLSBjb3NUaGV0YSwgMC4wLCAxLjApLCA1LjApO1xcclxcbn1cXHJcXG5cXHJcXG4vLyBHOiBHZW9tZXRyeSBGdW5jdGlvblxcclxcbmZuIEdlb21ldHJ5U21pdGgobm9ybWFsOiB2ZWMzZiwgdmlld0RpcjogdmVjM2YsIGxpZ2h0RGlyOiB2ZWMzZiwgcm91Z2huZXNzOiBmMzIpIC0+IGYzMiB7XFxyXFxuICBsZXQgTmRvdFYgPSBtYXgoZG90KG5vcm1hbCwgdmlld0RpciksIDAuMCk7XFxyXFxuICBsZXQgZ2d4MSA9IEdlb21ldHJ5U21pdGhHR1goTmRvdFYsIHJvdWdobmVzcyk7XFxyXFxuICBsZXQgTmRvdEwgPSBtYXgoZG90KG5vcm1hbCwgbGlnaHREaXIpLCAwLjApO1xcclxcbiAgbGV0IGdneDIgPSBHZW9tZXRyeVNtaXRoR0dYKE5kb3RMLCByb3VnaG5lc3MpO1xcclxcblxcclxcbiAgcmV0dXJuIGdneDEgKiBnZ3gyO1xcclxcbn1cXHJcXG5cXHJcXG5mbiBHZW9tZXRyeVNtaXRoR0dYKGNvc1RoZXRhOiBmMzIsIHJvdWdobmVzczogZjMyKSAtPiBmMzIge1xcclxcbiAgbGV0IHIgPSAocm91Z2huZXNzICsgMS4wKTtcXHJcXG4gIGxldCBrID0gKHIgKiByKSAvIDguMDtcXHJcXG5cXHJcXG4gIGxldCBudW1lcmF0b3IgPSBjb3NUaGV0YTtcXHJcXG4gIGxldCBkZW5vbWluYXRvciA9IChjb3NUaGV0YSAqICgxLjAgLSBrKSArIGspO1xcclxcblxcclxcbiAgcmV0dXJuIG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xcclxcbn1cXHJcXG5cXHJcXG4vLyBBQ0VTOiBBY2FkZW15IENvbG9yIEVuY29kaW5nIFN5c3RlbVxcclxcbmZuIFRvbmVNYXBBQ0VTKGhkcjogdmVjM2YpIC0+IHZlYzNmIHtcXHJcXG4gICAgbGV0IG0xID0gbWF0M3gzKFxcclxcbiAgICAgICAgMC41OTcxOSwgMC4wNzYwMCwgMC4wMjg0MCxcXHJcXG4gICAgICAgIDAuMzU0NTgsIDAuOTA4MzQsIDAuMTMzODMsXFxyXFxuICAgICAgICAwLjA0ODIzLCAwLjAxNTY2LCAwLjgzNzc3LFxcclxcbiAgICApO1xcclxcbiAgICBsZXQgbTIgPSBtYXQzeDMoXFxyXFxuICAgICAgICAxLjYwNDc1LCAtMC4xMDIwOCwgLTAuMDAzMjcsXFxyXFxuICAgICAgICAtMC41MzEwOCwgIDEuMTA4MTMsIC0wLjA3Mjc2LFxcclxcbiAgICAgICAgLTAuMDczNjcsIC0wLjAwNjA1LCAgMS4wNzYwMixcXHJcXG4gICAgKTtcXHJcXG4gICAgbGV0IHYgPSBtMSAqIGhkcjtcXHJcXG4gICAgbGV0IGEgPSB2ICogKHYgKyAwLjAyNDU3ODYpIC0gMC4wMDAwOTA1Mzc7XFxyXFxuICAgIGxldCBiID0gdiAqICgwLjk4MzcyOSAqIHYgKyAwLjQzMjk1MTApICsgMC4yMzgwODE7XFxyXFxuICAgIHJldHVybiBjbGFtcChtMiAqIChhIC8gYiksIHZlYzMoMC4wKSwgdmVjMygxLjApKTtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuQGZyYWdtZW50XFxyXFxuZm4gZnNfbWFpbihmcmFnRGF0YTogVmVydGV4T3V0KSAtPiBAbG9jYXRpb24oMCkgdmVjNGYge1xcclxcbiAgbGV0IGFsYmVkbyA9IHRleHR1cmVTYW1wbGUoYWxiZWRvTWFwLCBzYW1wbGVyMkQsIGZyYWdEYXRhLnRleENvb3JkKS5yZ2I7XFxyXFxuICB2YXIgbm9ybWFsID0gdGV4dHVyZVNhbXBsZShub3JtYWxNYXAsIHNhbXBsZXIyRCwgZnJhZ0RhdGEudGV4Q29vcmQpLnh5eiAqIDIuMCAtIDEuMDtcXHJcXG4gIGxldCBxMSA9IGRwZHgoZnJhZ0RhdGEucG9zKTtcXHJcXG4gIGxldCBxMiA9IGRwZHkoZnJhZ0RhdGEucG9zKTtcXHJcXG4gIGxldCBzdDEgPSBkcGR4KGZyYWdEYXRhLnRleENvb3JkKTtcXHJcXG4gIGxldCBzdDIgPSBkcGR5KGZyYWdEYXRhLnRleENvb3JkKTtcXHJcXG4gIGxldCBOID0gbm9ybWFsaXplKGZyYWdEYXRhLm5vcm1hbCk7XFxyXFxuICBsZXQgVCA9IG5vcm1hbGl6ZShxMSAqIHN0Mi55IC0gcTIgKiBzdDEueSk7XFxyXFxuICBsZXQgQiA9IC1ub3JtYWxpemUoY3Jvc3MoTiwgVCkpO1xcclxcbiAgbGV0IFRCTiA9IG1hdDN4M2YoVCwgQiwgTik7XFxyXFxuICBub3JtYWwgPSBub3JtYWxpemUoVEJOICogbm9ybWFsKTtcXHJcXG4gIGxldCBtZXRhbG5lc3MgPSB0ZXh0dXJlU2FtcGxlKG1ldGFsbGljUm91Z2huZXNzTWFwLCBzYW1wbGVyMkQsIGZyYWdEYXRhLnRleENvb3JkKS5iO1xcclxcbiAgbGV0IHJvdWdobmVzcyA9IHRleHR1cmVTYW1wbGUobWV0YWxsaWNSb3VnaG5lc3NNYXAsIHNhbXBsZXIyRCwgZnJhZ0RhdGEudGV4Q29vcmQpLmc7XFxyXFxuICBsZXQgZW1pc3NpdmUgPSB0ZXh0dXJlU2FtcGxlKGVtaXNzaXZlTWFwLCBzYW1wbGVyMkQsIGZyYWdEYXRhLnRleENvb3JkKS5yZ2IgKiBlbWlzc2l2ZUZhY3RvcjtcXHJcXG4gIGxldCBvY2NsdXNpb24gPSB0ZXh0dXJlU2FtcGxlKG9jY2x1c2lvbk1hcCwgc2FtcGxlcjJELCBmcmFnRGF0YS50ZXhDb29yZCkucjtcXHJcXG5cXHJcXG4gIGxldCB2aWV3RGlyID0gbm9ybWFsaXplKHZpZXdQb3MgLSBmcmFnRGF0YS5wb3MpO1xcclxcbiAgdmFyIGYwID0gdmVjM2YoMC4wNCk7XFxyXFxuICBmMCA9IG1peChmMCwgYWxiZWRvLCBtZXRhbG5lc3MpO1xcclxcblxcclxcbiAgLy8gcmVsZmxlY3RhbmNlIGVxdWF0aW9uXFxyXFxuICB2YXIgTG8gPSB2ZWMzZigwLjApO1xcclxcblxcclxcbiAgZm9yKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xcclxcbiAgICBsZXQgbGlnaHREaXIgPSBub3JtYWxpemUobGlnaHRQb3NpdGlvbnNbaV0gLSBmcmFnRGF0YS5wb3MpO1xcclxcbiAgICBsZXQgaGFsZndheURpciA9IG5vcm1hbGl6ZSh2aWV3RGlyICsgbGlnaHREaXIpO1xcclxcbiAgICBsZXQgZGlzdGFuY2UgPSBsZW5ndGgobGlnaHRQb3NpdGlvbnNbaV0gLSBmcmFnRGF0YS5wb3MpO1xcclxcbiAgICBsZXQgYXR0ZW51YXRpb24gPSAxLjAgLyBwb3coZGlzdGFuY2UsIDIuMCk7XFxyXFxuICAgIGxldCByYWRpYW5jZSA9IGxpZ2h0Q29sb3JzW2ldICogYXR0ZW51YXRpb247XFxyXFxuXFxyXFxuICAgIC8vIEJSREY6IENvb2stVG9ycmFuY2VcXHJcXG4gICAgbGV0IEQgPSBUcm93YnJpZGdlUmVpdHpHR1gobm9ybWFsLCBoYWxmd2F5RGlyLCByb3VnaG5lc3MpO1xcclxcbiAgICBsZXQgRiA9IEZyZXNuZWxTY2hsaWNrQXBwcm94aW1hdGlvbihtYXgoZG90KGhhbGZ3YXlEaXIsIHZpZXdEaXIpLCAwLjApLCBmMCwgcm91Z2huZXNzKTtcXHJcXG4gICAgbGV0IEcgPSBHZW9tZXRyeVNtaXRoKG5vcm1hbCwgdmlld0RpciwgbGlnaHREaXIsIHJvdWdobmVzcyk7XFxyXFxuXFxyXFxuICAgIGxldCBrUyA9IEY7XFxyXFxuICAgIHZhciBrRCA9IHZlYzNmKDEuMCkgLSBrUztcXHJcXG4gICAga0QgKj0gMS4wIC0gbWV0YWxuZXNzO1xcclxcblxcclxcbiAgICBsZXQgbnVtZXJhdG9yID0gRCAqIEYgKiBHO1xcclxcbiAgICBsZXQgZGVub21pbmF0b3IgPSA0LjAgKiBtYXgoZG90KG5vcm1hbCwgdmlld0RpciksIDAuMCkgKiBtYXgoZG90KG5vcm1hbCwgbGlnaHREaXIpLCAwLjApICsgMC4wMDE7XFxyXFxuICAgIGxldCBzcGVjdWxhciA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xcclxcblxcclxcbiAgICBMbyArPSAoa0QgKiBhbGJlZG8gLyBQSSArIHNwZWN1bGFyKSAqIHJhZGlhbmNlICogZG90KG5vcm1hbCwgbGlnaHREaXIpO1xcclxcbiAgfVxcclxcblxcclxcbiAgbGV0IGtTID0gRnJlc25lbFNjaGxpY2tBcHByb3hpbWF0aW9uKG1heChkb3Qobm9ybWFsLCB2aWV3RGlyKSwgMC4wKSwgZjAsIHJvdWdobmVzcyk7XFxyXFxuICB2YXIga0QgPSB2ZWMzZigxLjApIC0ga1M7XFxyXFxuICBrRCAqPSAxLjAgLSBtZXRhbG5lc3M7XFxyXFxuICBsZXQgaXJyYWRpYW5jZSA9IHRleHR1cmVTYW1wbGUoaXJyYWRpYW5jZU1hcCwgc2FtcGxlckN1YmUsIG5vcm1hbCkucmdiO1xcclxcbiAgbGV0IGRpZmZ1c2UgID0gaXJyYWRpYW5jZSAqIGFsYmVkbztcXHJcXG4gIGxldCBhbWJpZW50ID0oIGtEICogZGlmZnVzZSkgKiBvY2NsdXNpb247XFxyXFxuXFxyXFxuICB2YXIgY29sb3IgPSB2ZWMzZigwLjAzKSAqIG9jY2x1c2lvbiArIExvICsgZW1pc3NpdmU7XFxyXFxuICAvLyBIRFIgVG9uZSBNYXBwaW5nXFxyXFxuICBjb2xvciA9IFRvbmVNYXBBQ0VTKGNvbG9yKTtcXHJcXG4gIC8vIEdhbW1hIENvcnJlY3Rpb25cXHJcXG4gIGNvbG9yID0gcG93KGNvbG9yLCB2ZWMzZigxLjAgLyAyLjIpKTtcXHJcXG5cXHJcXG4gIHJldHVybiB2ZWM0Zihjb2xvciwgMS4wKTtcXHJcXG59XFxyXFxuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCJzdHJ1Y3QgVmVydGV4T3V0IHtcXHJcXG4gIEBidWlsdGluKHBvc2l0aW9uKSBwb3NpdGlvbiA6IHZlYzRmLFxcclxcbiAgQGxvY2F0aW9uKDApIHBvczogdmVjNGYsXFxyXFxufTtcXHJcXG5cXHJcXG5cXHJcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IG1hdHJpeDogbWF0NHg0ZjtcXHJcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyIGN1YmVTYW1wbGVyOiBzYW1wbGVyO1xcclxcbkBncm91cCgxKSBAYmluZGluZygwKSB2YXIgY3ViZVRleHR1cmU6IHRleHR1cmVfY3ViZTxmMzI+O1xcclxcblxcclxcblxcclxcbkB2ZXJ0ZXhcXHJcXG5mbiB2c19tYWluKEBidWlsdGluKHZlcnRleF9pbmRleCkgIHZlcnRleEluZGV4OiB1MzIpIC0+IFZlcnRleE91dCB7XFxyXFxuICBsZXQgcG9zaXRpb25zID0gYXJyYXkodmVjMmYoLTEsIDMpLCB2ZWMyZigtMSwtMSksIHZlYzJmKDMsIC0xKSk7XFxyXFxuXFxyXFxuICB2YXIgb3V0cHV0OiBWZXJ0ZXhPdXQ7XFxyXFxuXFxyXFxuICBvdXRwdXQucG9zaXRpb24gPSB2ZWM0Zihwb3NpdGlvbnNbdmVydGV4SW5kZXhdLCAxLjAsIDEuMCk7XFxyXFxuICBvdXRwdXQucG9zID0gb3V0cHV0LnBvc2l0aW9uO1xcclxcblxcclxcbiAgcmV0dXJuIG91dHB1dDtcXHJcXG59XFxyXFxuXFxyXFxuLy8gQUNFUzogQWNhZGVteSBDb2xvciBFbmNvZGluZyBTeXN0ZW1cXHJcXG5mbiBUb25lTWFwQUNFUyhoZHI6IHZlYzNmKSAtPiB2ZWMzZiB7XFxyXFxuICAgIGxldCBtMSA9IG1hdDN4MyhcXHJcXG4gICAgICAgIDAuNTk3MTksIDAuMDc2MDAsIDAuMDI4NDAsXFxyXFxuICAgICAgICAwLjM1NDU4LCAwLjkwODM0LCAwLjEzMzgzLFxcclxcbiAgICAgICAgMC4wNDgyMywgMC4wMTU2NiwgMC44Mzc3NyxcXHJcXG4gICAgKTtcXHJcXG4gICAgbGV0IG0yID0gbWF0M3gzKFxcclxcbiAgICAgICAgMS42MDQ3NSwgLTAuMTAyMDgsIC0wLjAwMzI3LFxcclxcbiAgICAgICAgLTAuNTMxMDgsICAxLjEwODEzLCAtMC4wNzI3NixcXHJcXG4gICAgICAgIC0wLjA3MzY3LCAtMC4wMDYwNSwgIDEuMDc2MDIsXFxyXFxuICAgICk7XFxyXFxuICAgIGxldCB2ID0gbTEgKiBoZHI7XFxyXFxuICAgIGxldCBhID0gdiAqICh2ICsgMC4wMjQ1Nzg2KSAtIDAuMDAwMDkwNTM3O1xcclxcbiAgICBsZXQgYiA9IHYgKiAoMC45ODM3MjkgKiB2ICsgMC40MzI5NTEwKSArIDAuMjM4MDgxO1xcclxcbiAgICByZXR1cm4gY2xhbXAobTIgKiAoYSAvIGIpLCB2ZWMzKDAuMCksIHZlYzMoMS4wKSk7XFxyXFxufVxcclxcblxcclxcbkBmcmFnbWVudFxcclxcbmZuIGZzX21haW4oZnJhZ0RhdGE6IFZlcnRleE91dCkgLT4gQGxvY2F0aW9uKDApIHZlYzRmIHtcXHJcXG4gIGxldCB0ZXhDb29yZCA9IG1hdHJpeCAqIGZyYWdEYXRhLnBvcztcXHJcXG4gIC8vIFdlYkdQVSB1c2VzIGEgcmlnaHQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtLCBidXQgY3ViZW1hcHMgYXJlIGFuIGV4Y2VwdGlvbiwgdXNpbmcgYSBsZWZ0LWhhbmRlZCBjb29yZGluYXRlIHN5c3RlbVxcclxcbiAgdmFyIGNvbG9yID0gdGV4dHVyZVNhbXBsZShjdWJlVGV4dHVyZSwgY3ViZVNhbXBsZXIsIG5vcm1hbGl6ZSh0ZXhDb29yZC54eXogLyB0ZXhDb29yZC53KSAqIHZlYzNmKDEsIDEsIC0xKSkucmdiO1xcclxcbiAgLy8gSERSIFRvbmUgTWFwcGluZ1xcclxcbiAgY29sb3IgPSBUb25lTWFwQUNFUyhjb2xvcik7XFxyXFxuICAvLyBHYW1tYSBDb3JyZWN0aW9uXFxyXFxuICBjb2xvciA9IHBvdyhjb2xvciwgdmVjM2YoMS4wLzIuMikpO1xcclxcblxcclxcbiAgcmV0dXJuIHZlYzRmKGNvbG9yLCAxLjApO1xcclxcbn1cXHJcXG5cIjsiLCJpbXBvcnQgeyBtYXQ0LCBNYXQ0LCBxdWF0LCBRdWF0LCB1dGlscywgdmVjMywgVmVjMyB9IGZyb20gXCJ3Z3B1LW1hdHJpeFwiO1xyXG5cclxuZW51bSBNb3ZlTW9kZSB7XHJcbiAgTk9ORSA9IFwiTm9uZVwiLFxyXG4gIFRVTUJMRSA9IFwiVHVtYmxlXCIsXHJcbiAgVFJBQ0sgPSBcIlRyYWNrXCIsXHJcbiAgRE9MTFkgPSBcIkRvbGx5XCIsXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSB7XHJcbiAgcHJpdmF0ZSBjb250cm9sbGVkOiBib29sZWFuO1xyXG4gIHByaXZhdGUgbW92ZU1vZGU6IE1vdmVNb2RlO1xyXG4gIHByaXZhdGUgeDogbnVtYmVyO1xyXG4gIHByaXZhdGUgeTogbnVtYmVyO1xyXG4gIHByaXZhdGUgcm90YXRlQW1wbGl0dWRlOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBwYW5BbXBsaXR1ZGU6IG51bWJlcjtcclxuICBwcml2YXRlIHNjcm9sbEFtcGxpdHVkZTogbnVtYmVyO1xyXG4gIHByaXZhdGUgcGl0Y2g6IG51bWJlcjtcclxuICBwcml2YXRlIHlhdzogbnVtYmVyO1xyXG4gIHByaXZhdGUgZGlzdGFuY2U6IG51bWJlcjtcclxuICBwcml2YXRlIHRhcmdldDogVmVjMztcclxuICBwcml2YXRlIGV5ZTogVmVjMztcclxuICBwcml2YXRlIHVwOiBWZWMzO1xyXG4gIHByaXZhdGUgcmlnaHQ6IFZlYzM7XHJcblxyXG4gIHByaXZhdGUgZGl2OiBIVE1MRGl2RWxlbWVudDtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5jb250cm9sbGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLm1vdmVNb2RlID0gTW92ZU1vZGUuTk9ORTtcclxuICAgIHRoaXMucm90YXRlQW1wbGl0dWRlID0gMC4xO1xyXG4gICAgdGhpcy5wYW5BbXBsaXR1ZGUgPSAwLjAxO1xyXG4gICAgdGhpcy5zY3JvbGxBbXBsaXR1ZGUgPSAwLjAxO1xyXG4gICAgdGhpcy54ID0gMDtcclxuICAgIHRoaXMueSA9IDA7XHJcbiAgICB0aGlzLnBpdGNoID0gMC4wO1xyXG4gICAgdGhpcy55YXcgPSAwLjA7XHJcbiAgICB0aGlzLmRpc3RhbmNlID0gNS4wO1xyXG4gICAgdGhpcy50YXJnZXQgPSB2ZWMzLmNyZWF0ZSgwLjAsIDAuMCwgMC4wKTtcclxuICAgIHRoaXMuZXllID0gdmVjMy5jcmVhdGUoMC4wLCAwLjAsIDUuMCk7XHJcbiAgICB0aGlzLnVwID0gdmVjMy5jcmVhdGUoMC4wLCAxLjAsIDAuMCk7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdmVjMy5jcmVhdGUoMS4wLCAwLjAsIDAuMCk7XHJcblxyXG4gICAgdGhpcy5vbktleURvd24gPSB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbktleVVwID0gdGhpcy5vbktleVVwLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbk1vdXNlVXAgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmNvbnRyb2xsZWQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25LZXlEb3duKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLm9uS2V5VXApO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Nb3VzZVVwKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5vbk1vdXNlTW92ZSk7XHJcblxyXG4gICAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFxyXG4gICAgICBcInN0eWxlXCIsXHJcbiAgICAgIFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IDEwcHg7IGxlZnQ6IDEwcHg7IHdpZHRoOiAyMDBweDsgY29sb3I6IHdoaXRlOyBmb250LXNpemU6IDE2cHg7IGZvbnQtd2VpZ2h0OiBib2xkO1wiXHJcbiAgICApO1xyXG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJib2R5XCIpO1xyXG4gICAgaWYgKGJvZHkpIHtcclxuICAgICAgYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRpdik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHZpZXcoKTogTWF0NCB7XHJcbiAgICByZXR1cm4gbWF0NC5sb29rQXQodGhpcy5leWUsIHRoaXMudGFyZ2V0LCB0aGlzLnVwKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgcG9zaXRpb24oKTogVmVjMyB7XHJcbiAgICByZXR1cm4gdGhpcy5leWU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgc3dpdGNoIChldmVudC5rZXkpIHtcclxuICAgICAgY2FzZSBcIkFsdFwiOlxyXG4gICAgICAgIHRoaXMuY29udHJvbGxlZCA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uS2V5VXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XHJcbiAgICAgIGNhc2UgXCJBbHRcIjpcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRpdi5pbm5lclRleHQgPSBcIlwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBvbk1vdXNlRG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMueCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICB0aGlzLnkgPSBldmVudC5jbGllbnRZO1xyXG5cclxuICAgIHN3aXRjaCAoZXZlbnQuYnV0dG9uKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICB0aGlzLm1vdmVNb2RlID0gTW92ZU1vZGUuVFVNQkxFO1xyXG4gICAgICAgIHRoaXMuZGl2LmlubmVyVGV4dCA9IGBUdW1ibGU6IEFsdCArIExNQmA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICB0aGlzLm1vdmVNb2RlID0gTW92ZU1vZGUuVFJBQ0s7XHJcbiAgICAgICAgdGhpcy5kaXYuaW5uZXJUZXh0ID0gYFRyYWNrOiBBbHQgKyBNTUJgO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgdGhpcy5tb3ZlTW9kZSA9IE1vdmVNb2RlLkRPTExZO1xyXG4gICAgICAgIHRoaXMuZGl2LmlubmVyVGV4dCA9IGBEb2xseTogQWx0ICsgUk1CYDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aGlzLm1vdmVNb2RlID0gTW92ZU1vZGUuTk9ORTtcclxuICAgICAgICB0aGlzLmRpdi5pbm5lclRleHQgPSBcIlwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBvbk1vdXNlVXAoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuY29udHJvbGxlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tb3ZlTW9kZSA9IE1vdmVNb2RlLk5PTkU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uTW91c2VNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuY29udHJvbGxlZCB8fCBNb3ZlTW9kZS5OT05FID09PSB0aGlzLm1vdmVNb2RlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy54O1xyXG4gICAgdGhpcy54ID0gZXZlbnQuY2xpZW50WDtcclxuXHJcbiAgICBjb25zdCBkZWx0YVkgPSBldmVudC5jbGllbnRZIC0gdGhpcy55O1xyXG4gICAgdGhpcy55ID0gZXZlbnQuY2xpZW50WTtcclxuXHJcbiAgICBzd2l0Y2ggKHRoaXMubW92ZU1vZGUpIHtcclxuICAgICAgY2FzZSBNb3ZlTW9kZS5UVU1CTEU6XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYW1lcmFSb3RhdGlvbihkZWx0YVgsIGRlbHRhWSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgTW92ZU1vZGUuRE9MTFk6XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYW1lcmFEaXN0YW5jZShkZWx0YVgsIGRlbHRhWSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgTW92ZU1vZGUuVFJBQ0s6XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYW1lcmFUYXJnZXQoZGVsdGFYLCBkZWx0YVkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVDYW1lcmFSb3RhdGlvbihkZWx0YVg6IG51bWJlciwgZGVsdGFZOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHRoaXMudGFyZ2V0ID0gdmVjMy5jcmVhdGUoMC4wLCAwLjAsIDAuMCk7XHJcblxyXG4gICAgdGhpcy55YXcgPSAtZGVsdGFYICogdGhpcy5yb3RhdGVBbXBsaXR1ZGU7XHJcbiAgICB0aGlzLnBpdGNoID0gLWRlbHRhWSAqIHRoaXMucm90YXRlQW1wbGl0dWRlO1xyXG5cclxuICAgIGNvbnN0IHF1YXRZYXcgPSBxdWF0LmZyb21BeGlzQW5nbGUodGhpcy51cCwgdXRpbHMuZGVnVG9SYWQodGhpcy55YXcpKTtcclxuXHJcbiAgICBjb25zdCBiYWNrID0gdmVjMy5ub3JtYWxpemUodmVjMy5zdWIodGhpcy5leWUsIHRoaXMudGFyZ2V0KSk7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdmVjMy50cmFuc2Zvcm1RdWF0KHZlYzMuY3Jvc3ModGhpcy51cCwgYmFjayksIHF1YXRZYXcpO1xyXG4gICAgY29uc3QgcXVhdFBpdGNoID0gcXVhdC5mcm9tQXhpc0FuZ2xlKFxyXG4gICAgICB0aGlzLnJpZ2h0LFxyXG4gICAgICB1dGlscy5kZWdUb1JhZCh0aGlzLnBpdGNoKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCByb3RhdGlvbiA9IHF1YXQubXVsKHF1YXRZYXcsIHF1YXRQaXRjaCk7XHJcblxyXG4gICAgY29uc3QgbmV3QmFjayA9IHZlYzMudHJhbnNmb3JtUXVhdChiYWNrLCByb3RhdGlvbik7XHJcbiAgICB0aGlzLnVwID0gdmVjMy5ub3JtYWxpemUodmVjMy5jcm9zcyhuZXdCYWNrLCB0aGlzLnJpZ2h0KSk7XHJcbiAgICB0aGlzLmV5ZSA9IHZlYzMuYWRkKHRoaXMudGFyZ2V0LCB2ZWMzLm11bFNjYWxhcihuZXdCYWNrLCB0aGlzLmRpc3RhbmNlKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZUNhbWVyYURpc3RhbmNlKGRlbHRhWDogbnVtYmVyLCBkZWx0YVk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5kaXN0YW5jZSAtPSAoZGVsdGFYICsgZGVsdGFZKSAqIHRoaXMuc2Nyb2xsQW1wbGl0dWRlO1xyXG4gICAgY29uc3QgYmFjayA9IHZlYzMubm9ybWFsaXplKHZlYzMuc3ViKHRoaXMuZXllLCB0aGlzLnRhcmdldCkpO1xyXG4gICAgdGhpcy5leWUgPSB2ZWMzLmFkZCh0aGlzLnRhcmdldCwgdmVjMy5tdWxTY2FsYXIoYmFjaywgdGhpcy5kaXN0YW5jZSkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVDYW1lcmFUYXJnZXQoZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyKSB7XHJcbiAgICBsZXQgcGFuT2Zmc2V0ID0gdmVjMy5jcmVhdGUoMC4wLCAwLjAsIDAuMCk7XHJcbiAgICBwYW5PZmZzZXQgPSB2ZWMzLmFkZFNjYWxlZChcclxuICAgICAgcGFuT2Zmc2V0LFxyXG4gICAgICB0aGlzLnJpZ2h0LFxyXG4gICAgICAtZGVsdGFYICogdGhpcy5wYW5BbXBsaXR1ZGVcclxuICAgICk7XHJcbiAgICBwYW5PZmZzZXQgPSB2ZWMzLmFkZFNjYWxlZChwYW5PZmZzZXQsIHRoaXMudXAsIGRlbHRhWSAqIHRoaXMucGFuQW1wbGl0dWRlKTtcclxuXHJcbiAgICB0aGlzLnRhcmdldCA9IHZlYzMuYWRkKHRoaXMudGFyZ2V0LCBwYW5PZmZzZXQpO1xyXG4gICAgdGhpcy5leWUgPSB2ZWMzLmFkZCh0aGlzLmV5ZSwgcGFuT2Zmc2V0KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHR5cGUge1xyXG4gIGdsVEYsXHJcbiAgZ2xURkJ1ZmZlcixcclxuICBnbFRGTWVzaCxcclxuICBnbFRGTm9kZSxcclxuICBnbFRGUHJpbWl0aXZlLFxyXG59IGZyb20gXCJAL3R5cGVzL2dsVEZcIjtcclxuaW1wb3J0IHsgY2FsY3VsYXRlQnl0ZUxlbmd0aCB9IGZyb20gXCIuL3V0aWxzXCI7XHJcbmltcG9ydCB7IG1hdDQsIHF1YXQsIHZlYzMsIHR5cGUgTWF0NCB9IGZyb20gXCJ3Z3B1LW1hdHJpeFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IENvbXBvbmVudFR5cGUgPSB7XHJcbiAgNTEyMDogXCJzaW50OFwiLFxyXG4gIDUxMjE6IFwidWludDhcIixcclxuICA1MTIyOiBcInNpbnQxNlwiLFxyXG4gIDUxMjM6IFwidWludDE2XCIsXHJcbiAgNTEyNTogXCJ1aW50MzJcIixcclxuICA1MTI2OiBcImZsb2F0MzJcIixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBDb21wb25lbnRDb3VudCA9IHtcclxuICBTQ0FMQVI6IFwiXCIsXHJcbiAgVkVDMjogXCJ4MlwiLFxyXG4gIFZFQzM6IFwieDNcIixcclxuICBWRUM0OiBcIng0XCIsXHJcbiAgTUFUMjogXCJ4OFwiLFxyXG4gIE1BVDM6IFwieDEyXCIsXHJcbiAgTUFUNDogXCJ4MTZcIixcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIExheW91dCA9IHtcclxuICBmb3JtYXQ6IEdQVVZlcnRleEZvcm1hdDtcclxuICBvZmZzZXQ6IG51bWJlcjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIEdlb21ldHJ5ID0ge1xyXG4gIG1vZGVsOiBNYXQ0O1xyXG4gIHZlcnRpY2VzOiBGbG9hdDMyQXJyYXk7XHJcbiAgYXJyYXlTdHJpZGU6IG51bWJlcjtcclxuICBwb3NpdGlvbjogTGF5b3V0O1xyXG4gIG5vcm1hbDogTGF5b3V0O1xyXG4gIHRleENvb3JkOiBMYXlvdXQ7XHJcbiAgaW5kaWNlczogVWludDE2QXJyYXk7XHJcbiAgdGV4dHVyZXM6IHtcclxuICAgIGJhc2VDb2xvclVSSTogc3RyaW5nO1xyXG4gICAgbWV0YWxsaWNSb3VnaG5lc3NVUkk6IHN0cmluZztcclxuICAgIG5vcm1hbFVSSTogc3RyaW5nO1xyXG4gICAgZW1pc3NpdmU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICAgIGVtaXNzaXZlVVJJOiBzdHJpbmc7XHJcbiAgICBvY2NsdXNpb25VUkk6IHN0cmluZztcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZ2xURkxvYWRlciB7XHJcbiAgcHJpdmF0ZSBwYXRobmFtZTogc3RyaW5nO1xyXG5cclxuICBwcml2YXRlIGdsdGY6IGdsVEY7XHJcbiAgcHJpdmF0ZSBidWZmZXJzOiBBcnJheUJ1ZmZlcltdO1xyXG4gIHByaXZhdGUgZ2VvbWV0cmllczogR2VvbWV0cnlbXTtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5sb2FkQmluQnVmZmVyID0gdGhpcy5sb2FkQmluQnVmZmVyLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgbG9hZCh1cmw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgaW5kZXggPSB1cmwubGFzdEluZGV4T2YoXCIvXCIpO1xyXG4gICAgdGhpcy5wYXRobmFtZSA9IHVybC5zbGljZSgwLCBpbmRleCArIDEpO1xyXG5cclxuICAgIGF3YWl0IHRoaXMubG9hZEpTT04odXJsKTtcclxuICAgIGF3YWl0IHRoaXMubG9hZEJpbkJ1ZmZlcnMoKTtcclxuICAgIHRoaXMuZ2VuZXJhdGVHZW9tZXRyaWVzKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0R2VvbWV0cmllcygpIHtcclxuICAgIHJldHVybiB0aGlzLmdlb21ldHJpZXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGxvYWRKU09OKHVybDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwpO1xyXG4gICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggLmdsdGYgZmlsZTogJHt1cmx9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5nbHRmID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgIGlmIChcIjIuMFwiICE9PSB0aGlzLmdsdGYuYXNzZXQudmVyc2lvbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGdsVEYgdmVyc2lvbjogJHt0aGlzLmdsdGYuYXNzZXQudmVyc2lvbn1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbG9hZEJpbkJ1ZmZlcnMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmJ1ZmZlcnMgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmdsdGYuYnVmZmVycy5tYXAodGhpcy5sb2FkQmluQnVmZmVyKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGxvYWRCaW5CdWZmZXIoYnVmZmVyOiBnbFRGQnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godGhpcy5wYXRobmFtZSArIGJ1ZmZlci51cmkpO1xyXG4gICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggLmJpbiBmaWxlOiAke2J1ZmZlci51cml9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcclxuICAgIGlmIChhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoICE9PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBidWZmZXIgYnl0ZSBsZW5ndGguXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVHZW9tZXRyaWVzKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdsdGYubm9kZXM7XHJcbiAgICB0aGlzLmdlb21ldHJpZXMgPSBuZXcgQXJyYXk8R2VvbWV0cnk+KG5vZGVzLmxlbmd0aCk7XHJcblxyXG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZTogZ2xURk5vZGUsIGluZGV4OiBudW1iZXIpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IG1vZGVsOiBNYXQ0O1xyXG4gICAgICBpZiAoXCJtYXRyaXhcIiBpbiBub2RlKSB7XHJcbiAgICAgICAgbW9kZWwgPSBtYXQ0LmNyZWF0ZSguLi5ub2RlLm1hdHJpeCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbW9kZWwgPSBtYXQ0LmlkZW50aXR5KCk7XHJcblxyXG4gICAgICAgIGlmIChcInNjYWxlXCIgaW4gbm9kZSkge1xyXG4gICAgICAgICAgbW9kZWwgPSBtYXQ0LnNjYWxlKG1vZGVsLCB2ZWMzLmNyZWF0ZSguLi5ub2RlLnNjYWxlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXCJ0cmFuc2xhdGlvblwiIGluIG5vZGUpIHtcclxuICAgICAgICAgIG1vZGVsID0gbWF0NC50cmFuc2xhdGUobW9kZWwsIHZlYzMuY3JlYXRlKC4uLm5vZGUudHJhbnNsYXRpb24pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcInJvdGF0aW9uXCIgaW4gbm9kZSkge1xyXG4gICAgICAgICAgY29uc3QgcSA9IHF1YXQuZnJvbVZhbHVlcyguLi5ub2RlLnJvdGF0aW9uKTtcclxuICAgICAgICAgIG1vZGVsID0gbWF0NC5tdWwobW9kZWwsIG1hdDQuZnJvbVF1YXQocSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbWVzaCA9IHRoaXMuZ2x0Zi5tZXNoZXNbbm9kZS5tZXNoXTtcclxuICAgICAgbWVzaC5wcmltaXRpdmVzLm1hcCgocHJpbWl0aXZlOiBnbFRGUHJpbWl0aXZlKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKFwibW9kZVwiIGluIHByaW1pdGl2ZSAmJiA0ICE9PSBwcmltaXRpdmUubW9kZSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcG9zaXRpb25zXHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25BY2Nlc3NvciA9XHJcbiAgICAgICAgICB0aGlzLmdsdGYuYWNjZXNzb3JzW3ByaW1pdGl2ZS5hdHRyaWJ1dGVzLlBPU0lUSU9OXTtcclxuICAgICAgICBjb25zdCBwb3NpdGlvblR5cGUgPSAoQ29tcG9uZW50VHlwZVtwb3NpdGlvbkFjY2Vzc29yLmNvbXBvbmVudFR5cGVdICtcclxuICAgICAgICAgIENvbXBvbmVudENvdW50W3Bvc2l0aW9uQWNjZXNzb3IudHlwZV0pIGFzIEdQVVZlcnRleEZvcm1hdDtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbk9mZnNldCA9IGNhbGN1bGF0ZUJ5dGVMZW5ndGgoKTtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlcnZpZXcgPVxyXG4gICAgICAgICAgdGhpcy5nbHRmLmJ1ZmZlclZpZXdzW3Bvc2l0aW9uQWNjZXNzb3IuYnVmZmVyVmlld107XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KFxyXG4gICAgICAgICAgdGhpcy5idWZmZXJzW3Bvc2l0aW9uQnVmZmVydmlldy5idWZmZXJdLFxyXG4gICAgICAgICAgcG9zaXRpb25CdWZmZXJ2aWV3LmJ5dGVPZmZzZXQsXHJcbiAgICAgICAgICBwb3NpdGlvbkJ1ZmZlcnZpZXcuYnl0ZUxlbmd0aCAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIHRleHR1cmUgY29vcmRpbmF0ZXNcclxuICAgICAgICBjb25zdCB0ZXhDb29yZEFjY2Vzc29yID1cclxuICAgICAgICAgIHRoaXMuZ2x0Zi5hY2Nlc3NvcnNbcHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEVYQ09PUkRfMF07XHJcbiAgICAgICAgY29uc3QgdGV4Q29vcmRUeXBlID0gKENvbXBvbmVudFR5cGVbdGV4Q29vcmRBY2Nlc3Nvci5jb21wb25lbnRUeXBlXSArXHJcbiAgICAgICAgICBDb21wb25lbnRDb3VudFt0ZXhDb29yZEFjY2Vzc29yLnR5cGVdKSBhcyBHUFVWZXJ0ZXhGb3JtYXQ7XHJcbiAgICAgICAgY29uc3QgdGV4Q29vcmRPZmZzZXQgPSBjYWxjdWxhdGVCeXRlTGVuZ3RoKHBvc2l0aW9uVHlwZSk7XHJcbiAgICAgICAgY29uc3QgdGV4Q29vcmRCdWZmZXJ2aWV3ID1cclxuICAgICAgICAgIHRoaXMuZ2x0Zi5idWZmZXJWaWV3c1t0ZXhDb29yZEFjY2Vzc29yLmJ1ZmZlclZpZXddO1xyXG4gICAgICAgIGNvbnN0IHRleENvb3JkbEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoXHJcbiAgICAgICAgICB0aGlzLmJ1ZmZlcnNbdGV4Q29vcmRCdWZmZXJ2aWV3LmJ1ZmZlcl0sXHJcbiAgICAgICAgICB0ZXhDb29yZEJ1ZmZlcnZpZXcuYnl0ZU9mZnNldCxcclxuICAgICAgICAgIHRleENvb3JkQnVmZmVydmlldy5ieXRlTGVuZ3RoIC8gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gbm9ybWFsc1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbEFjY2Vzc29yID0gdGhpcy5nbHRmLmFjY2Vzc29yc1twcmltaXRpdmUuYXR0cmlidXRlcy5OT1JNQUxdO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbFR5cGUgPSAoQ29tcG9uZW50VHlwZVtub3JtYWxBY2Nlc3Nvci5jb21wb25lbnRUeXBlXSArXHJcbiAgICAgICAgICBDb21wb25lbnRDb3VudFtub3JtYWxBY2Nlc3Nvci50eXBlXSkgYXMgR1BVVmVydGV4Rm9ybWF0O1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbE9mZnNldCA9XHJcbiAgICAgICAgICBjYWxjdWxhdGVCeXRlTGVuZ3RoKHBvc2l0aW9uVHlwZSkgKyBjYWxjdWxhdGVCeXRlTGVuZ3RoKHRleENvb3JkVHlwZSk7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsQnVmZmVydmlldyA9XHJcbiAgICAgICAgICB0aGlzLmdsdGYuYnVmZmVyVmlld3Nbbm9ybWFsQWNjZXNzb3IuYnVmZmVyVmlld107XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsQnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgICAgIHRoaXMuYnVmZmVyc1tub3JtYWxCdWZmZXJ2aWV3LmJ1ZmZlcl0sXHJcbiAgICAgICAgICBub3JtYWxCdWZmZXJ2aWV3LmJ5dGVPZmZzZXQsXHJcbiAgICAgICAgICBub3JtYWxCdWZmZXJ2aWV3LmJ5dGVMZW5ndGggLyBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBhcnJheVN0cmlkZSA9XHJcbiAgICAgICAgICBjYWxjdWxhdGVCeXRlTGVuZ3RoKHBvc2l0aW9uVHlwZSkgK1xyXG4gICAgICAgICAgY2FsY3VsYXRlQnl0ZUxlbmd0aCh0ZXhDb29yZFR5cGUpICtcclxuICAgICAgICAgIGNhbGN1bGF0ZUJ5dGVMZW5ndGgobm9ybWFsVHlwZSk7XHJcblxyXG4gICAgICAgIC8vIHZlcnRpY2VzIGFycmF5XHJcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFxyXG4gICAgICAgICAgKHBvc2l0aW9uQWNjZXNzb3IuY291bnQgKiBhcnJheVN0cmlkZSkgL1xyXG4gICAgICAgICAgICBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlRcclxuICAgICAgICApO1xyXG4gICAgICAgIGxldCBwT2Zmc2V0ID0gMDtcclxuICAgICAgICBsZXQgbk9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IHRPZmZzZXQgPSAwO1xyXG4gICAgICAgIGxldCBzdHJpZGUgPSA4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25BY2Nlc3Nvci5jb3VudDsgKytpKSB7XHJcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IFtcclxuICAgICAgICAgICAgcG9zaXRpb25CdWZmZXJbcE9mZnNldCsrXSxcclxuICAgICAgICAgICAgcG9zaXRpb25CdWZmZXJbcE9mZnNldCsrXSxcclxuICAgICAgICAgICAgcG9zaXRpb25CdWZmZXJbcE9mZnNldCsrXSxcclxuICAgICAgICAgIF07XHJcbiAgICAgICAgICB2ZXJ0aWNlcy5zZXQocG9zaXRpb24sIHN0cmlkZSAqIGkpO1xyXG5cclxuICAgICAgICAgIGNvbnN0IHRleENvb3JkID0gW1xyXG4gICAgICAgICAgICB0ZXhDb29yZGxCdWZmZXJbdE9mZnNldCsrXSxcclxuICAgICAgICAgICAgdGV4Q29vcmRsQnVmZmVyW3RPZmZzZXQrK10sXHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgICAgdmVydGljZXMuc2V0KHRleENvb3JkLCBzdHJpZGUgKiBpICsgMyk7XHJcblxyXG4gICAgICAgICAgY29uc3Qgbm9ybWFsID0gW1xyXG4gICAgICAgICAgICBub3JtYWxCdWZmZXJbbk9mZnNldCsrXSxcclxuICAgICAgICAgICAgbm9ybWFsQnVmZmVyW25PZmZzZXQrK10sXHJcbiAgICAgICAgICAgIG5vcm1hbEJ1ZmZlcltuT2Zmc2V0KytdLFxyXG4gICAgICAgICAgXTtcclxuICAgICAgICAgIHZlcnRpY2VzLnNldChub3JtYWwsIHN0cmlkZSAqIGkgKyA1KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGluZGljZXNcclxuICAgICAgICBjb25zdCBpbmRleEFjY2Vzc29yID0gdGhpcy5nbHRmLmFjY2Vzc29yc1twcmltaXRpdmUuaW5kaWNlc107XHJcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXJWaWV3ID0gdGhpcy5nbHRmLmJ1ZmZlclZpZXdzW2luZGV4QWNjZXNzb3IuYnVmZmVyVmlld107XHJcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLmJ1ZmZlcnNbaW5kZXhCdWZmZXJWaWV3LmJ1ZmZlcl07XHJcblxyXG4gICAgICAgIC8vIGluZGljZXMgYXJyYXlcclxuICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFxyXG4gICAgICAgICAgaW5kZXhCdWZmZXIsXHJcbiAgICAgICAgICBpbmRleEJ1ZmZlclZpZXcuYnl0ZU9mZnNldCxcclxuICAgICAgICAgIGluZGV4QnVmZmVyVmlldy5ieXRlTGVuZ3RoIC8gVWludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlRcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuZ2x0Zi5tYXRlcmlhbHNbcHJpbWl0aXZlLm1hdGVyaWFsXTtcclxuICAgICAgICAvLyBiYXNlIGNvbG9yIHRleHR1cmVcclxuICAgICAgICBjb25zdCBiY1Rlcnh0dXJlSW5kZXggPVxyXG4gICAgICAgICAgbWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZS5pbmRleDtcclxuICAgICAgICBjb25zdCBiY0ltYWdlSW5kZXggPSB0aGlzLmdsdGYudGV4dHVyZXNbYmNUZXJ4dHVyZUluZGV4XS5zb3VyY2U7XHJcbiAgICAgICAgY29uc3QgYmFzZUNvbG9yVVJJID0gdGhpcy5wYXRobmFtZSArIHRoaXMuZ2x0Zi5pbWFnZXNbYmNJbWFnZUluZGV4XS51cmk7XHJcbiAgICAgICAgLy8gbWV0YWxsaWMgcm91Z2huZXNzIHRleHR1cmVcclxuICAgICAgICBjb25zdCBtclRleHR1cmVJbmRleCA9XHJcbiAgICAgICAgICBtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUuaW5kZXg7XHJcbiAgICAgICAgY29uc3QgbXJJbWFnZUluZGV4ID0gdGhpcy5nbHRmLnRleHR1cmVzW21yVGV4dHVyZUluZGV4XS5zb3VyY2U7XHJcbiAgICAgICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3NVUkkgPVxyXG4gICAgICAgICAgdGhpcy5wYXRobmFtZSArIHRoaXMuZ2x0Zi5pbWFnZXNbbXJJbWFnZUluZGV4XS51cmk7XHJcbiAgICAgICAgLy8gbm9ybWFsIHRleHR1cmVcclxuICAgICAgICBjb25zdCBuVGV4dHVyZUluZGV4ID0gbWF0ZXJpYWwubm9ybWFsVGV4dHVyZS5pbmRleDtcclxuICAgICAgICBjb25zdCBuSW1hZ2VJbmRleCA9IHRoaXMuZ2x0Zi50ZXh0dXJlc1tuVGV4dHVyZUluZGV4XS5zb3VyY2U7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsVVJJID0gdGhpcy5wYXRobmFtZSArIHRoaXMuZ2x0Zi5pbWFnZXNbbkltYWdlSW5kZXhdLnVyaTtcclxuICAgICAgICAvLyBlbWlzc2l2ZSBmYWN0b3IgdGV4dHVyZVxyXG4gICAgICAgIGNvbnN0IGVtaXNzaXZlID0gbWF0ZXJpYWwuZW1pc3NpdmVGYWN0b3I7XHJcbiAgICAgICAgY29uc3QgZVRleHR1cmVJbmRleCA9IG1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZS5pbmRleDtcclxuICAgICAgICBjb25zdCBlSW1hZ2VJbmRleCA9IHRoaXMuZ2x0Zi50ZXh0dXJlc1tlVGV4dHVyZUluZGV4XS5zb3VyY2U7XHJcbiAgICAgICAgY29uc3QgZW1pc3NpdmVVUkkgPSB0aGlzLnBhdGhuYW1lICsgdGhpcy5nbHRmLmltYWdlc1tlSW1hZ2VJbmRleF0udXJpO1xyXG4gICAgICAgIC8vIG9jY2x1c2lvbiB0ZXh0dXJlXHJcbiAgICAgICAgY29uc3Qgb1RleHR1cmVJbmRleCA9IG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUuaW5kZXg7XHJcbiAgICAgICAgY29uc3Qgb0ltYWdlSW5kZXggPSB0aGlzLmdsdGYudGV4dHVyZXNbb1RleHR1cmVJbmRleF0uc291cmNlO1xyXG4gICAgICAgIGNvbnN0IG9jY2x1c2lvblVSSSA9IHRoaXMucGF0aG5hbWUgKyB0aGlzLmdsdGYuaW1hZ2VzW29JbWFnZUluZGV4XS51cmk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2VvbWV0cmllc1tpbmRleF0gPSB7XHJcbiAgICAgICAgICBtb2RlbCxcclxuICAgICAgICAgIHZlcnRpY2VzLFxyXG4gICAgICAgICAgYXJyYXlTdHJpZGUsXHJcbiAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICBmb3JtYXQ6IHBvc2l0aW9uVHlwZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBwb3NpdGlvbk9mZnNldCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgZm9ybWF0OiBub3JtYWxUeXBlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IG5vcm1hbE9mZnNldCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0ZXhDb29yZDoge1xyXG4gICAgICAgICAgICBmb3JtYXQ6IHRleENvb3JkVHlwZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiB0ZXhDb29yZE9mZnNldCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBpbmRpY2VzLFxyXG4gICAgICAgICAgdGV4dHVyZXM6IHtcclxuICAgICAgICAgICAgYmFzZUNvbG9yVVJJLFxyXG4gICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc1VSSSxcclxuICAgICAgICAgICAgbm9ybWFsVVJJLFxyXG4gICAgICAgICAgICBlbWlzc2l2ZSxcclxuICAgICAgICAgICAgZW1pc3NpdmVVUkksXHJcbiAgICAgICAgICAgIG9jY2x1c2lvblVSSSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IHR5cGUgSERSID0ge1xyXG4gIHdpZHRoOiBudW1iZXI7XHJcbiAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgZGF0YTogRmxvYXQzMkFycmF5O1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSERSTG9hZGVyIHtcclxuICBwcml2YXRlIGJ1ZmZlcjogQXJyYXlCdWZmZXI7XHJcbiAgcHJpdmF0ZSB3aWR0aDogbnVtYmVyO1xyXG4gIHByaXZhdGUgaGVpZ2h0OiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHt9XHJcblxyXG4gIHB1YmxpYyBnZXQgaGRyKCk6IEhEUiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgZGF0YTogdGhpcy5kYXRhLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBsb2FkKHVybDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCB0aGlzLmxvYWRCdWZmZXIodXJsKTtcclxuICAgIHRoaXMucGFyc2VIRFIoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbG9hZEJ1ZmZlcih1cmw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsKTtcclxuICAgIGlmICghcmVzLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIC5oZHIgZmlsZTogJHt1cmx9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5idWZmZXIgPSBhd2FpdCByZXMuYXJyYXlCdWZmZXIoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGFyc2VIRFIoKTogdm9pZCB7XHJcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKTtcclxuXHJcbiAgICAvLyBIRFIgaGVhZGVyXHJcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwiYXNjaWlcIik7XHJcbiAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgbGV0IGhlYWRlciA9IFwiXCI7XHJcblxyXG4gICAgd2hpbGUgKGluZGV4IDwgYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGNoYXIgPSBkZWNvZGVyLmRlY29kZShieXRlcy5zbGljZShpbmRleCwgaW5kZXggKyAxKSk7XHJcbiAgICAgIGhlYWRlciArPSBjaGFyO1xyXG4gICAgICBpbmRleCsrO1xyXG4gICAgICBpZiAoY2hhciA9PT0gXCJcXG5cIiAmJiBoZWFkZXIuaW5jbHVkZXMoXCItWSBcIikgJiYgaGVhZGVyLmluY2x1ZGVzKFwiICtYIFwiKSkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICAhaGVhZGVyLmluY2x1ZGVzKFwiMzItYml0X3JsZV9yZ2JlXCIpICYmXHJcbiAgICAgICFoZWFkZXIuaW5jbHVkZXMoXCIzMi1iaXRfcmxlX3h5emVcIilcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIRFJMb2FkZXI6IFVuc3VwcG9ydGVkIC5oZHIgZm9ybWF0LlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXNvbHV0aW9uID0gaGVhZGVyLm1hdGNoKC8tWSAoXFxkKykgXFwrWCAoXFxkKykvKTtcclxuICAgIGlmICghcmVzb2x1dGlvbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIRFJMb2FkZXI6IE5vIHJlc29sdXRpb24gZm91bmQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMud2lkdGggPSBwYXJzZUludChyZXNvbHV0aW9uWzJdKTtcclxuICAgIHRoaXMuaGVpZ2h0ID0gcGFyc2VJbnQocmVzb2x1dGlvblsxXSk7XHJcblxyXG4gICAgLy8gSERSIHBpeGVsIGJ5dGVzXHJcbiAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIDQpO1xyXG4gICAgbGV0IGN1cnJlbnRQaXhlbCA9IDA7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBieXRlcy5sZW5ndGgpIHtcclxuICAgICAgY29uc3Qgc2NhbmxpbmVIZWFkZXIgPSBieXRlcy5zbGljZShpbmRleCwgaW5kZXggKyA0KTtcclxuICAgICAgaW5kZXggKz0gNDtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBzY2FubGluZUhlYWRlclswXSAhPT0gMiB8fFxyXG4gICAgICAgIHNjYW5saW5lSGVhZGVyWzFdICE9PSAyIHx8XHJcbiAgICAgICAgKHNjYW5saW5lSGVhZGVyWzJdIDw8IDgpICsgc2NhbmxpbmVIZWFkZXJbM10gIT09IHRoaXMud2lkdGhcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSERSTG9hZGVyOiBPbmx5IHN1cHBvcnQgUkxFIGZvcm1hdC5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHNjYW5saW5lID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIDQpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgdGhpcy53aWR0aCkge1xyXG4gICAgICAgICAgY29uc3QgY291bnQgPSBieXRlc1tpbmRleCsrXTtcclxuICAgICAgICAgIGlmIChjb3VudCA+IDEyOCkge1xyXG4gICAgICAgICAgICBjb25zdCBydW5MZW5ndGggPSBjb3VudCAtIDEyODtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBieXRlc1tpbmRleCsrXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBydW5MZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgIHNjYW5saW5lW2kgKyBwb3NpdGlvbiAqIDRdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgcG9zaXRpb24rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgc2NhbmxpbmVbaSArIHBvc2l0aW9uICogNF0gPSBieXRlc1tpbmRleCsrXTtcclxuICAgICAgICAgICAgICBwb3NpdGlvbisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xyXG4gICAgICAgIGNvbnN0IHIgPSBzY2FubGluZVt4ICogNF07XHJcbiAgICAgICAgY29uc3QgZyA9IHNjYW5saW5lW3ggKiA0ICsgMV07XHJcbiAgICAgICAgY29uc3QgYiA9IHNjYW5saW5lW3ggKiA0ICsgMl07XHJcbiAgICAgICAgY29uc3QgZSA9IHNjYW5saW5lW3ggKiA0ICsgM107XHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBlIC0gMTI4KSAvIDI1NTtcclxuXHJcbiAgICAgICAgdGhpcy5kYXRhW2N1cnJlbnRQaXhlbCsrXSA9IHIgKiBzY2FsZTtcclxuICAgICAgICB0aGlzLmRhdGFbY3VycmVudFBpeGVsKytdID0gZyAqIHNjYWxlO1xyXG4gICAgICAgIHRoaXMuZGF0YVtjdXJyZW50UGl4ZWwrK10gPSBiICogc2NhbGU7XHJcbiAgICAgICAgdGhpcy5kYXRhW2N1cnJlbnRQaXhlbCsrXSA9IDEuMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgc2hhZGVyQ29kZSBmcm9tIFwiQC9zaGFkZXJzL3NoYWRlci53Z3NsXCI7XHJcbmltcG9ydCBtaXBtYXBTaGFkZXJDb2RlIGZyb20gXCJAL3NoYWRlcnMvbWlwbWFwLndnc2xcIjtcclxuaW1wb3J0IHNreWJveFNoYWRlckNvZGUgZnJvbSBcIkAvc2hhZGVycy9za3lib3gud2dzbFwiO1xyXG5pbXBvcnQgZXF1aXJlY3Rhbmd1bGFyU2hhZGVyQ29kZSBmcm9tIFwiQC9zaGFkZXJzL2VxdWlyZWN0YW5ndWxhci53Z3NsXCI7XHJcbmltcG9ydCBpcnJhZGlhbmNlbWFwU2hhZGVyQ29kZSBmcm9tIFwiQC9zaGFkZXJzL2lycmFkaWFuY2VtYXAud2dzbFwiO1xyXG5pbXBvcnQgeyBtYXQ0LCB1dGlscywgdmVjMyB9IGZyb20gXCJ3Z3B1LW1hdHJpeFwiO1xyXG5pbXBvcnQgeyBHVUksIEdVSUNvbnRyb2xsZXIgfSBmcm9tIFwiZGF0Lmd1aVwiO1xyXG5pbXBvcnQge1xyXG4gIGxvYWRJbWFnZUJpdG1hcCxcclxuICBjYWxjdWxhdGVNaXBMZXZlbENvdW50LFxyXG4gIFJvbGxpbmdBdmVyYWdlLFxyXG59IGZyb20gXCJAL3V0aWxzXCI7XHJcbmltcG9ydCBDYW1lcmEgZnJvbSBcIkAvY2FtZXJhXCI7XHJcbmltcG9ydCBnbFRGTG9hZGVyLCB7IHR5cGUgR2VvbWV0cnkgfSBmcm9tIFwiQC9nbFRGXCI7XHJcbmltcG9ydCBIRFJMb2FkZXIsIHsgdHlwZSBIRFIgfSBmcm9tIFwiQC9oZHJcIjtcclxuXHJcbmNvbnN0IGZwc0F2ZyA9IG5ldyBSb2xsaW5nQXZlcmFnZSgpO1xyXG5jb25zdCBjcHVUaW1lQXZnID0gbmV3IFJvbGxpbmdBdmVyYWdlKCk7XHJcbmNvbnN0IGdwdVRpbWVBdmcgPSBuZXcgUm9sbGluZ0F2ZXJhZ2UoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcclxuICBwcml2YXRlIGNhbWVyYTogQ2FtZXJhO1xyXG5cclxuICBwcml2YXRlIGFkYXB0ZXI6IEdQVUFkYXB0ZXI7XHJcbiAgcHJpdmF0ZSBkZXZpY2U6IEdQVURldmljZTtcclxuICBwcml2YXRlIGhhc1RpbWVzdGFtcDogYm9vbGVhbjtcclxuICBwcml2YXRlIHF1ZXJ5U2V0OiBHUFVRdWVyeVNldDtcclxuICBwcml2YXRlIHJlc29sdmVCdWZmZXI6IEdQVUJ1ZmZlcjtcclxuICBwcml2YXRlIHJlc3VsdEJ1ZmZlcjogR1BVQnVmZmVyO1xyXG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudDtcclxuICBwcml2YXRlIGNvbnRleHQ6IEdQVUNhbnZhc0NvbnRleHQ7XHJcbiAgcHJpdmF0ZSBwcmVzZW50YXRpb25Gb3JtYXQ6IEdQVVRleHR1cmVGb3JtYXQ7XHJcbiAgcHJpdmF0ZSBtdWx0aXNhbXBsaW5nVGV4dHVyZTogR1BVVGV4dHVyZTtcclxuICBwcml2YXRlIG11bHRpc2FtcGxpbmdUZXh0dXJlVmlldzogR1BVVGV4dHVyZVZpZXc7XHJcbiAgcHJpdmF0ZSBkZXB0aFRleHR1cmVzOiBBcnJheTxHUFVUZXh0dXJlPjtcclxuICBwcml2YXRlIGRlcHRoVGV4dHVyZVZpZXdzOiBBcnJheTxHUFVUZXh0dXJlVmlldz47XHJcblxyXG4gIHByaXZhdGUgZ2VvbWV0cmllczogQXJyYXk8R2VvbWV0cnk+O1xyXG5cclxuICBwcml2YXRlIGhkcnM6IEFycmF5PEhEUj47XHJcblxyXG4gIHByaXZhdGUgcmVuZGVyUGlwZWxpbmVzOiBBcnJheTxHUFVSZW5kZXJQaXBlbGluZT47XHJcbiAgcHJpdmF0ZSB2ZXJ0ZXhCdWZmZXI6IEdQVUJ1ZmZlcjtcclxuICBwcml2YXRlIGluZGV4QnVmZmVyOiBHUFVCdWZmZXI7XHJcbiAgcHJpdmF0ZSBiaW5kR3JvdXBzOiBBcnJheTxBcnJheTxHUFVCaW5kR3JvdXA+PjtcclxuICBwcml2YXRlIHRyYW5zZm9ybVVuaWZvcm1CdWZmZXI6IEdQVUJ1ZmZlcjtcclxuICBwcml2YXRlIHZpZXdQb3NpdGlvblVuaWZvcm1CdWZmZXI6IEdQVUJ1ZmZlcjtcclxuICBwcml2YXRlIGxpZ2h0UG9zaXRpb25zVW5pZm9ybUJ1ZmZlcjogR1BVQnVmZmVyO1xyXG4gIHByaXZhdGUgbGlnaHRDb2xvcnNVbmlmb3JtQnVmZmVyOiBHUFVCdWZmZXI7XHJcblxyXG4gIHByaXZhdGUgc2t5Ym94UmVuZGVyUGlwZWxpbmVzOiBBcnJheTxHUFVSZW5kZXJQaXBlbGluZT47XHJcbiAgcHJpdmF0ZSBza3lib3hCaW5kR3JvdXBzOiBBcnJheTxBcnJheTxHUFVCaW5kR3JvdXA+PjtcclxuICBwcml2YXRlIHNreWJveFVuaWZvcm1CdWZmZXI6IEdQVUJ1ZmZlcjtcclxuXHJcbiAgcHJpdmF0ZSBjdXJyZW50OiBudW1iZXI7XHJcblxyXG4gIHByaXZhdGUgZnBzQ29udHJvbGxlcjogR1VJQ29udHJvbGxlcjtcclxuICBwcml2YXRlIGNwdVRpbWVDb250cm9sbGVyOiBHVUlDb250cm9sbGVyO1xyXG4gIHByaXZhdGUgZ3B1VGltZUNvbnRyb2xsZXI6IEdVSUNvbnRyb2xsZXI7XHJcbiAgcHJpdmF0ZSBtaXBtYXBzQ29udHJvbGxlcjogR1VJQ29udHJvbGxlcjtcclxuICBwcml2YXRlIGFkZHJlc3NNb2RlVUNvbnRyb2xsZXI6IEdVSUNvbnRyb2xsZXI7XHJcbiAgcHJpdmF0ZSBhZGRyZXNzTW9kZVZDb250cm9sbGVyOiBHVUlDb250cm9sbGVyO1xyXG4gIHByaXZhdGUgbWFnRmlsdGVyQ29udHJvbGxlcjogR1VJQ29udHJvbGxlcjtcclxuICBwcml2YXRlIG1pbkZpbHRlckNvbnRyb2xsZXI6IEdVSUNvbnRyb2xsZXI7XHJcbiAgcHJpdmF0ZSBtc2FhQ29udHJvbGxlcjogR1VJQ29udHJvbGxlcjtcclxuICBwcml2YXRlIHNreWJveENvbnRyb2xsZXI6IEdVSUNvbnRyb2xsZXI7XHJcblxyXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY2FtZXJhID0gbmV3IENhbWVyYSgpO1xyXG5cclxuICAgIHRoaXMuZGVwdGhUZXh0dXJlcyA9IG5ldyBBcnJheTxHUFVUZXh0dXJlPigyKTtcclxuICAgIHRoaXMuZGVwdGhUZXh0dXJlVmlld3MgPSBuZXcgQXJyYXk8R1BVVGV4dHVyZVZpZXc+KDIpO1xyXG5cclxuICAgIHRoaXMucmVuZGVyUGlwZWxpbmVzID0gbmV3IEFycmF5PEdQVVJlbmRlclBpcGVsaW5lPigyKTtcclxuICAgIHRoaXMuYmluZEdyb3VwcyA9IG5ldyBBcnJheTxBcnJheTxHUFVCaW5kR3JvdXA+PihcclxuICAgICAgbmV3IEFycmF5PEdQVUJpbmRHcm91cD4oKSxcclxuICAgICAgbmV3IEFycmF5PEdQVUJpbmRHcm91cD4oKSxcclxuICAgICAgbmV3IEFycmF5PEdQVUJpbmRHcm91cD4oKSxcclxuICAgICAgbmV3IEFycmF5PEdQVUJpbmRHcm91cD4oKVxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLnNreWJveFJlbmRlclBpcGVsaW5lcyA9IG5ldyBBcnJheTxHUFVSZW5kZXJQaXBlbGluZT4oMik7XHJcbiAgICB0aGlzLnNreWJveEJpbmRHcm91cHMgPSBuZXcgQXJyYXk8QXJyYXk8R1BVQmluZEdyb3VwPj4oXHJcbiAgICAgIG5ldyBBcnJheTxHUFVCaW5kR3JvdXA+KCksXHJcbiAgICAgIG5ldyBBcnJheTxHUFVCaW5kR3JvdXA+KCksXHJcbiAgICAgIG5ldyBBcnJheTxHUFVCaW5kR3JvdXA+KClcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50ID0gMDtcclxuXHJcbiAgICB0aGlzLmRyYXdGcmFtZSA9IHRoaXMuZHJhd0ZyYW1lLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgcmVuZGVyKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XHJcbiAgICB0aGlzLnJ1bigpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBpbml0KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5jaGVja1dlYkdQVVN1cHBvcnQoKTtcclxuICAgIGF3YWl0IHRoaXMucmVxdWVzdEFkYXB0ZXIoKTtcclxuICAgIGF3YWl0IHRoaXMucmVxdWVzdERldmljZSgpO1xyXG4gICAgdGhpcy5nZXRDYW52YXMoKTtcclxuICAgIHRoaXMuY29uZmlnQ29udGV4dCgpO1xyXG4gICAgdGhpcy5jcmVhdGVNdWx0aXNhbXBsaW5nVGV4dHVyZSgpO1xyXG4gICAgdGhpcy5jcmVhdGVEZXB0aFRleHR1cmVzKCk7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5sb2FkTW9kZWwoKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLmxvYWRIRFIoKTtcclxuXHJcbiAgICB0aGlzLmNyZWF0ZVJlbmRlclBpcGVsaW5lKCk7XHJcbiAgICB0aGlzLmNyZWF0ZVZlcnRleEJ1ZmZlcigpO1xyXG4gICAgdGhpcy5jcmVhdGVJbmRleEJ1ZmZlcigpO1xyXG4gICAgdGhpcy5jcmVhdGVVbmlmb3JtQnVmZmVyKCk7XHJcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgICB0aGlzLmNyZWF0ZVNreWJveFJlbmRlclBpcGVsaW5lKCk7XHJcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZVNreWJveFVuaWZvcm1CdWZmZXIoKTtcclxuXHJcbiAgICB0aGlzLmluaXRHVUkoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2hlY2tXZWJHUFVTdXBwb3J0KCk6IHZvaWQge1xyXG4gICAgaWYgKCFuYXZpZ2F0b3IuZ3B1KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYkdQVSBub3Qgc3VwcG9ydGVkLlwiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVxdWVzdEFkYXB0ZXIoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1Py5yZXF1ZXN0QWRhcHRlcigpO1xyXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJlcXVlc3QgV2ViR1BVIGFkYXB0ZXIuXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZXF1ZXN0RGV2aWNlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5oYXNUaW1lc3RhbXAgPSB0aGlzLmFkYXB0ZXI/LmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKTtcclxuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZXM6IEdQVUZlYXR1cmVOYW1lW10gPSB0aGlzLmhhc1RpbWVzdGFtcFxyXG4gICAgICA/IFtcInRpbWVzdGFtcC1xdWVyeVwiXVxyXG4gICAgICA6IFtdO1xyXG5cclxuICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgdGhpcy5hZGFwdGVyPy5yZXF1ZXN0RGV2aWNlKHtcclxuICAgICAgbGFiZWw6IGBHUFUgRGV2aWNlICR7XHJcbiAgICAgICAgdGhpcy5oYXNUaW1lc3RhbXAgJiYgXCJ3aXRoIGZlYXR1cmU6IHRpbWVzdGFtcC1xdWVyeVwiXHJcbiAgICAgIH1gLFxyXG4gICAgICByZXF1aXJlZEZlYXR1cmVzLFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXRoaXMuZGV2aWNlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZXF1ZXN0IFdlYkdQVSBkZXZpY2UuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmhhc1RpbWVzdGFtcCkge1xyXG4gICAgICB0aGlzLnF1ZXJ5U2V0ID0gdGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe1xyXG4gICAgICAgIGxhYmVsOiBcIkdQVSBRdWVyeSBTZXQgd2l0aCBUeXBlOiB0aW1lc3RhbXBcIixcclxuICAgICAgICB0eXBlOiBcInRpbWVzdGFtcFwiLFxyXG4gICAgICAgIGNvdW50OiAyLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMucmVzb2x2ZUJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XHJcbiAgICAgICAgbGFiZWw6IFwiR1BVIEJ1ZmZlcjogUmVzb2x2ZVwiLFxyXG4gICAgICAgIHNpemU6IHRoaXMucXVlcnlTZXQuY291bnQgKiA4LFxyXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5yZXN1bHRCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe1xyXG4gICAgICAgIGxhYmVsOiBcIkdQVSBCdWZmZXI6IFJlc3VsdFwiLFxyXG4gICAgICAgIHNpemU6IHRoaXMucmVzb2x2ZUJ1ZmZlci5zaXplLFxyXG4gICAgICAgIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFELFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRldmljZS5sb3N0LnRoZW4oKGluZm8pID0+IHtcclxuICAgICAgaWYgKGluZm8ucmVhc29uICE9PSBcImRlc3Ryb3llZFwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXZWJHUFUgZGV2aWNlIHdhcyBsb3N0OiAke2luZm8ubWVzc2FnZX1gKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldENhbnZhcygpOiB2b2lkIHtcclxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhc1wiKTtcclxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZpbmQgY2FudmFzIGVsZW1lbnQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGVudHJ5LnRhcmdldCBhcyBIVE1MQ2FudmFzRWxlbWVudDtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRCb3hTaXplWzBdLmlubGluZVNpemU7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudEJveFNpemVbMF0uYmxvY2tTaXplO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgMSxcclxuICAgICAgICAgIE1hdGgubWluKHdpZHRoLCB0aGlzLmRldmljZS5saW1pdHMubWF4VGV4dHVyZURpbWVuc2lvbjJEKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgMSxcclxuICAgICAgICAgIE1hdGgubWluKGhlaWdodCwgdGhpcy5kZXZpY2UubGltaXRzLm1heFRleHR1cmVEaW1lbnNpb24yRClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZU11bHRpc2FtcGxpbmdUZXh0dXJlKCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVEZXB0aFRleHR1cmVzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNhbnZhcyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNvbmZpZ0NvbnRleHQoKTogdm9pZCB7XHJcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ3B1XCIpO1xyXG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBXZWJHUFUgY29udGV4dCBmcm9tIGNhbnZhcy5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wcmVzZW50YXRpb25Gb3JtYXQgPSBuYXZpZ2F0b3IuZ3B1LmdldFByZWZlcnJlZENhbnZhc0Zvcm1hdCgpO1xyXG5cclxuICAgIHRoaXMuY29udGV4dC5jb25maWd1cmUoe1xyXG4gICAgICBkZXZpY2U6IHRoaXMuZGV2aWNlLFxyXG4gICAgICBmb3JtYXQ6IHRoaXMucHJlc2VudGF0aW9uRm9ybWF0LFxyXG4gICAgICBhbHBoYU1vZGU6IFwicHJlbXVsdGlwbGllZFwiLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZU11bHRpc2FtcGxpbmdUZXh0dXJlKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMubXVsdGlzYW1wbGluZ1RleHR1cmUpIHtcclxuICAgICAgdGhpcy5tdWx0aXNhbXBsaW5nVGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tdWx0aXNhbXBsaW5nVGV4dHVyZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xyXG4gICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZTogTXVsdGlzYW1wbGluZyBUZXh0dXJlXCIsXHJcbiAgICAgIHNpemU6IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XSxcclxuICAgICAgZm9ybWF0OiB0aGlzLnByZXNlbnRhdGlvbkZvcm1hdCxcclxuICAgICAgdXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCxcclxuICAgICAgc2FtcGxlQ291bnQ6IDQsXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm11bHRpc2FtcGxpbmdUZXh0dXJlVmlldyA9IHRoaXMubXVsdGlzYW1wbGluZ1RleHR1cmUuY3JlYXRlVmlldyh7XHJcbiAgICAgIGxhYmVsOiBcIkdQVSBUZXh0dXJlIFZpZXc6IE11bHRpc2FtcGxpbmcgVGV4dHVyZSBWaWV3XCIsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlRGVwdGhUZXh0dXJlcygpOiB2b2lkIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgKytpKSB7XHJcbiAgICAgIGlmICh0aGlzLmRlcHRoVGV4dHVyZXNbaV0pIHtcclxuICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZXNbaV0uZGVzdHJveSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZXNbaV0gPSB0aGlzLmRldmljZS5jcmVhdGVUZXh0dXJlKHtcclxuICAgICAgICBsYWJlbDogYEdQVSBUZXh0dXJlOiBEZXB0aCBUZXh0dXJlICR7aSAmJiBcIndpdGggTVNBQVwifWAsXHJcbiAgICAgICAgc2l6ZTogW3RoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHRdLFxyXG4gICAgICAgIGZvcm1hdDogXCJkZXB0aDI0cGx1c1wiLFxyXG4gICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQsXHJcbiAgICAgICAgc2FtcGxlQ291bnQ6IGkgPyA0IDogMSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZVZpZXdzW2ldID0gdGhpcy5kZXB0aFRleHR1cmVzW2ldLmNyZWF0ZVZpZXcoe1xyXG4gICAgICAgIGxhYmVsOiBgR1BVIFRleHR1cmUgVmlldzogRGVwdGggVGV4dHVyZSBWaWV3ICR7aSAmJiBcIndpdGggTVNBQVwifWAsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBsb2FkTW9kZWwoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgZ2xURkxvYWRlcigpO1xyXG4gICAgYXdhaXQgbG9hZGVyLmxvYWQoXCJtb2RlbHMvRGFtYWdlZEhlbG1ldC9EYW1hZ2VkSGVsbWV0LmdsdGZcIik7XHJcblxyXG4gICAgdGhpcy5nZW9tZXRyaWVzID0gbG9hZGVyLmdldEdlb21ldHJpZXMoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbG9hZEhEUigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGxvYWRlcjAgPSBuZXcgSERSTG9hZGVyKCk7XHJcbiAgICBhd2FpdCBsb2FkZXIwLmxvYWQoXCJpbWFnZXMvcHVyZXNreV80ay5oZHJcIik7XHJcbiAgICBjb25zdCBsb2FkZXIxID0gbmV3IEhEUkxvYWRlcigpO1xyXG4gICAgYXdhaXQgbG9hZGVyMS5sb2FkKFwiaW1hZ2VzL2NsZWFyX3B1cmVza3lfNGsuaGRyXCIpO1xyXG4gICAgdGhpcy5oZHJzID0gW2xvYWRlcjAuaGRyLCBsb2FkZXIxLmhkcl07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZVJlbmRlclBpcGVsaW5lKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgc2hhZGVyTW9kdWxlID0gdGhpcy5jcmVhdGVTaGFkZXJNb2R1bGUoXHJcbiAgICAgIFwiR1BVIFNoYWRlciBNb2R1bGVcIixcclxuICAgICAgc2hhZGVyQ29kZVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBiaW5kR3JvdXBMYXlvdXQwID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtcclxuICAgICAgbGFiZWw6IFwiR1BVIEJpbmQgR3JvdXAgMCBMYXlvdXRcIixcclxuICAgICAgZW50cmllczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5WRVJURVgsXHJcbiAgICAgICAgICBidWZmZXI6IHsgdHlwZTogXCJ1bmlmb3JtXCIgYXMgR1BVQnVmZmVyQmluZGluZ1R5cGUgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGJpbmRpbmc6IDEsXHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcclxuICAgICAgICAgIGJ1ZmZlcjogeyB0eXBlOiBcInVuaWZvcm1cIiBhcyBHUFVCdWZmZXJCaW5kaW5nVHlwZSB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYmluZGluZzogMixcclxuICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxyXG4gICAgICAgICAgYnVmZmVyOiB7IHR5cGU6IFwidW5pZm9ybVwiIGFzIEdQVUJ1ZmZlckJpbmRpbmdUeXBlIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBiaW5kaW5nOiAzLFxyXG4gICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXHJcbiAgICAgICAgICBidWZmZXI6IHsgdHlwZTogXCJ1bmlmb3JtXCIgYXMgR1BVQnVmZmVyQmluZGluZ1R5cGUgfSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBiaW5kR3JvdXBMYXlvdXQxID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtcclxuICAgICAgbGFiZWw6IFwiR1BVIEJpbmQgR3JvdXAgMSBMYXlvdXRcIixcclxuICAgICAgZW50cmllczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcclxuICAgICAgICAgIHRleHR1cmU6IHtcclxuICAgICAgICAgICAgc2FtcGxlVHlwZTogXCJmbG9hdFwiIGFzIEdQVVRleHR1cmVTYW1wbGVUeXBlLFxyXG4gICAgICAgICAgICB2aWV3RGltZW5zaW9uOiBcIjJkXCIgYXMgR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24sXHJcbiAgICAgICAgICAgIG11bHRpc2FtcGxlZDogZmFsc2UsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxyXG4gICAgICAgICAgdGV4dHVyZToge1xyXG4gICAgICAgICAgICBzYW1wbGVUeXBlOiBcImZsb2F0XCIgYXMgR1BVVGV4dHVyZVNhbXBsZVR5cGUsXHJcbiAgICAgICAgICAgIHZpZXdEaW1lbnNpb246IFwiMmRcIiBhcyBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbixcclxuICAgICAgICAgICAgbXVsdGlzYW1wbGVkOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBiaW5kaW5nOiAyLFxyXG4gICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXHJcbiAgICAgICAgICB0ZXh0dXJlOiB7XHJcbiAgICAgICAgICAgIHNhbXBsZVR5cGU6IFwiZmxvYXRcIiBhcyBHUFVUZXh0dXJlU2FtcGxlVHlwZSxcclxuICAgICAgICAgICAgdmlld0RpbWVuc2lvbjogXCIyZFwiIGFzIEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLFxyXG4gICAgICAgICAgICBtdWx0aXNhbXBsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGJpbmRpbmc6IDMsXHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcclxuICAgICAgICAgIGJ1ZmZlcjogeyB0eXBlOiBcInVuaWZvcm1cIiBhcyBHUFVCdWZmZXJCaW5kaW5nVHlwZSB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYmluZGluZzogNCxcclxuICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxyXG4gICAgICAgICAgdGV4dHVyZToge1xyXG4gICAgICAgICAgICBzYW1wbGVUeXBlOiBcImZsb2F0XCIgYXMgR1BVVGV4dHVyZVNhbXBsZVR5cGUsXHJcbiAgICAgICAgICAgIHZpZXdEaW1lbnNpb246IFwiMmRcIiBhcyBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbixcclxuICAgICAgICAgICAgbXVsdGlzYW1wbGVkOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBiaW5kaW5nOiA1LFxyXG4gICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXHJcbiAgICAgICAgICB0ZXh0dXJlOiB7XHJcbiAgICAgICAgICAgIHNhbXBsZVR5cGU6IFwiZmxvYXRcIiBhcyBHUFVUZXh0dXJlU2FtcGxlVHlwZSxcclxuICAgICAgICAgICAgdmlld0RpbWVuc2lvbjogXCIyZFwiIGFzIEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLFxyXG4gICAgICAgICAgICBtdWx0aXNhbXBsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBiaW5kR3JvdXBMYXlvdXQyID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtcclxuICAgICAgbGFiZWw6IFwiR1BVIEJpbmQgR3JvdXAgMiBMYXlvdXRcIixcclxuICAgICAgZW50cmllczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcclxuICAgICAgICAgIHRleHR1cmU6IHtcclxuICAgICAgICAgICAgc2FtcGxlVHlwZTogXCJ1bmZpbHRlcmFibGUtZmxvYXRcIiBhcyBHUFVUZXh0dXJlU2FtcGxlVHlwZSxcclxuICAgICAgICAgICAgdmlld0RpbWVuc2lvbjogXCJjdWJlXCIgYXMgR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24sXHJcbiAgICAgICAgICAgIG11bHRpc2FtcGxlZDogZmFsc2UsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGJpbmRHcm91cExheW91dDMgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xyXG4gICAgICBsYWJlbDogXCJHUFUgQmluZCBHcm91cCAzIExheW91dFwiLFxyXG4gICAgICBlbnRyaWVzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxyXG4gICAgICAgICAgc2FtcGxlcjogeyB0eXBlOiBcImZpbHRlcmluZ1wiIGFzIEdQVVNhbXBsZXJCaW5kaW5nVHlwZSB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkZSQUdNRU5ULFxyXG4gICAgICAgICAgc2FtcGxlcjogeyB0eXBlOiBcIm5vbi1maWx0ZXJpbmdcIiBhcyBHUFVTYW1wbGVyQmluZGluZ1R5cGUgfSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCByZW5kZXJQaXBlbGluZUxheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcclxuICAgICAgbGFiZWw6IFwiR1BVIFJlbmRlciBQaXBlbGluZSBMYXlvdXRcIixcclxuICAgICAgYmluZEdyb3VwTGF5b3V0czogW1xyXG4gICAgICAgIGJpbmRHcm91cExheW91dDAsXHJcbiAgICAgICAgYmluZEdyb3VwTGF5b3V0MSxcclxuICAgICAgICBiaW5kR3JvdXBMYXlvdXQyLFxyXG4gICAgICAgIGJpbmRHcm91cExheW91dDMsXHJcbiAgICAgIF0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZW5kZXJQaXBlbGluZURlc2NyaXB0b3I6IEdQVVJlbmRlclBpcGVsaW5lRGVzY3JpcHRvciA9IHtcclxuICAgICAgbGFiZWw6IFwiR1BVIFJlbmRlciBQaXBlbGluZVwiLFxyXG4gICAgICBsYXlvdXQ6IHJlbmRlclBpcGVsaW5lTGF5b3V0LFxyXG4gICAgICB2ZXJ0ZXg6IHtcclxuICAgICAgICBtb2R1bGU6IHNoYWRlck1vZHVsZSxcclxuICAgICAgICBlbnRyeVBvaW50OiBcInZzX21haW5cIixcclxuICAgICAgICBidWZmZXJzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGFycmF5U3RyaWRlOiB0aGlzLmdlb21ldHJpZXNbMF0uYXJyYXlTdHJpZGUsXHJcbiAgICAgICAgICAgIHN0ZXBNb2RlOiBcInZlcnRleFwiIGFzIEdQVVZlcnRleFN0ZXBNb2RlLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLmdlb21ldHJpZXNbMF0ucG9zaXRpb24uZm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmdlb21ldHJpZXNbMF0ucG9zaXRpb24ub2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDAsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZ2VvbWV0cmllc1swXS50ZXhDb29yZC5mb3JtYXQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuZ2VvbWV0cmllc1swXS50ZXhDb29yZC5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBzaGFkZXJMb2NhdGlvbjogMSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5nZW9tZXRyaWVzWzBdLm5vcm1hbC5mb3JtYXQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuZ2VvbWV0cmllc1swXS5ub3JtYWwub2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDIsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgICAgcHJpbWl0aXZlOiB7XHJcbiAgICAgICAgdG9wb2xvZ3k6IFwidHJpYW5nbGUtbGlzdFwiLFxyXG4gICAgICAgIGN1bGxNb2RlOiBcImJhY2tcIixcclxuICAgICAgfSxcclxuICAgICAgZGVwdGhTdGVuY2lsOiB7XHJcbiAgICAgICAgZm9ybWF0OiBcImRlcHRoMjRwbHVzXCIsXHJcbiAgICAgICAgZGVwdGhXcml0ZUVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgZGVwdGhDb21wYXJlOiBcImxlc3NcIixcclxuICAgICAgfSxcclxuICAgICAgbXVsdGlzYW1wbGU6IHtcclxuICAgICAgICBjb3VudDogMSxcclxuICAgICAgfSxcclxuICAgICAgZnJhZ21lbnQ6IHtcclxuICAgICAgICBtb2R1bGU6IHNoYWRlck1vZHVsZSxcclxuICAgICAgICBlbnRyeVBvaW50OiBcImZzX21haW5cIixcclxuICAgICAgICB0YXJnZXRzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5wcmVzZW50YXRpb25Gb3JtYXQsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgKytpKSB7XHJcbiAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgcmVuZGVyUGlwZWxpbmVEZXNjcmlwdG9yLmxhYmVsID0gXCJHUFUgUmVuZGVyIFBpcGVsaW5lIHdpdGggTVNBQVwiO1xyXG4gICAgICAgIHJlbmRlclBpcGVsaW5lRGVzY3JpcHRvci5tdWx0aXNhbXBsZS5jb3VudCA9IDQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucmVuZGVyUGlwZWxpbmVzW2ldID0gdGhpcy5kZXZpY2UuY3JlYXRlUmVuZGVyUGlwZWxpbmUoXHJcbiAgICAgICAgcmVuZGVyUGlwZWxpbmVEZXNjcmlwdG9yXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZVZlcnRleEJ1ZmZlcigpOiB2b2lkIHtcclxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLmdlb21ldHJpZXNbMF0udmVydGljZXM7XHJcblxyXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihcclxuICAgICAgXCJHUFUgQnVmZmVyOiBWZXJ0ZXhcIixcclxuICAgICAgdmVydGljZXMuYnl0ZUxlbmd0aCxcclxuICAgICAgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1RcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoXHJcbiAgICAgIHRoaXMudmVydGV4QnVmZmVyLFxyXG4gICAgICAwLFxyXG4gICAgICB2ZXJ0aWNlcy5idWZmZXIsXHJcbiAgICAgIDAsXHJcbiAgICAgIHZlcnRpY2VzLmJ5dGVMZW5ndGhcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZUluZGV4QnVmZmVyKCk6IHZvaWQge1xyXG4gICAgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5nZW9tZXRyaWVzWzBdLmluZGljZXM7XHJcblxyXG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKFxyXG4gICAgICBcIkdQVSBCdWZmZXI6IEluZGV4XCIsXHJcbiAgICAgIGluZGljZXMuYnl0ZUxlbmd0aCxcclxuICAgICAgR1BVQnVmZmVyVXNhZ2UuSU5ERVggfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcclxuICAgICAgdGhpcy5pbmRleEJ1ZmZlcixcclxuICAgICAgMCxcclxuICAgICAgaW5kaWNlcy5idWZmZXIsXHJcbiAgICAgIDAsXHJcbiAgICAgIGluZGljZXMuYnl0ZUxlbmd0aFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlVW5pZm9ybUJ1ZmZlcigpOiB2b2lkIHtcclxuICAgIHRoaXMudHJhbnNmb3JtVW5pZm9ybUJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKFxyXG4gICAgICBgR1BVIFVuaWZvcm0gQnVmZmVyOiBUcmFuc2Zvcm1gLFxyXG4gICAgICAoNCAqIDQgKyA0ICogNCArIDQgKiA0ICsgNCAqIDQpICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1RcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy52aWV3UG9zaXRpb25Vbmlmb3JtQnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoXHJcbiAgICAgIGBHUFUgVW5pZm9ybSBCdWZmZXI6IFZpZXcgUG9zaXRpb25gLFxyXG4gICAgICA0ICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1RcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5saWdodFBvc2l0aW9uc1VuaWZvcm1CdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihcclxuICAgICAgYEdQVSBVbmlmb3JtIEJ1ZmZlcjogTGlnaHQgUG9zaXRpb25zYCxcclxuICAgICAgNCAqIDQgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0gfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmxpZ2h0Q29sb3JzVW5pZm9ybUJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKFxyXG4gICAgICBgR1BVIFVuaWZvcm0gQnVmZmVyOiBMaWdodCBDb2xvcnNgLFxyXG4gICAgICA0ICogNCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUXHJcbiAgICApO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgKytpKSB7XHJcbiAgICAgIGNvbnN0IGJpbmRHcm91cCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgICAgbGFiZWw6IGBHUFUgQmluZCBHcm91cCAwOiBUcmFuc2Zvcm0sIFZpZXcgUG9zaXRpb24sIExpZ2h0IERpcmVjdGlvbiR7XHJcbiAgICAgICAgICBpICYmIFwid2l0aCBNU0FBXCJcclxuICAgICAgICB9YCxcclxuICAgICAgICBsYXlvdXQ6IHRoaXMucmVuZGVyUGlwZWxpbmVzW2ldLmdldEJpbmRHcm91cExheW91dCgwKSxcclxuICAgICAgICBlbnRyaWVzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgIHJlc291cmNlOiB7XHJcbiAgICAgICAgICAgICAgYnVmZmVyOiB0aGlzLnRyYW5zZm9ybVVuaWZvcm1CdWZmZXIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nOiAxLFxyXG4gICAgICAgICAgICByZXNvdXJjZToge1xyXG4gICAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy52aWV3UG9zaXRpb25Vbmlmb3JtQnVmZmVyLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZzogMixcclxuICAgICAgICAgICAgcmVzb3VyY2U6IHtcclxuICAgICAgICAgICAgICBidWZmZXI6IHRoaXMubGlnaHRQb3NpdGlvbnNVbmlmb3JtQnVmZmVyLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZzogMyxcclxuICAgICAgICAgICAgcmVzb3VyY2U6IHtcclxuICAgICAgICAgICAgICBidWZmZXI6IHRoaXMubGlnaHRDb2xvcnNVbmlmb3JtQnVmZmVyLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5iaW5kR3JvdXBzWzBdLnB1c2goYmluZEdyb3VwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlVGV4dHVyZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGJhc2VDb2xvckltYWdlQml0bWFwID0gYXdhaXQgbG9hZEltYWdlQml0bWFwKFxyXG4gICAgICB0aGlzLmdlb21ldHJpZXNbMF0udGV4dHVyZXMuYmFzZUNvbG9yVVJJXHJcbiAgICApO1xyXG4gICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3NJbWFnZUJpdG1hcCA9IGF3YWl0IGxvYWRJbWFnZUJpdG1hcChcclxuICAgICAgdGhpcy5nZW9tZXRyaWVzWzBdLnRleHR1cmVzLm1ldGFsbGljUm91Z2huZXNzVVJJXHJcbiAgICApO1xyXG4gICAgY29uc3Qgbm9ybWFsSW1hZ2VCaXRtYXAgPSBhd2FpdCBsb2FkSW1hZ2VCaXRtYXAoXHJcbiAgICAgIHRoaXMuZ2VvbWV0cmllc1swXS50ZXh0dXJlcy5ub3JtYWxVUklcclxuICAgICk7XHJcbiAgICBjb25zdCBlbWlzc2l2ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5nZW9tZXRyaWVzWzBdLnRleHR1cmVzLmVtaXNzaXZlKTtcclxuICAgIGNvbnN0IGVtaXNzaXZlQnVmZmVyID0gdGhpcy5jcmVhdGVCdWZmZXIoXHJcbiAgICAgIGBHUFUgVW5pZm9ybSBCdWZmZXI6IEVtaXNzaXZlIEZhY3RvcmAsXHJcbiAgICAgIDQgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0gfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVFxyXG4gICAgKTtcclxuICAgIHRoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxyXG4gICAgICBlbWlzc2l2ZUJ1ZmZlcixcclxuICAgICAgMCxcclxuICAgICAgZW1pc3NpdmUuYnVmZmVyLFxyXG4gICAgICBlbWlzc2l2ZS5ieXRlT2Zmc2V0LFxyXG4gICAgICBlbWlzc2l2ZS5ieXRlTGVuZ3RoXHJcbiAgICApO1xyXG4gICAgY29uc3QgZW1pc3NpdmVJbWFnZUJpdG1hcCA9IGF3YWl0IGxvYWRJbWFnZUJpdG1hcChcclxuICAgICAgdGhpcy5nZW9tZXRyaWVzWzBdLnRleHR1cmVzLmVtaXNzaXZlVVJJXHJcbiAgICApO1xyXG4gICAgY29uc3Qgb2NjbHVzaW9uSW1hZ2VCaXRtYXAgPSBhd2FpdCBsb2FkSW1hZ2VCaXRtYXAoXHJcbiAgICAgIHRoaXMuZ2VvbWV0cmllc1swXS50ZXh0dXJlcy5vY2NsdXNpb25VUklcclxuICAgICk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgICAgY29uc3QgbWlwSW5kZXggPSBpICYgMSA/IDEgOiAwO1xyXG4gICAgICBjb25zdCByZW5kZXJQaXBlbGluZUluZGV4ID0gaSAmIDIgPyAxIDogMDtcclxuXHJcbiAgICAgIGNvbnN0IGJhc2VDb2xvck1pcExldmVsQ291bnQgPSBtaXBJbmRleFxyXG4gICAgICAgID8gY2FsY3VsYXRlTWlwTGV2ZWxDb3VudChcclxuICAgICAgICAgICAgYmFzZUNvbG9ySW1hZ2VCaXRtYXAud2lkdGgsXHJcbiAgICAgICAgICAgIGJhc2VDb2xvckltYWdlQml0bWFwLmhlaWdodFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDogMTtcclxuICAgICAgY29uc3QgYmFzZUNvbG9yVGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZShcclxuICAgICAgICBgR1BVIFRleHR1cmU6IEJhc2UgQ29sb3IgJHttaXBJbmRleCAmJiBcIndpdGggTWlwbWFwc1wifWAsXHJcbiAgICAgICAgYmFzZUNvbG9ySW1hZ2VCaXRtYXAsXHJcbiAgICAgICAgYmFzZUNvbG9yTWlwTGV2ZWxDb3VudFxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBiYXNlQ29sb3JUZXh0dXJlVmlldyA9IGJhc2VDb2xvclRleHR1cmUuY3JlYXRlVmlldyh7XHJcbiAgICAgICAgbGFiZWw6IGBHUFUgVGV4dHVyZSBWaWV3OiBCYXNlIENvbG9yICR7bWlwSW5kZXggJiYgXCJ3aXRoIE1pcG1hcHNcIn1gLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzTWlwTGV2ZWxDb3VudCA9IG1pcEluZGV4XHJcbiAgICAgICAgPyBjYWxjdWxhdGVNaXBMZXZlbENvdW50KFxyXG4gICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc0ltYWdlQml0bWFwLndpZHRoLFxyXG4gICAgICAgICAgICBtZXRhbGxpY1JvdWdobmVzc0ltYWdlQml0bWFwLmhlaWdodFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDogMTtcclxuICAgICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlKFxyXG4gICAgICAgIGBHUFUgVGV4dHVyZTogTWV0YWxsaWMgUm91Z2huZXNzICR7bWlwSW5kZXggJiYgXCJ3aXRoIE1pcG1hcHNcIn1gLFxyXG4gICAgICAgIG1ldGFsbGljUm91Z2huZXNzSW1hZ2VCaXRtYXAsXHJcbiAgICAgICAgbWV0YWxsaWNSb3VnaG5lc3NNaXBMZXZlbENvdW50XHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZVZpZXcgPSBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUuY3JlYXRlVmlldyh7XHJcbiAgICAgICAgbGFiZWw6IGBHUFUgVGV4dHVyZSBWaWV3OiBNZXRhbGxpYyBSb3VnaG5lc3MgJHttaXBJbmRleCAmJiBcIndpdGggTWlwbWFwc1wifWAsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3Qgbm9yYW1sTWlwTGV2ZWxDb3VudCA9IG1pcEluZGV4XHJcbiAgICAgICAgPyBjYWxjdWxhdGVNaXBMZXZlbENvdW50KFxyXG4gICAgICAgICAgICBub3JtYWxJbWFnZUJpdG1hcC53aWR0aCxcclxuICAgICAgICAgICAgbm9ybWFsSW1hZ2VCaXRtYXAuaGVpZ2h0XHJcbiAgICAgICAgICApXHJcbiAgICAgICAgOiAxO1xyXG4gICAgICBjb25zdCBub3JtYWxUZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlKFxyXG4gICAgICAgIGBHUFUgVGV4dHVyZTogTm9yYW1sICR7bWlwSW5kZXggJiYgXCJ3aXRoIE1pcG1hcHNcIn1gLFxyXG4gICAgICAgIG5vcm1hbEltYWdlQml0bWFwLFxyXG4gICAgICAgIG5vcmFtbE1pcExldmVsQ291bnRcclxuICAgICAgKTtcclxuICAgICAgY29uc3Qgbm9ybWFsVGV4dHVyZVZpZXcgPSBub3JtYWxUZXh0dXJlLmNyZWF0ZVZpZXcoe1xyXG4gICAgICAgIGxhYmVsOiBgR1BVIFRleHR1cmUgVmlldzogTm9yYW1sICR7bWlwSW5kZXggJiYgXCJ3aXRoIE1pcG1hcHNcIn1gLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGVtaXNzaXZlTWlwTGV2ZWxDb3VudCA9IG1pcEluZGV4XHJcbiAgICAgICAgPyBjYWxjdWxhdGVNaXBMZXZlbENvdW50KFxyXG4gICAgICAgICAgICBlbWlzc2l2ZUltYWdlQml0bWFwLndpZHRoLFxyXG4gICAgICAgICAgICBlbWlzc2l2ZUltYWdlQml0bWFwLmhlaWdodFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDogMTtcclxuICAgICAgY29uc3QgZW1pc3NpdmVUZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlKFxyXG4gICAgICAgIGBHUFUgVGV4dHVyZTogRW1pc3NpdmUgJHttaXBJbmRleCAmJiBcIndpdGggTWlwbWFwc1wifWAsXHJcbiAgICAgICAgZW1pc3NpdmVJbWFnZUJpdG1hcCxcclxuICAgICAgICBlbWlzc2l2ZU1pcExldmVsQ291bnRcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgZW1pc3NpdmVUZXh0dXJlVmlldyA9IGVtaXNzaXZlVGV4dHVyZS5jcmVhdGVWaWV3KHtcclxuICAgICAgICBsYWJlbDogYEdQVSBUZXh0dXJlIFZpZXc6IEVtaXNzaXZlICR7bWlwSW5kZXggJiYgXCJ3aXRoIE1pcG1hcHNcIn1gLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IG9jY2x1c2lvbk1pcExldmVsQ291bnQgPSBtaXBJbmRleFxyXG4gICAgICAgID8gY2FsY3VsYXRlTWlwTGV2ZWxDb3VudChcclxuICAgICAgICAgICAgb2NjbHVzaW9uSW1hZ2VCaXRtYXAud2lkdGgsXHJcbiAgICAgICAgICAgIG9jY2x1c2lvbkltYWdlQml0bWFwLmhlaWdodFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDogMTtcclxuICAgICAgY29uc3Qgb2NjbHVzaW9uVGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZTJERnJvbVNvdXJjZShcclxuICAgICAgICBgR1BVIFRleHR1cmU6IE9jY2x1c2lvbiAke21pcEluZGV4ICYmIFwid2l0aCBNaXBtYXBzXCJ9YCxcclxuICAgICAgICBvY2NsdXNpb25JbWFnZUJpdG1hcCxcclxuICAgICAgICBvY2NsdXNpb25NaXBMZXZlbENvdW50XHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IG9jY2x1c2lvblRleHR1cmVWaWV3ID0gb2NjbHVzaW9uVGV4dHVyZS5jcmVhdGVWaWV3KHtcclxuICAgICAgICBsYWJlbDogYEdQVSBUZXh0dXJlIFZpZXc6IE9jY2x1c2lvbiAke21pcEluZGV4ICYmIFwid2l0aCBNaXBtYXBzXCJ9YCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBiaW5kR3JvdXAgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xyXG4gICAgICAgIGxhYmVsOiBgR1BVIEJpbmQgR3JvdXAgMTogTWF0ZXJpYWwgJHtcclxuICAgICAgICAgIG1pcEluZGV4ICYmIFwid2l0aCBNaXBtYXBzXCJcclxuICAgICAgICB9ICR7cmVuZGVyUGlwZWxpbmVJbmRleCAmJiBcIndpdGggTVNBQVwifWAsXHJcbiAgICAgICAgbGF5b3V0OiB0aGlzLnJlbmRlclBpcGVsaW5lc1tyZW5kZXJQaXBlbGluZUluZGV4XS5nZXRCaW5kR3JvdXBMYXlvdXQoMSksXHJcbiAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgICByZXNvdXJjZTogYmFzZUNvbG9yVGV4dHVyZVZpZXcsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nOiAxLFxyXG4gICAgICAgICAgICByZXNvdXJjZTogbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlVmlldyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmc6IDIsXHJcbiAgICAgICAgICAgIHJlc291cmNlOiBub3JtYWxUZXh0dXJlVmlldyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmc6IDMsXHJcbiAgICAgICAgICAgIHJlc291cmNlOiB7XHJcbiAgICAgICAgICAgICAgYnVmZmVyOiBlbWlzc2l2ZUJ1ZmZlcixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmc6IDQsXHJcbiAgICAgICAgICAgIHJlc291cmNlOiBlbWlzc2l2ZVRleHR1cmVWaWV3LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZzogNSxcclxuICAgICAgICAgICAgcmVzb3VyY2U6IG9jY2x1c2lvblRleHR1cmVWaWV3LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5iaW5kR3JvdXBzWzFdLnB1c2goYmluZEdyb3VwKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7ICsraSkge1xyXG4gICAgICBjb25zdCBtaXBJbmRleCA9IGkgJiAxID8gMSA6IDA7XHJcbiAgICAgIGNvbnN0IHJlbmRlclBpcGVsaW5lSW5kZXggPSBpICYgMiA/IDEgOiAwO1xyXG4gICAgICBjb25zdCBza3lib3hJbmRleCA9IGkgJiA0ID8gMSA6IDA7XHJcblxyXG4gICAgICBsZXQgY3ViZVRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmVDdWJlRnJvbUhEUih0aGlzLmhkcnNbc2t5Ym94SW5kZXhdKTtcclxuICAgICAgY3ViZVRleHR1cmUgPSB0aGlzLmdlbmVyYXRlSXJyYWRpYW5jZU1hcCgpKHRoaXMuZGV2aWNlLCBjdWJlVGV4dHVyZSwgMzIpO1xyXG5cclxuICAgICAgY29uc3QgY3ViZVRleHR1cmVWaWV3ID0gY3ViZVRleHR1cmUuY3JlYXRlVmlldyh7XHJcbiAgICAgICAgbGFiZWw6IGBHUFUgVGV4dHVyZSBWaWV3OiBDdWJlICR7c2t5Ym94SW5kZXh9YCxcclxuICAgICAgICBkaW1lbnNpb246IFwiY3ViZVwiLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGJpbmRHcm91cCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgICAgbGFiZWw6IGBHUFUgQmluZCBHcm91cCAyOiBDdWJlICR7bWlwSW5kZXggJiYgXCJ3aXRoIE1pcG1hcHNcIn0gJHtcclxuICAgICAgICAgIHJlbmRlclBpcGVsaW5lSW5kZXggJiYgXCJ3aXRoIE1TQUFcIlxyXG4gICAgICAgIH1gLFxyXG4gICAgICAgIGxheW91dDogdGhpcy5yZW5kZXJQaXBlbGluZXNbcmVuZGVyUGlwZWxpbmVJbmRleF0uZ2V0QmluZEdyb3VwTGF5b3V0KDIpLFxyXG4gICAgICAgIGVudHJpZXM6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgcmVzb3VyY2U6IGN1YmVUZXh0dXJlVmlldyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuYmluZEdyb3Vwc1syXS5wdXNoKGJpbmRHcm91cCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSB7XHJcbiAgICAgIGNvbnN0IHNhbXBsZXIyRCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe1xyXG4gICAgICAgIGxhYmVsOiBgR1BVIFNhbXBsZXI6IFNhbXBsZXIgMkQgJHtpfWAsXHJcbiAgICAgICAgYWRkcmVzc01vZGVVOiBpICYgMSA/IFwicmVwZWF0XCIgOiBcImNsYW1wLXRvLWVkZ2VcIixcclxuICAgICAgICBhZGRyZXNzTW9kZVY6IGkgJiAyID8gXCJyZXBlYXRcIiA6IFwiY2xhbXAtdG8tZWRnZVwiLFxyXG4gICAgICAgIG1hZ0ZpbHRlcjogaSAmIDQgPyBcImxpbmVhclwiIDogXCJuZWFyZXN0XCIsXHJcbiAgICAgICAgbWluRmlsdGVyOiBpICYgOCA/IFwibGluZWFyXCIgOiBcIm5lYXJlc3RcIixcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBzYW1wbGVyQ3ViZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe1xyXG4gICAgICAgIGxhYmVsOiBgR1BVIFNhbXBsZXI6IFNhbXBsZXIgQ3ViZSAke2l9YCxcclxuICAgICAgICBhZGRyZXNzTW9kZVU6IFwiY2xhbXAtdG8tZWRnZVwiLFxyXG4gICAgICAgIGFkZHJlc3NNb2RlVjogXCJjbGFtcC10by1lZGdlXCIsXHJcbiAgICAgICAgYWRkcmVzc01vZGVXOiBcImNsYW1wLXRvLWVkZ2VcIixcclxuICAgICAgICBtYWdGaWx0ZXI6IFwibmVhcmVzdFwiLFxyXG4gICAgICAgIG1pbkZpbHRlcjogXCJuZWFyZXN0XCIsXHJcbiAgICAgICAgbWlwbWFwRmlsdGVyOiBcIm5lYXJlc3RcIixcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCByZW5kZXJQaXBlbGluZUluZGV4ID0gaSAmIDE2ID8gMSA6IDA7XHJcbiAgICAgIGNvbnN0IGJpbmRHcm91cCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgICAgbGFiZWw6IGBHUFUgQmluZCBHcm91cCAzIDogU2FtcGxlciAke2l9LCAke1xyXG4gICAgICAgICAgcmVuZGVyUGlwZWxpbmVJbmRleCAmJiBcIndpdGggTVNBQVwiXHJcbiAgICAgICAgfWAsXHJcbiAgICAgICAgbGF5b3V0OiB0aGlzLnJlbmRlclBpcGVsaW5lc1tyZW5kZXJQaXBlbGluZUluZGV4XS5nZXRCaW5kR3JvdXBMYXlvdXQoMyksXHJcbiAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgICByZXNvdXJjZTogc2FtcGxlcjJELFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgICAgcmVzb3VyY2U6IHNhbXBsZXJDdWJlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5iaW5kR3JvdXBzWzNdLnB1c2goYmluZEdyb3VwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlU2t5Ym94UmVuZGVyUGlwZWxpbmUoKTogdm9pZCB7XHJcbiAgICBjb25zdCBza3lib3hTaGFkZXJNb2R1bGUgPSB0aGlzLmNyZWF0ZVNoYWRlck1vZHVsZShcclxuICAgICAgXCJHUFUgU2hhZGVyIE1vZHVsZTogU2t5Ym94XCIsXHJcbiAgICAgIHNreWJveFNoYWRlckNvZGVcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgYmluZEdyb3VwTGF5b3V0MCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XHJcbiAgICAgIGxhYmVsOiBcIkdQVSBCaW5kIEdyb3VwIDAgTGF5b3V0OiBTa3lib3hcIixcclxuICAgICAgZW50cmllczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5GUkFHTUVOVCxcclxuICAgICAgICAgIGJ1ZmZlcjoge1xyXG4gICAgICAgICAgICB0eXBlOiBcInVuaWZvcm1cIiBhcyBHUFVCdWZmZXJCaW5kaW5nVHlwZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBiaW5kaW5nOiAxLFxyXG4gICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXHJcbiAgICAgICAgICBzYW1wbGVyOiB7IHR5cGU6IFwibm9uLWZpbHRlcmluZ1wiIGFzIEdQVVNhbXBsZXJCaW5kaW5nVHlwZSB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGJpbmRHcm91cExheW91dDEgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXBMYXlvdXQoe1xyXG4gICAgICBsYWJlbDogXCJHUFUgQmluZCBHcm91cCAxIExheW91dDogU2t5Ym94XCIsXHJcbiAgICAgIGVudHJpZXM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQsXHJcbiAgICAgICAgICB0ZXh0dXJlOiB7XHJcbiAgICAgICAgICAgIHNhbXBsZVR5cGU6IFwidW5maWx0ZXJhYmxlLWZsb2F0XCIgYXMgR1BVVGV4dHVyZVNhbXBsZVR5cGUsXHJcbiAgICAgICAgICAgIHZpZXdEaW1lbnNpb246IFwiY3ViZVwiIGFzIEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLFxyXG4gICAgICAgICAgICBtdWx0aXNhbXBsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBza3lib3hSZW5kZXJQaXBlbGluZUxheW91dCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVBpcGVsaW5lTGF5b3V0KHtcclxuICAgICAgbGFiZWw6IFwiR1BVIFJlbmRlciBQaXBlbGluZSBMYXlvdXQ6IFNreWJveFwiLFxyXG4gICAgICBiaW5kR3JvdXBMYXlvdXRzOiBbYmluZEdyb3VwTGF5b3V0MCwgYmluZEdyb3VwTGF5b3V0MV0sXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHNreWJveFJlbmRlclBpcGVsaW5lRGVzY3JpcHRvcjogR1BVUmVuZGVyUGlwZWxpbmVEZXNjcmlwdG9yID0ge1xyXG4gICAgICBsYWJlbDogYEdQVSBSZW5kZXIgUGlwZWxpbmU6IFNreWJveGAsXHJcbiAgICAgIGxheW91dDogc2t5Ym94UmVuZGVyUGlwZWxpbmVMYXlvdXQsXHJcbiAgICAgIHZlcnRleDoge1xyXG4gICAgICAgIG1vZHVsZTogc2t5Ym94U2hhZGVyTW9kdWxlLFxyXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwidnNfbWFpblwiLFxyXG4gICAgICB9LFxyXG4gICAgICBkZXB0aFN0ZW5jaWw6IHtcclxuICAgICAgICBmb3JtYXQ6IFwiZGVwdGgyNHBsdXNcIixcclxuICAgICAgICBkZXB0aFdyaXRlRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBkZXB0aENvbXBhcmU6IFwibGVzcy1lcXVhbFwiLFxyXG4gICAgICB9LFxyXG4gICAgICBtdWx0aXNhbXBsZToge1xyXG4gICAgICAgIGNvdW50OiAxLFxyXG4gICAgICB9LFxyXG4gICAgICBmcmFnbWVudDoge1xyXG4gICAgICAgIG1vZHVsZTogc2t5Ym94U2hhZGVyTW9kdWxlLFxyXG4gICAgICAgIGVudHJ5UG9pbnQ6IFwiZnNfbWFpblwiLFxyXG4gICAgICAgIHRhcmdldHM6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnByZXNlbnRhdGlvbkZvcm1hdCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcclxuICAgICAgaWYgKGkpIHtcclxuICAgICAgICBza3lib3hSZW5kZXJQaXBlbGluZURlc2NyaXB0b3IubGFiZWwgPSBcIkdQVSBSZW5kZXIgUGlwZWxpbmUgd2l0aCBNU0FBXCI7XHJcbiAgICAgICAgc2t5Ym94UmVuZGVyUGlwZWxpbmVEZXNjcmlwdG9yLm11bHRpc2FtcGxlLmNvdW50ID0gNDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5za3lib3hSZW5kZXJQaXBlbGluZXNbaV0gPSB0aGlzLmRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZShcclxuICAgICAgICBza3lib3hSZW5kZXJQaXBlbGluZURlc2NyaXB0b3JcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlU2t5Ym94VW5pZm9ybUJ1ZmZlcigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRoaXMuc2t5Ym94VW5pZm9ybUJ1ZmZlciA9IHRoaXMuY3JlYXRlQnVmZmVyKFxyXG4gICAgICBgR1BVIFVuaWZvcm0gQnVmZmVyOiBTa3lib3hgLFxyXG4gICAgICA0ICogNCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHNreWJveFNhbXBsZXIgPSB0aGlzLmRldmljZS5jcmVhdGVTYW1wbGVyKHtcclxuICAgICAgbGFiZWw6IFwiR1BVIFNhbXBsZXI6IFNreWJveFwiLFxyXG4gICAgICBhZGRyZXNzTW9kZVU6IFwiY2xhbXAtdG8tZWRnZVwiLFxyXG4gICAgICBhZGRyZXNzTW9kZVY6IFwiY2xhbXAtdG8tZWRnZVwiLFxyXG4gICAgICBhZGRyZXNzTW9kZVc6IFwiY2xhbXAtdG8tZWRnZVwiLFxyXG4gICAgICBtYWdGaWx0ZXI6IFwibmVhcmVzdFwiLFxyXG4gICAgICBtaW5GaWx0ZXI6IFwibmVhcmVzdFwiLFxyXG4gICAgICBtaXBtYXBGaWx0ZXI6IFwibmVhcmVzdFwiLFxyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcclxuICAgICAgY29uc3QgYmluZEdyb3VwID0gdGhpcy5kZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcclxuICAgICAgICBsYWJlbDogYEdQVSBCaW5kIEdyb3VwOiBTa3lib3ggTWF0cml4LCBTYW1wbGVyICR7aSAmJiBcIndpdGggTVNBQVwifWAsXHJcbiAgICAgICAgbGF5b3V0OiB0aGlzLnNreWJveFJlbmRlclBpcGVsaW5lc1tpXS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksXHJcbiAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgICByZXNvdXJjZToge1xyXG4gICAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5za3lib3hVbmlmb3JtQnVmZmVyLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgICAgcmVzb3VyY2U6IHNreWJveFNhbXBsZXIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnNreWJveEJpbmRHcm91cHNbMF0ucHVzaChiaW5kR3JvdXApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNreWJveFRleHR1cmVWaWV3cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcclxuICAgICAgY29uc3Qgc2t5Ym94VGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZUN1YmVGcm9tSERSKHRoaXMuaGRyc1tpXSk7XHJcblxyXG4gICAgICBza3lib3hUZXh0dXJlVmlld3MucHVzaChcclxuICAgICAgICBza3lib3hUZXh0dXJlLmNyZWF0ZVZpZXcoe1xyXG4gICAgICAgICAgbGFiZWw6IGBHUFUgVGV4dHVyZSBWaWV3OiBTa3lib3ggJHtpfWAsXHJcbiAgICAgICAgICBkaW1lbnNpb246IFwiY3ViZVwiLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgICAgY29uc3QgcmVuZGVyUGlwZWxpbmVJbmRleCA9IGkgJiAxID8gMSA6IDA7XHJcbiAgICAgIGNvbnN0IHNreWJveEluZGV4ID0gaSAmIDIgPyAxIDogMDtcclxuXHJcbiAgICAgIGNvbnN0IGJpbmRHcm91cCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgICAgbGFiZWw6IGBHUFUgQmluZCBHcm91cDogU2t5Ym94IFRleHR1cmUgJHtcclxuICAgICAgICAgIHJlbmRlclBpcGVsaW5lSW5kZXggJiYgXCJ3aXRoIE1TQUFcIlxyXG4gICAgICAgIH1gLFxyXG4gICAgICAgIGxheW91dDpcclxuICAgICAgICAgIHRoaXMuc2t5Ym94UmVuZGVyUGlwZWxpbmVzW3JlbmRlclBpcGVsaW5lSW5kZXhdLmdldEJpbmRHcm91cExheW91dCgxKSxcclxuICAgICAgICBlbnRyaWVzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgIHJlc291cmNlOiBza3lib3hUZXh0dXJlVmlld3Nbc2t5Ym94SW5kZXhdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5za3lib3hCaW5kR3JvdXBzWzFdLnB1c2goYmluZEdyb3VwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlU2hhZGVyTW9kdWxlKGxhYmVsOiBzdHJpbmcsIGNvZGU6IHN0cmluZyk6IEdQVVNoYWRlck1vZHVsZSB7XHJcbiAgICBjb25zdCBzaGFkZXJNb2R1bGUgPSB0aGlzLmRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe1xyXG4gICAgICBsYWJlbCxcclxuICAgICAgY29kZSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBzaGFkZXJNb2R1bGU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZUJ1ZmZlcihcclxuICAgIGxhYmVsOiBzdHJpbmcsXHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICB1c2FnZTogR1BVQnVmZmVyVXNhZ2VGbGFnc1xyXG4gICk6IEdQVUJ1ZmZlciB7XHJcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe1xyXG4gICAgICBsYWJlbCxcclxuICAgICAgc2l6ZSxcclxuICAgICAgdXNhZ2UsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVUZXh0dXJlMkRGcm9tU291cmNlKFxyXG4gICAgbGFiZWw6IHN0cmluZyxcclxuICAgIHNvdXJjZTogR1BVSW1hZ2VDb3B5RXh0ZXJuYWxJbWFnZVNvdXJjZSxcclxuICAgIG1pcExldmVsQ291bnQ6IG51bWJlclxyXG4gICk6IEdQVVRleHR1cmUge1xyXG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XHJcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xyXG4gICAgICB3aWR0aCA9IHNvdXJjZS52aWRlb1dpZHRoO1xyXG4gICAgICBoZWlnaHQgPSBzb3VyY2UudmlkZW9IZWlnaHQ7XHJcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFZpZGVvRnJhbWUpIHtcclxuICAgICAgd2lkdGggPSBzb3VyY2UuY29kZWRXaWR0aDtcclxuICAgICAgaGVpZ2h0ID0gc291cmNlLmNvZGVkSGVpZ2h0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2lkdGggPSBzb3VyY2Uud2lkdGg7XHJcbiAgICAgIGhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xyXG4gICAgICBsYWJlbCxcclxuICAgICAgZm9ybWF0OiBcInJnYmE4dW5vcm1cIixcclxuICAgICAgbWlwTGV2ZWxDb3VudCxcclxuICAgICAgc2l6ZTogW3dpZHRoLCBoZWlnaHRdLFxyXG4gICAgICB1c2FnZTpcclxuICAgICAgICBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHxcclxuICAgICAgICBHUFVUZXh0dXJlVXNhZ2UuQ09QWV9EU1QgfFxyXG4gICAgICAgIEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuY29weVNvdXJjZVRvVGV4dHVyZSh0aGlzLmRldmljZSwgc291cmNlLCB0ZXh0dXJlKTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlVGV4dHVyZUN1YmVGcm9tSERSKGhkcjogSERSKTogR1BVVGV4dHVyZSB7XHJcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nZW5lcmF0ZUN1YmVtYXAoKSh0aGlzLmRldmljZSwgaGRyLCAxNDQwKTtcclxuXHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY29weVNvdXJjZVRvVGV4dHVyZShcclxuICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgc291cmNlOiBHUFVJbWFnZUNvcHlFeHRlcm5hbEltYWdlU291cmNlLFxyXG4gICAgdGV4dHVyZTogR1BVVGV4dHVyZVxyXG4gICk6IHZvaWQge1xyXG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XHJcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xyXG4gICAgICB3aWR0aCA9IHNvdXJjZS52aWRlb1dpZHRoO1xyXG4gICAgICBoZWlnaHQgPSBzb3VyY2UudmlkZW9IZWlnaHQ7XHJcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFZpZGVvRnJhbWUpIHtcclxuICAgICAgd2lkdGggPSBzb3VyY2UuY29kZWRXaWR0aDtcclxuICAgICAgaGVpZ2h0ID0gc291cmNlLmNvZGVkSGVpZ2h0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2lkdGggPSBzb3VyY2Uud2lkdGg7XHJcbiAgICAgIGhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZGV2aWNlLnF1ZXVlLmNvcHlFeHRlcm5hbEltYWdlVG9UZXh0dXJlKFxyXG4gICAgICB7IHNvdXJjZSB9LFxyXG4gICAgICB7IHRleHR1cmUgfSxcclxuICAgICAgeyB3aWR0aCwgaGVpZ2h0IH1cclxuICAgICk7XHJcblxyXG4gICAgaWYgKHRleHR1cmUubWlwTGV2ZWxDb3VudCA+IDEpIHtcclxuICAgICAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMoKShkZXZpY2UsIHRleHR1cmUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZU1pcG1hcHMoKTogKGQ6IEdQVURldmljZSwgdDogR1BVVGV4dHVyZSkgPT4gdm9pZCB7XHJcbiAgICBsZXQgc2FtcGxlcjogR1BVU2FtcGxlcjtcclxuICAgIGxldCBtb2R1bGU6IEdQVVNoYWRlck1vZHVsZTtcclxuICAgIGNvbnN0IHBpcGVsaW5lQnlGb3JtYXQgPSBuZXcgTWFwPEdQVVRleHR1cmVGb3JtYXQsIEdQVVJlbmRlclBpcGVsaW5lPigpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZU1pcG1hcHMoZGV2aWNlOiBHUFVEZXZpY2UsIHRleHR1cmU6IEdQVVRleHR1cmUpIHtcclxuICAgICAgaWYgKCFtb2R1bGUpIHtcclxuICAgICAgICBtb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcclxuICAgICAgICAgIGxhYmVsOiBcIkdQVSBTaGFkZXIgTW9kdWxlOiBNaXBtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgICAgY29kZTogbWlwbWFwU2hhZGVyQ29kZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzYW1wbGVyID0gZGV2aWNlLmNyZWF0ZVNhbXBsZXIoe1xyXG4gICAgICAgICAgbWluRmlsdGVyOiBcImxpbmVhclwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXBpcGVsaW5lQnlGb3JtYXQuaGFzKHRleHR1cmUuZm9ybWF0KSkge1xyXG4gICAgICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKHtcclxuICAgICAgICAgIGxhYmVsOiBcIkdQVSBSZW5kZXIgUGlwZWxpbmU6IE1pcG1hcCBHZW5lcmF0aW9uIFwiLFxyXG4gICAgICAgICAgbGF5b3V0OiBcImF1dG9cIixcclxuICAgICAgICAgIHZlcnRleDoge1xyXG4gICAgICAgICAgICBtb2R1bGU6IG1vZHVsZSxcclxuICAgICAgICAgICAgZW50cnlQb2ludDogXCJ2c19tYWluXCIsXHJcbiAgICAgICAgICAgIGJ1ZmZlcnM6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVN0cmlkZTogKDQgKyAyKSAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAgICAgICAgIHN0ZXBNb2RlOiBcInZlcnRleFwiIGFzIEdQVVZlcnRleFN0ZXBNb2RlLFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcImZsb2F0MzJ4NFwiIGFzIEdQVVZlcnRleEZvcm1hdCxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZGVyTG9jYXRpb246IDAsXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIgYXMgR1BVVmVydGV4Rm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogNCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJMb2NhdGlvbjogMSxcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBwcmltaXRpdmU6IHtcclxuICAgICAgICAgICAgdG9wb2xvZ3k6IFwidHJpYW5nbGUtbGlzdFwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZyYWdtZW50OiB7XHJcbiAgICAgICAgICAgIG1vZHVsZSxcclxuICAgICAgICAgICAgZW50cnlQb2ludDogXCJmc19tYWluXCIsXHJcbiAgICAgICAgICAgIHRhcmdldHM6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHRleHR1cmUuZm9ybWF0LFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBpcGVsaW5lQnlGb3JtYXQuc2V0KHRleHR1cmUuZm9ybWF0LCBwaXBlbGluZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHBpcGVsaW5lID0gcGlwZWxpbmVCeUZvcm1hdC5nZXQodGV4dHVyZS5mb3JtYXQpO1xyXG5cclxuICAgICAgLy8gdmVydGV4IGJ1ZmZlclxyXG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcclxuICAgICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAtMS4wLCAgMS4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsXHJcbiAgICAgICAgLTEuMCwgLTEuMCwgMC4wLCAxLjAsIDAuMCwgMS4wLCBcclxuICAgICAgICAgMS4wLCAgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIFxyXG4gICAgICAgICAxLjAsIC0xLjAsIDAuMCwgMS4wLCAxLjAsIDEuMCxcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlcihcclxuICAgICAgICBcIkdQVSBCdWZmZXI6IE1pcG1hcHMgR2VuZXJhdGlvbiBWZXJ0ZXhcIixcclxuICAgICAgICB2ZXJ0aWNlcy5ieXRlTGVuZ3RoLFxyXG4gICAgICAgIEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBkZXZpY2UucXVldWUud3JpdGVCdWZmZXIoXHJcbiAgICAgICAgdmVydGV4QnVmZmVyLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgdmVydGljZXMuYnVmZmVyLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgdmVydGljZXMuYnl0ZUxlbmd0aFxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gaW5kZXggYnVmZmVyXHJcbiAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoWzAsIDEsIDIsIDIsIDEsIDNdKTtcclxuXHJcbiAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoXHJcbiAgICAgICAgXCJHUFUgQnVmZmVyOiBNaXBtYXAgR2VuZXJhdGlvbiBJbmRleCBcIixcclxuICAgICAgICBpbmRpY2VzLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgR1BVQnVmZmVyVXNhZ2UuSU5ERVggfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVFxyXG4gICAgICApO1xyXG5cclxuICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxyXG4gICAgICAgIGluZGV4QnVmZmVyLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgaW5kaWNlcy5idWZmZXIsXHJcbiAgICAgICAgMCxcclxuICAgICAgICBpbmRpY2VzLmJ5dGVMZW5ndGhcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoe1xyXG4gICAgICAgIGxhYmVsOiBcIkdQVSBDb21tYW5kIEVuY29kZXI6IE1pcG1hcCBHZW5lcmF0aW9uXCIsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbGV0IHdpZHRoID0gdGV4dHVyZS53aWR0aDtcclxuICAgICAgbGV0IGhlaWdodCA9IHRleHR1cmUuaGVpZ2h0O1xyXG4gICAgICBsZXQgYmFzZU1pcExldmVsID0gMDtcclxuICAgICAgd2hpbGUgKHdpZHRoID4gMSB8fCBoZWlnaHQgPiAxKSB7XHJcbiAgICAgICAgd2lkdGggPSBNYXRoLm1heCgxLCAod2lkdGggLyAyKSB8IDApO1xyXG4gICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDEsIChoZWlnaHQgLyAyKSB8IDApO1xyXG5cclxuICAgICAgICBpZiAoMSA9PSB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycykge1xyXG4gICAgICAgICAgY29uc3QgYmluZEdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgICAgICAgIGxhYmVsOiBcIkdQVSBCaW5kIEdyb3VwOiBNaXBtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IHBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxcclxuICAgICAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogc2FtcGxlcixcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJpbmRpbmc6IDEsXHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZTogdGV4dHVyZS5jcmVhdGVWaWV3KHtcclxuICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiR1BVIFRleHR1cmUgVmlldzogTWlwbWFwIEdlbmVyYXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgYmFzZU1pcExldmVsLFxyXG4gICAgICAgICAgICAgICAgICBtaXBMZXZlbENvdW50OiAxLFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICsrYmFzZU1pcExldmVsO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGNvbG9yQXR0YWNobWVudHM6IEdQVVJlbmRlclBhc3NDb2xvckF0dGFjaG1lbnRbXSA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIHZpZXc6IHRleHR1cmUuY3JlYXRlVmlldyh7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZSBWaWV3OiBNaXBtYXAgR2VuZXJhdGlvbiBSZW5kZXIgVGFyZ2V0XCIsXHJcbiAgICAgICAgICAgICAgICBiYXNlTWlwTGV2ZWwsXHJcbiAgICAgICAgICAgICAgICBtaXBMZXZlbENvdW50OiAxLFxyXG4gICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgIGxvYWRPcDogXCJjbGVhclwiLFxyXG4gICAgICAgICAgICAgIHN0b3JlT3A6IFwic3RvcmVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgY29uc3QgcGFzc0Rlc2NyaXB0b3I6IEdQVVJlbmRlclBhc3NEZXNjcmlwdG9yID0ge1xyXG4gICAgICAgICAgICBsYWJlbDogXCJHUFUgUmVuZGVyIFBhc3MgRGVzY3JpcHRvcjogTWlwbWFwIEdlbmVyYXRpb25cIixcclxuICAgICAgICAgICAgY29sb3JBdHRhY2htZW50cyxcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgY29uc3QgcGFzcyA9IGVuY29kZXIuYmVnaW5SZW5kZXJQYXNzKHBhc3NEZXNjcmlwdG9yKTtcclxuICAgICAgICAgIHBhc3Muc2V0UGlwZWxpbmUocGlwZWxpbmUpO1xyXG4gICAgICAgICAgcGFzcy5zZXRWZXJ0ZXhCdWZmZXIoMCwgdmVydGV4QnVmZmVyKTtcclxuICAgICAgICAgIHBhc3Muc2V0SW5kZXhCdWZmZXIoaW5kZXhCdWZmZXIsIFwidWludDMyXCIpO1xyXG4gICAgICAgICAgcGFzcy5zZXRCaW5kR3JvdXAoMCwgYmluZEdyb3VwKTtcclxuICAgICAgICAgIHBhc3MuZHJhd0luZGV4ZWQoNik7XHJcbiAgICAgICAgICBwYXNzLmVuZCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoNiA9PSB0ZXh0dXJlLmRlcHRoT3JBcnJheUxheWVycykge1xyXG4gICAgICAgICAgZm9yIChsZXQgbGF5ZXIgPSAwOyBsYXllciA8IHRleHR1cmUuZGVwdGhPckFycmF5TGF5ZXJzOyArK2xheWVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJpbmRHcm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xyXG4gICAgICAgICAgICAgIGxhYmVsOiBcIkdQVSBCaW5kIEdyb3VwOiBNaXBtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgICAgICAgIGxheW91dDogcGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLFxyXG4gICAgICAgICAgICAgIGVudHJpZXM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgICAgICAgcmVzb3VyY2U6IHNhbXBsZXIsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxyXG4gICAgICAgICAgICAgICAgICByZXNvdXJjZTogdGV4dHVyZS5jcmVhdGVWaWV3KHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZSBWaWV3OiBNaXBtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogXCIyZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VNaXBMZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICBtaXBMZXZlbENvdW50OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VBcnJheUxheWVyOiBsYXllcixcclxuICAgICAgICAgICAgICAgICAgICBhcnJheUxheWVyQ291bnQ6IDEsXHJcbiAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yQXR0YWNobWVudHM6IEdQVVJlbmRlclBhc3NDb2xvckF0dGFjaG1lbnRbXSA9IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2aWV3OiB0ZXh0dXJlLmNyZWF0ZVZpZXcoe1xyXG4gICAgICAgICAgICAgICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZSBWaWV3OiBNaXBtYXAgR2VuZXJhdGlvbiBSZW5kZXIgVGFyZ2V0XCIsXHJcbiAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogXCIyZFwiLFxyXG4gICAgICAgICAgICAgICAgICBiYXNlTWlwTGV2ZWw6IGJhc2VNaXBMZXZlbCArIDEsXHJcbiAgICAgICAgICAgICAgICAgIG1pcExldmVsQ291bnQ6IDEsXHJcbiAgICAgICAgICAgICAgICAgIGJhc2VBcnJheUxheWVyOiBsYXllcixcclxuICAgICAgICAgICAgICAgICAgYXJyYXlMYXllckNvdW50OiAxLFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICBsb2FkT3A6IFwiY2xlYXJcIixcclxuICAgICAgICAgICAgICAgIHN0b3JlT3A6IFwic3RvcmVcIixcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcGFzc0Rlc2NyaXB0b3I6IEdQVVJlbmRlclBhc3NEZXNjcmlwdG9yID0ge1xyXG4gICAgICAgICAgICAgIGxhYmVsOiBcIkdQVSBSZW5kZXIgUGFzcyBEZXNjcmlwdG9yOiBNaXBtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgICAgICAgIGNvbG9yQXR0YWNobWVudHMsXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3MocGFzc0Rlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICBwYXNzLnNldFBpcGVsaW5lKHBpcGVsaW5lKTtcclxuICAgICAgICAgICAgcGFzcy5zZXRWZXJ0ZXhCdWZmZXIoMCwgdmVydGV4QnVmZmVyKTtcclxuICAgICAgICAgICAgcGFzcy5zZXRJbmRleEJ1ZmZlcihpbmRleEJ1ZmZlciwgXCJ1aW50MzJcIik7XHJcbiAgICAgICAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIGJpbmRHcm91cCk7XHJcbiAgICAgICAgICAgIHBhc3MuZHJhd0luZGV4ZWQoNik7XHJcbiAgICAgICAgICAgIHBhc3MuZW5kKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgKytiYXNlTWlwTGV2ZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkZXZpY2UucXVldWUuc3VibWl0KFtlbmNvZGVyLmZpbmlzaCgpXSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZUN1YmVtYXAoKTogKGQ6IEdQVURldmljZSwgaDogSERSLCBzOiBudW1iZXIpID0+IEdQVVRleHR1cmUge1xyXG4gICAgbGV0IG1vZHVsZTogR1BVU2hhZGVyTW9kdWxlO1xyXG4gICAgbGV0IGNvbXB1dGVQaXBlbGluZTogR1BVQ29tcHV0ZVBpcGVsaW5lO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZUN1YmVtYXAoXHJcbiAgICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgICBoZHI6IEhEUixcclxuICAgICAgc2l6ZTogbnVtYmVyXHJcbiAgICApOiBHUFVUZXh0dXJlIHtcclxuICAgICAgaWYgKCFtb2R1bGUpIHtcclxuICAgICAgICBtb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHtcclxuICAgICAgICAgIGxhYmVsOiBcIkdQVSBTaGFkZXIgTW9kdWxlOiBDdWJlbWFwIEdlbmVyYXRpb25cIixcclxuICAgICAgICAgIGNvZGU6IGVxdWlyZWN0YW5ndWxhclNoYWRlckNvZGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghY29tcHV0ZVBpcGVsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgYmluZEdyb3VwTGF5b3V0ID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCh7XHJcbiAgICAgICAgICBsYWJlbDogXCJHUFUgQmluZCBHcm91cCBMYXlvdXQ6IEN1YmVtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgYmluZGluZzogMCxcclxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLFxyXG4gICAgICAgICAgICAgIHRleHR1cmU6IHtcclxuICAgICAgICAgICAgICAgIHNhbXBsZVR5cGU6IFwidW5maWx0ZXJhYmxlLWZsb2F0XCIgYXMgR1BVVGV4dHVyZVNhbXBsZVR5cGUsXHJcbiAgICAgICAgICAgICAgICB2aWV3RGltZW5zaW9uOiBcIjJkXCIgYXMgR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24sXHJcbiAgICAgICAgICAgICAgICBtdWx0aXNhbXBsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBiaW5kaW5nOiAxLFxyXG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IEdQVVNoYWRlclN0YWdlLkNPTVBVVEUsXHJcbiAgICAgICAgICAgICAgc3RvcmFnZVRleHR1cmU6IHtcclxuICAgICAgICAgICAgICAgIGFjY2VzczogXCJ3cml0ZS1vbmx5XCIgYXMgR1BVU3RvcmFnZVRleHR1cmVBY2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwicmdiYTMyZmxvYXRcIiBhcyBHUFVUZXh0dXJlRm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgdmlld0RpbWVuc2lvbjogXCIyZC1hcnJheVwiIGFzIEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZUxheW91dCA9IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCh7XHJcbiAgICAgICAgICBsYWJlbDogXCJHUFUgQ29tcHV0ZSBQaXBlbGluZSBMYXlvdXQ6IEN1YmVtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgICAgYmluZEdyb3VwTGF5b3V0czogW2JpbmRHcm91cExheW91dF0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29tcHV0ZVBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7XHJcbiAgICAgICAgICBsYWJlbDogXCJHUFUgQ29tcHV0ZSBQaXBlbGluZTogQ3ViZW1hcCBHZW5lcmF0aW9uXCIsXHJcbiAgICAgICAgICBsYXlvdXQ6IGNvbXB1dGVQaXBlbGluZUxheW91dCxcclxuICAgICAgICAgIGNvbXB1dGU6IHtcclxuICAgICAgICAgICAgbW9kdWxlLFxyXG4gICAgICAgICAgICBlbnRyeVBvaW50OiBcImNvbXB1dGVfbWFpblwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc3JjVGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcclxuICAgICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZTogQ3ViZW1hcCBHZW5lcmF0aW9uIFNvdXJjZVwiLFxyXG4gICAgICAgIHNpemU6IFtoZHIud2lkdGgsIGhkci5oZWlnaHRdLFxyXG4gICAgICAgIGZvcm1hdDogXCJyZ2JhMzJmbG9hdFwiLFxyXG4gICAgICAgIHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNULFxyXG4gICAgICB9KTtcclxuICAgICAgZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0ZXh0dXJlOiBzcmNUZXh0dXJlLFxyXG4gICAgICAgICAgbWlwTGV2ZWw6IDAsXHJcbiAgICAgICAgICBvcmlnaW46IFswLCAwLCAwXSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhkci5kYXRhLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgIGJ5dGVzUGVyUm93OiBoZHIud2lkdGggKiA0ICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgICAgcm93c1BlckltYWdlOiBoZHIuaGVpZ2h0LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgd2lkdGg6IGhkci53aWR0aCxcclxuICAgICAgICAgIGhlaWdodDogaGRyLmhlaWdodCxcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHNyY1RleHR1cmVWaWV3ID0gc3JjVGV4dHVyZS5jcmVhdGVWaWV3KHtcclxuICAgICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZSBWaWV3OiBDdWJlbWFwIEdlbmVyYXRpb24gU291cmNlXCIsXHJcbiAgICAgICAgZm9ybWF0OiBcInJnYmEzMmZsb2F0XCIsXHJcbiAgICAgICAgZGltZW5zaW9uOiBcIjJkXCIsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgZHN0VGV4dHVyZSA9IGRldmljZS5jcmVhdGVUZXh0dXJlKHtcclxuICAgICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZTogQ3ViZW1hcCBHZW5lcmF0aW9uIERlc3RpbmF0aW9uXCIsXHJcbiAgICAgICAgc2l6ZTogW3NpemUsIHNpemUsIDZdLFxyXG4gICAgICAgIGZvcm1hdDogXCJyZ2JhMzJmbG9hdFwiLFxyXG4gICAgICAgIHVzYWdlOlxyXG4gICAgICAgICAgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8XHJcbiAgICAgICAgICBHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HIHxcclxuICAgICAgICAgIEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBkc3RUZXh0dXJlVmlldyA9IGRzdFRleHR1cmUuY3JlYXRlVmlldyh7XHJcbiAgICAgICAgbGFiZWw6IFwiR1BVIFRleHR1cmUgVmlldzogQ3ViZW1hcCBHZW5lcmF0aW9uIERlc3RpbmF0aW9uXCIsXHJcbiAgICAgICAgZm9ybWF0OiBcInJnYmEzMmZsb2F0XCIsXHJcbiAgICAgICAgZGltZW5zaW9uOiBcIjJkLWFycmF5XCIsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgYmluZEdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgICAgbGFiZWw6IFwiR1BVIEJpbmQgR3JvdXA6IEN1YmVtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgIGxheW91dDogY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxcclxuICAgICAgICBlbnRyaWVzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgIHJlc291cmNlOiBzcmNUZXh0dXJlVmlldyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGJpbmRpbmc6IDEsXHJcbiAgICAgICAgICAgIHJlc291cmNlOiBkc3RUZXh0dXJlVmlldyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKHtcclxuICAgICAgICBsYWJlbDogXCJHUFUgQ29tbWFuZCBFbmNvZGVyOiBDdWJlbWFwIEdlbmVyYXRpb25cIixcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCB3b3JrZ3JvdXBzTnVtID0gTWF0aC5mbG9vcigoc2l6ZSArIDE1KSAvIDE2KTtcclxuXHJcbiAgICAgIGNvbnN0IHBhc3MgPSBlbmNvZGVyLmJlZ2luQ29tcHV0ZVBhc3Moe1xyXG4gICAgICAgIGxhYmVsOiBcIkdQVSBDb21wdXRlIFBhc3M6IEN1YmVtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICB9KTtcclxuICAgICAgcGFzcy5zZXRQaXBlbGluZShjb21wdXRlUGlwZWxpbmUpO1xyXG4gICAgICBwYXNzLnNldEJpbmRHcm91cCgwLCBiaW5kR3JvdXApO1xyXG4gICAgICBwYXNzLmRpc3BhdGNoV29ya2dyb3Vwcyh3b3JrZ3JvdXBzTnVtLCB3b3JrZ3JvdXBzTnVtLCA2KTtcclxuICAgICAgcGFzcy5lbmQoKTtcclxuXHJcbiAgICAgIGRldmljZS5xdWV1ZS5zdWJtaXQoW2VuY29kZXIuZmluaXNoKCldKTtcclxuXHJcbiAgICAgIHJldHVybiBkc3RUZXh0dXJlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVJcnJhZGlhbmNlTWFwKCk6IChcclxuICAgIGQ6IEdQVURldmljZSxcclxuICAgIHQ6IEdQVVRleHR1cmUsXHJcbiAgICBzOiBudW1iZXJcclxuICApID0+IEdQVVRleHR1cmUge1xyXG4gICAgbGV0IG1vZHVsZTogR1BVU2hhZGVyTW9kdWxlO1xyXG4gICAgbGV0IGNvbXB1dGVQaXBlbGluZTogR1BVQ29tcHV0ZVBpcGVsaW5lO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZUlycmFkaWFuY2VNYXAoXHJcbiAgICAgIGRldmljZTogR1BVRGV2aWNlLFxyXG4gICAgICB0ZXh0dXJlOiBHUFVUZXh0dXJlLFxyXG4gICAgICBzaXplOiBudW1iZXJcclxuICAgICk6IEdQVVRleHR1cmUge1xyXG4gICAgICBpZiAoIW1vZHVsZSkge1xyXG4gICAgICAgIG1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe1xyXG4gICAgICAgICAgbGFiZWw6IFwiR1BVIFNoYWRlciBNb2R1bGU6IElycmFkaWFuY2UgQ3ViZW1hcCBHZW5lcmF0aW9uXCIsXHJcbiAgICAgICAgICBjb2RlOiBpcnJhZGlhbmNlbWFwU2hhZGVyQ29kZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFjb21wdXRlUGlwZWxpbmUpIHtcclxuICAgICAgICBjb25zdCBiaW5kR3JvdXBMYXlvdXQgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwTGF5b3V0KHtcclxuICAgICAgICAgIGxhYmVsOiBcIkdQVSBCaW5kIEdyb3VwIExheW91dDogSXJyYWRpYW5jZSBDdWJlbWFwIEdlbmVyYXRpb25cIixcclxuICAgICAgICAgIGVudHJpZXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGJpbmRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eTogR1BVU2hhZGVyU3RhZ2UuQ09NUFVURSxcclxuICAgICAgICAgICAgICBzdG9yYWdlVGV4dHVyZToge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzOiBcInJlYWQtb25seVwiIGFzIEdQVVN0b3JhZ2VUZXh0dXJlQWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcInJnYmEzMmZsb2F0XCIgYXMgR1BVVGV4dHVyZUZvcm1hdCxcclxuICAgICAgICAgICAgICAgIHZpZXdEaW1lbnNpb246IFwiMmQtYXJyYXlcIiBhcyBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbixcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgYmluZGluZzogMSxcclxuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBHUFVTaGFkZXJTdGFnZS5DT01QVVRFLFxyXG4gICAgICAgICAgICAgIHN0b3JhZ2VUZXh0dXJlOiB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3M6IFwid3JpdGUtb25seVwiIGFzIEdQVVN0b3JhZ2VUZXh0dXJlQWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcInJnYmEzMmZsb2F0XCIgYXMgR1BVVGV4dHVyZUZvcm1hdCxcclxuICAgICAgICAgICAgICAgIHZpZXdEaW1lbnNpb246IFwiMmQtYXJyYXlcIiBhcyBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbixcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjb21wdXRlUGlwZWxpbmVMYXlvdXQgPSBkZXZpY2UuY3JlYXRlUGlwZWxpbmVMYXlvdXQoe1xyXG4gICAgICAgICAgbGFiZWw6IFwiR1BVIENvbXB1dGUgUGlwZWxpbmUgTGF5b3V0OiBJcnJhZGlhbmNlIEN1YmVtYXAgR2VuZXJhdGlvblwiLFxyXG4gICAgICAgICAgYmluZEdyb3VwTGF5b3V0czogW2JpbmRHcm91cExheW91dF0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29tcHV0ZVBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7XHJcbiAgICAgICAgICBsYWJlbDogXCJHUFUgQ29tcHV0ZSBQaXBlbGluZTogSXJyYWRpYW5jZSBDdWJlbWFwIEdlbmVyYXRpb25cIixcclxuICAgICAgICAgIGxheW91dDogY29tcHV0ZVBpcGVsaW5lTGF5b3V0LFxyXG4gICAgICAgICAgY29tcHV0ZToge1xyXG4gICAgICAgICAgICBtb2R1bGUsXHJcbiAgICAgICAgICAgIGVudHJ5UG9pbnQ6IFwiY29tcHV0ZV9tYWluXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzcmNUZXh0dXJlID0gZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xyXG4gICAgICAgIGxhYmVsOiBcIkdQVSBUZXh0dXJlOiBJcnJhZGlhbmNlIEN1YmVtYXAgR2VuZXJhdGlvbiBTb3VyY2VcIixcclxuICAgICAgICBzaXplOiBbdGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHQsIDZdLFxyXG4gICAgICAgIGZvcm1hdDogXCJyZ2JhMzJmbG9hdFwiLFxyXG4gICAgICAgIHVzYWdlOlxyXG4gICAgICAgICAgR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8XHJcbiAgICAgICAgICBHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HIHxcclxuICAgICAgICAgIEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBjb3B5Q29tbWFuZEVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcclxuICAgICAgY29weUNvbW1hbmRFbmNvZGVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHRleHR1cmUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0ZXh0dXJlOiBzcmNUZXh0dXJlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgW3RleHR1cmUud2lkdGgsIHRleHR1cmUuaGVpZ2h0LCA2XVxyXG4gICAgICApO1xyXG4gICAgICBkZXZpY2UucXVldWUuc3VibWl0KFtjb3B5Q29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcclxuXHJcbiAgICAgIGNvbnN0IHNyY1RleHR1cmVWaWV3ID0gc3JjVGV4dHVyZS5jcmVhdGVWaWV3KHtcclxuICAgICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZSBWaWV3OiBJcnJhZGlhbmNlIEN1YmVtYXAgR2VuZXJhdGlvbiBTb3VyY2VcIixcclxuICAgICAgICBmb3JtYXQ6IFwicmdiYTMyZmxvYXRcIixcclxuICAgICAgICBkaW1lbnNpb246IFwiMmQtYXJyYXlcIixcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBkc3RUZXh0dXJlID0gZGV2aWNlLmNyZWF0ZVRleHR1cmUoe1xyXG4gICAgICAgIGxhYmVsOiBcIkdQVSBUZXh0dXJlOiBJcnJhZGlhbmNlIEN1YmVtYXAgR2VuZXJhdGlvbiBEZXN0aW5hdGlvblwiLFxyXG4gICAgICAgIHNpemU6IFtzaXplLCBzaXplLCA2XSxcclxuICAgICAgICBmb3JtYXQ6IFwicmdiYTMyZmxvYXRcIixcclxuICAgICAgICB1c2FnZTpcclxuICAgICAgICAgIEdQVVRleHR1cmVVc2FnZS5URVhUVVJFX0JJTkRJTkcgfCBHUFVUZXh0dXJlVXNhZ2UuU1RPUkFHRV9CSU5ESU5HLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGRzdFRleHR1cmVWaWV3ID0gZHN0VGV4dHVyZS5jcmVhdGVWaWV3KHtcclxuICAgICAgICBsYWJlbDogXCJHUFUgVGV4dHVyZSBWaWV3OiBJcnJhZGlhbmNlIEN1YmVtYXAgR2VuZXJhdGlvbiBEZXN0aW5hdGlvblwiLFxyXG4gICAgICAgIGZvcm1hdDogXCJyZ2JhMzJmbG9hdFwiLFxyXG4gICAgICAgIGRpbWVuc2lvbjogXCIyZC1hcnJheVwiLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGJpbmRHcm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xyXG4gICAgICAgIGxhYmVsOiBcIkdQVSBCaW5kIEdyb3VwOiBDdWJlbWFwIEdlbmVyYXRpb25cIixcclxuICAgICAgICBsYXlvdXQ6IGNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksXHJcbiAgICAgICAgZW50cmllczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nOiAwLFxyXG4gICAgICAgICAgICByZXNvdXJjZTogc3JjVGV4dHVyZVZpZXcsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBiaW5kaW5nOiAxLFxyXG4gICAgICAgICAgICByZXNvdXJjZTogZHN0VGV4dHVyZVZpZXcsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcih7XHJcbiAgICAgICAgbGFiZWw6IFwiR1BVIENvbW1hbmQgRW5jb2RlcjogSXJyYWRpYW5jZSBDdWJlbWFwIEdlbmVyYXRpb25cIixcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCB3b3JrZ3JvdXBzTnVtID0gTWF0aC5mbG9vcigoc2l6ZSArIDE1KSAvIDE2KTtcclxuXHJcbiAgICAgIGNvbnN0IHBhc3MgPSBlbmNvZGVyLmJlZ2luQ29tcHV0ZVBhc3Moe1xyXG4gICAgICAgIGxhYmVsOiBcIkdQVSBDb21wdXRlIFBhc3M6IElycmFkaWFuY2UgQ3ViZW1hcCBHZW5lcmF0aW9uXCIsXHJcbiAgICAgIH0pO1xyXG4gICAgICBwYXNzLnNldFBpcGVsaW5lKGNvbXB1dGVQaXBlbGluZSk7XHJcbiAgICAgIHBhc3Muc2V0QmluZEdyb3VwKDAsIGJpbmRHcm91cCk7XHJcbiAgICAgIHBhc3MuZGlzcGF0Y2hXb3JrZ3JvdXBzKHdvcmtncm91cHNOdW0sIHdvcmtncm91cHNOdW0sIDYpO1xyXG4gICAgICBwYXNzLmVuZCgpO1xyXG5cclxuICAgICAgZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZW5jb2Rlci5maW5pc2goKV0pO1xyXG5cclxuICAgICAgcmV0dXJuIGRzdFRleHR1cmU7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbml0R1VJKCk6IHZvaWQge1xyXG4gICAgY29uc3QgZ3VpID0gbmV3IEdVSSh7XHJcbiAgICAgIG5hbWU6IFwiTXkgR1VJXCIsXHJcbiAgICAgIGF1dG9QbGFjZTogdHJ1ZSxcclxuICAgICAgaGlkZWFibGU6IHRydWUsXHJcbiAgICAgIHdpZHRoOiAzMDAsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBwcm9maWxpbmcgR1VJXHJcbiAgICBjb25zdCBwcm9maWxlciA9IHsgZnBzOiBcIjBcIiwgY3B1VGltZTogXCIwXCIsIGdwdVRpbWU6IFwiMFwiIH07XHJcblxyXG4gICAgY29uc3QgcHJvZmlsZXJHVUkgPSBndWkuYWRkRm9sZGVyKFwiUHJvZmlsZXJcIik7XHJcbiAgICBwcm9maWxlckdVSS5jbG9zZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuZnBzQ29udHJvbGxlciA9IHByb2ZpbGVyR1VJXHJcbiAgICAgIC5hZGQoeyBkaXNwbGF5OiBwcm9maWxlci5mcHMgfSwgXCJkaXNwbGF5XCIpXHJcbiAgICAgIC5uYW1lKFwiRlBTXCIpO1xyXG4gICAgdGhpcy5jcHVUaW1lQ29udHJvbGxlciA9IHByb2ZpbGVyR1VJXHJcbiAgICAgIC5hZGQoeyBkaXNwbGF5OiBwcm9maWxlci5jcHVUaW1lIH0sIFwiZGlzcGxheVwiKVxyXG4gICAgICAubmFtZShcIkNQVSBUaW1lIChtcylcIik7XHJcbiAgICB0aGlzLmdwdVRpbWVDb250cm9sbGVyID0gcHJvZmlsZXJHVUlcclxuICAgICAgLmFkZCh7IGRpc3BsYXk6IHByb2ZpbGVyLmdwdVRpbWUgfSwgXCJkaXNwbGF5XCIpXHJcbiAgICAgIC5uYW1lKFwiR1BVIFRpbWUgKMK1cylcIik7XHJcblxyXG4gICAgLy8gdGV4dHVyZSBvcHRpb25zIEdVSVxyXG4gICAgY29uc3QgdGV4dHVyZU9wdGlvbnMgPSB7XHJcbiAgICAgIG1pbWFwczogdHJ1ZSxcclxuICAgICAgYWRkcmVzc01vZGVVOiBcInJlcGVhdFwiLFxyXG4gICAgICBhZGRyZXNzTW9kZVY6IFwicmVwZWF0XCIsXHJcbiAgICAgIG1hZ0ZpbHRlcjogXCJsaW5lYXJcIixcclxuICAgICAgbWluRmlsdGVyOiBcImxpbmVhclwiLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB0ZXh0dXJlT3B0aW9uc0dVSSA9IGd1aS5hZGRGb2xkZXIoXCJUZXh0dXJlIE9wdGlvbnNcIik7XHJcbiAgICB0ZXh0dXJlT3B0aW9uc0dVSS5jbG9zZWQgPSBmYWxzZTtcclxuICAgIHRoaXMubWlwbWFwc0NvbnRyb2xsZXIgPSB0ZXh0dXJlT3B0aW9uc0dVSVxyXG4gICAgICAuYWRkKHRleHR1cmVPcHRpb25zLCBcIm1pbWFwc1wiKVxyXG4gICAgICAubmFtZShcIk1pcG1hcHNcIik7XHJcbiAgICB0aGlzLmFkZHJlc3NNb2RlVUNvbnRyb2xsZXIgPSB0ZXh0dXJlT3B0aW9uc0dVSVxyXG4gICAgICAuYWRkKHRleHR1cmVPcHRpb25zLCBcImFkZHJlc3NNb2RlVVwiKVxyXG4gICAgICAub3B0aW9ucyhbXCJyZXBlYXRcIiwgXCJjbGFtcC10by1lZGdlXCJdKVxyXG4gICAgICAubmFtZShcImFkZHJlc3NNb2RlVVwiKTtcclxuICAgIHRoaXMuYWRkcmVzc01vZGVWQ29udHJvbGxlciA9IHRleHR1cmVPcHRpb25zR1VJXHJcbiAgICAgIC5hZGQodGV4dHVyZU9wdGlvbnMsIFwiYWRkcmVzc01vZGVWXCIpXHJcbiAgICAgIC5vcHRpb25zKFtcInJlcGVhdFwiLCBcImNsYW1wLXRvLWVkZ2VcIl0pXHJcbiAgICAgIC5uYW1lKFwiYWRkcmVzc01vZGVWXCIpO1xyXG4gICAgdGhpcy5tYWdGaWx0ZXJDb250cm9sbGVyID0gdGV4dHVyZU9wdGlvbnNHVUlcclxuICAgICAgLmFkZCh0ZXh0dXJlT3B0aW9ucywgXCJtYWdGaWx0ZXJcIilcclxuICAgICAgLm9wdGlvbnMoW1wibGluZWFyXCIsIFwibmVhcmVzdFwiXSlcclxuICAgICAgLm5hbWUoXCJtYWdGaWx0ZXJcIik7XHJcbiAgICB0aGlzLm1pbkZpbHRlckNvbnRyb2xsZXIgPSB0ZXh0dXJlT3B0aW9uc0dVSVxyXG4gICAgICAuYWRkKHRleHR1cmVPcHRpb25zLCBcIm1pbkZpbHRlclwiKVxyXG4gICAgICAub3B0aW9ucyhbXCJsaW5lYXJcIiwgXCJuZWFyZXN0XCJdKVxyXG4gICAgICAubmFtZShcIm1pbkZpbHRlclwiKTtcclxuXHJcbiAgICAvLyBtdWx0aXNhbXBsaW5nIGFudGktYWxpYXNpbmcgR1VJXHJcbiAgICBjb25zdCBtc2FhT3B0aW9ucyA9IHtcclxuICAgICAgZW5hYmxlOiBmYWxzZSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgYW50aUFsaWFzaW5nR1VJID0gZ3VpLmFkZEZvbGRlcihcIk11bHRpc2FtcGxpbmcgQW50aS1BbGlhc2luZyAoTVNBQSlcIik7XHJcbiAgICBhbnRpQWxpYXNpbmdHVUkuY2xvc2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLm1zYWFDb250cm9sbGVyID0gYW50aUFsaWFzaW5nR1VJXHJcbiAgICAgIC5hZGQobXNhYU9wdGlvbnMsIFwiZW5hYmxlXCIpXHJcbiAgICAgIC5uYW1lKFwiRW5hYmxlXCIpO1xyXG5cclxuICAgIC8vIHNreWJveCBHVUlcclxuICAgIGNvbnN0IHNreWJveE9wdGlvbnMgPSB7XHJcbiAgICAgIHNreWJveDogXCJQdXJlIFNreVwiLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBza3lib3hHVUkgPSBndWkuYWRkRm9sZGVyKFwiU2t5Ym94XCIpO1xyXG4gICAgc2t5Ym94R1VJLmNsb3NlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5za3lib3hDb250cm9sbGVyID0gc2t5Ym94R1VJXHJcbiAgICAgIC5hZGQoc2t5Ym94T3B0aW9ucywgXCJza3lib3hcIilcclxuICAgICAgLm9wdGlvbnMoW1wiUHVyZSBTa3lcIiwgXCJDbGVhciBQdXJlIFNreVwiXSlcclxuICAgICAgLm5hbWUoXCJTa3lib3hcIik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJ1bigpOiB2b2lkIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXdGcmFtZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRyYXdGcmFtZShub3c6IG51bWJlcik6IHZvaWQge1xyXG4gICAgZnBzQXZnLnZhbHVlID0gMTAwMCAvIChub3cgLSB0aGlzLmN1cnJlbnQpO1xyXG4gICAgdGhpcy5mcHNDb250cm9sbGVyLnNldFZhbHVlKGZwc0F2Zy52YWx1ZS50b0ZpeGVkKDEpKTtcclxuICAgIHRoaXMuY3VycmVudCA9IG5vdztcclxuXHJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgICAvLyB0cmFuc2Zvcm0gdmFsdWVzXHJcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KFxyXG4gICAgICB0aGlzLnRyYW5zZm9ybVVuaWZvcm1CdWZmZXIuc2l6ZSAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBtb2RlbCBtYXRyaXhcclxuICAgIGNvbnN0IG1vZGVsID0gdGhpcy5nZW9tZXRyaWVzWzBdLm1vZGVsO1xyXG4gICAgdHJhbnNmb3JtVmFsdWVzLnNldChtb2RlbCwgMCk7XHJcblxyXG4gICAgLy8gbm9yYW1sIG1hdHJpeFxyXG4gICAgY29uc3Qgbm9ybWFsID0gbWF0NC50cmFuc3Bvc2UobWF0NC5pbnZlcnNlKG1vZGVsKSk7XHJcbiAgICB0cmFuc2Zvcm1WYWx1ZXMuc2V0KG5vcm1hbCwgbW9kZWwubGVuZ3RoKTtcclxuXHJcbiAgICAvLyB2aWV3IG1hdHJpeFxyXG4gICAgY29uc3QgdmlldyA9IHRoaXMuY2FtZXJhLnZpZXc7XHJcbiAgICB0cmFuc2Zvcm1WYWx1ZXMuc2V0KHZpZXcsIG1vZGVsLmxlbmd0aCArIG5vcm1hbC5sZW5ndGgpO1xyXG5cclxuICAgIC8vIHByb2plY3Rpb24gbWF0cml4XHJcbiAgICBjb25zdCBhc3BlY3QgPSB0aGlzLmNhbnZhcy53aWR0aCAvIHRoaXMuY2FudmFzLmhlaWdodDtcclxuICAgIGNvbnN0IHByb2plY3Rpb24gPSBtYXQ0LnBlcnNwZWN0aXZlKFxyXG4gICAgICB1dGlscy5kZWdUb1JhZCg0NS4wKSxcclxuICAgICAgYXNwZWN0LFxyXG4gICAgICAxLjAsXHJcbiAgICAgIDEwMC4wXHJcbiAgICApO1xyXG5cclxuICAgIHRyYW5zZm9ybVZhbHVlcy5zZXQocHJvamVjdGlvbiwgbW9kZWwubGVuZ3RoICsgbm9ybWFsLmxlbmd0aCArIHZpZXcubGVuZ3RoKTtcclxuXHJcbiAgICB0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcclxuICAgICAgdGhpcy50cmFuc2Zvcm1Vbmlmb3JtQnVmZmVyLFxyXG4gICAgICAwLFxyXG4gICAgICB0cmFuc2Zvcm1WYWx1ZXMuYnVmZmVyLFxyXG4gICAgICB0cmFuc2Zvcm1WYWx1ZXMuYnl0ZU9mZnNldCxcclxuICAgICAgdHJhbnNmb3JtVmFsdWVzLmJ5dGVMZW5ndGhcclxuICAgICk7XHJcblxyXG4gICAgLy8gc2t5Ym94IHVuaWZvcm0gYnVmZmVyIHZhbHVlc1xyXG4gICAgY29uc3Qgc2t5Ym94VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgdGhpcy5za3lib3hVbmlmb3JtQnVmZmVyLnNpemUgLyBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlRcclxuICAgICk7XHJcbiAgICBza3lib3hWYWx1ZXMuc2V0KG1hdDQuaW52ZXJzZShtYXQ0Lm11bChwcm9qZWN0aW9uLCB2aWV3KSksIDApO1xyXG5cclxuICAgIHRoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxyXG4gICAgICB0aGlzLnNreWJveFVuaWZvcm1CdWZmZXIsXHJcbiAgICAgIDAsXHJcbiAgICAgIHNreWJveFZhbHVlcy5idWZmZXIsXHJcbiAgICAgIHNreWJveFZhbHVlcy5ieXRlT2Zmc2V0LFxyXG4gICAgICBza3lib3hWYWx1ZXMuYnl0ZUxlbmd0aFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBjYW1lcmEgcG9zaXRpb25cclxuICAgIHRoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxyXG4gICAgICB0aGlzLnZpZXdQb3NpdGlvblVuaWZvcm1CdWZmZXIsXHJcbiAgICAgIDAsXHJcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmJ1ZmZlcixcclxuICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uYnl0ZU9mZnNldCxcclxuICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uYnl0ZUxlbmd0aFxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBsaWdodCBwb3NpdGlvbnNcclxuICAgIGNvbnN0IGxpZ2h0UG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgdGhpcy5saWdodFBvc2l0aW9uc1VuaWZvcm1CdWZmZXIuc2l6ZSAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVFxyXG4gICAgKTtcclxuXHJcbiAgICBsaWdodFBvc2l0aW9ucy5zZXQodmVjMy5jcmVhdGUoMTAuMCwgMTAuMCwgMTAuMCksIDApO1xyXG4gICAgbGlnaHRQb3NpdGlvbnMuc2V0KHZlYzMuY3JlYXRlKC0xMC4wLCAxMC4wLCAxMC4wKSwgNCk7XHJcbiAgICBsaWdodFBvc2l0aW9ucy5zZXQodmVjMy5jcmVhdGUoMTAuMCwgLTEwLjAsIDEwLjApLCA4KTtcclxuICAgIGxpZ2h0UG9zaXRpb25zLnNldCh2ZWMzLmNyZWF0ZSgtMTAuMCwgLTEwLjAsIDEwLjApLCAxMik7XHJcblxyXG4gICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoXHJcbiAgICAgIHRoaXMubGlnaHRQb3NpdGlvbnNVbmlmb3JtQnVmZmVyLFxyXG4gICAgICAwLFxyXG4gICAgICBsaWdodFBvc2l0aW9ucy5idWZmZXIsXHJcbiAgICAgIGxpZ2h0UG9zaXRpb25zLmJ5dGVPZmZzZXQsXHJcbiAgICAgIGxpZ2h0UG9zaXRpb25zLmJ5dGVMZW5ndGhcclxuICAgICk7XHJcblxyXG4gICAgLy8gbGlnaHQgY29sb3JzXHJcbiAgICBjb25zdCBsaWdodENvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoXHJcbiAgICAgIHRoaXMubGlnaHRDb2xvcnNVbmlmb3JtQnVmZmVyLnNpemUgLyBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlRcclxuICAgICk7XHJcblxyXG4gICAgbGlnaHRDb2xvcnMuc2V0KHZlYzMuY3JlYXRlKDMwMC4wLCAzMDAuMCwgMzAwLjApLCAwKTtcclxuICAgIGxpZ2h0Q29sb3JzLnNldCh2ZWMzLmNyZWF0ZSgzMDAuMCwgMzAwLjAsIDMwMC4wKSwgNCk7XHJcbiAgICBsaWdodENvbG9ycy5zZXQodmVjMy5jcmVhdGUoMzAwLjAsIDMwMC4wLCAzMDAuMCksIDgpO1xyXG4gICAgbGlnaHRDb2xvcnMuc2V0KHZlYzMuY3JlYXRlKDMwMC4wLCAzMDAuMCwgMzAwLjApLCAxMik7XHJcblxyXG4gICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoXHJcbiAgICAgIHRoaXMubGlnaHRDb2xvcnNVbmlmb3JtQnVmZmVyLFxyXG4gICAgICAwLFxyXG4gICAgICBsaWdodENvbG9ycy5idWZmZXIsXHJcbiAgICAgIGxpZ2h0Q29sb3JzLmJ5dGVPZmZzZXQsXHJcbiAgICAgIGxpZ2h0Q29sb3JzLmJ5dGVMZW5ndGhcclxuICAgICk7XHJcblxyXG4gICAgLy8gc2FtcGxlciBpbmRleFxyXG4gICAgY29uc3QgYWRkcmVzc01vZGVVID0gdGhpcy5hZGRyZXNzTW9kZVVDb250cm9sbGVyLmdldFZhbHVlKCk7XHJcbiAgICBjb25zdCBhZGRyZXNzTW9kZVYgPSB0aGlzLmFkZHJlc3NNb2RlVkNvbnRyb2xsZXIuZ2V0VmFsdWUoKTtcclxuICAgIGNvbnN0IG1hZ0ZpbHRlciA9IHRoaXMubWFnRmlsdGVyQ29udHJvbGxlci5nZXRWYWx1ZSgpO1xyXG4gICAgY29uc3QgbWluRmlsdGVyID0gdGhpcy5taW5GaWx0ZXJDb250cm9sbGVyLmdldFZhbHVlKCk7XHJcbiAgICBjb25zdCBzYW1wbGVySW5kZXggPVxyXG4gICAgICAoYWRkcmVzc01vZGVVID09PSBcInJlcGVhdFwiID8gMSA6IDApICtcclxuICAgICAgKGFkZHJlc3NNb2RlViA9PT0gXCJyZXBlYXRcIiA/IDIgOiAwKSArXHJcbiAgICAgIChtYWdGaWx0ZXIgPT09IFwibGluZWFyXCIgPyA0IDogMCkgK1xyXG4gICAgICAobWluRmlsdGVyID09PSBcImxpbmVhclwiID8gOCA6IDApICtcclxuICAgICAgKHRoaXMubXNhYUNvbnRyb2xsZXIuZ2V0VmFsdWUoKSA/IDE2IDogMCk7XHJcblxyXG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcih7XHJcbiAgICAgIGxhYmVsOiBcIkdQVSBDb21tYW5kIEVuY29kZXI6IERyYXcgRnJhbWVcIixcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNhbnZhc1RleHR1cmUgPSB0aGlzLmNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKTtcclxuICAgIGNvbnN0IGNhbnZhc1RleHR1cmVWaWV3ID0gY2FudmFzVGV4dHVyZS5jcmVhdGVWaWV3KHtcclxuICAgICAgbGFiZWw6IFwiR1BVIFRleHR1cmUgVmlldzogQ2FudmFzIFRleHR1cmUgVmlld1wiLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY29sb3JBdHRhY2htZW50czogR1BVUmVuZGVyUGFzc0NvbG9yQXR0YWNobWVudFtdID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgdmlldzogY2FudmFzVGV4dHVyZVZpZXcsXHJcbiAgICAgICAgY2xlYXJWYWx1ZTogeyByOiAwLjAsIGc6IDAuMCwgYjogMC4wLCBhOiAxLjAgfSxcclxuICAgICAgICBsb2FkT3A6IFwiY2xlYXJcIixcclxuICAgICAgICBzdG9yZU9wOiBcInN0b3JlXCIsXHJcbiAgICAgIH0sXHJcbiAgICBdO1xyXG4gICAgaWYgKHRoaXMubXNhYUNvbnRyb2xsZXIuZ2V0VmFsdWUoKSkge1xyXG4gICAgICBjb2xvckF0dGFjaG1lbnRzWzBdLnZpZXcgPSB0aGlzLm11bHRpc2FtcGxpbmdUZXh0dXJlVmlldztcclxuICAgICAgY29sb3JBdHRhY2htZW50c1swXS5yZXNvbHZlVGFyZ2V0ID0gY2FudmFzVGV4dHVyZVZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGVwdGhUZXh0dXJlVmlld0luZGV4ID0gdGhpcy5tc2FhQ29udHJvbGxlci5nZXRWYWx1ZSgpID8gMSA6IDA7XHJcbiAgICBjb25zdCByZW5kZXJQYXNzRGVzY3JpcHRvcjogR1BVUmVuZGVyUGFzc0Rlc2NyaXB0b3IgPSB7XHJcbiAgICAgIGxhYmVsOiBcIkdQVSBSZW5kZXJwYXNzIERlc2NyaXB0b3I6IERyYXcgRnJhbWVcIixcclxuICAgICAgY29sb3JBdHRhY2htZW50cyxcclxuICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudDoge1xyXG4gICAgICAgIHZpZXc6IHRoaXMuZGVwdGhUZXh0dXJlVmlld3NbZGVwdGhUZXh0dXJlVmlld0luZGV4XSxcclxuICAgICAgICBkZXB0aENsZWFyVmFsdWU6IDEuMCxcclxuICAgICAgICBkZXB0aExvYWRPcDogXCJjbGVhclwiLFxyXG4gICAgICAgIGRlcHRoU3RvcmVPcDogXCJzdG9yZVwiLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNUaW1lc3RhbXApIHtcclxuICAgICAgcmVuZGVyUGFzc0Rlc2NyaXB0b3IudGltZXN0YW1wV3JpdGVzID0ge1xyXG4gICAgICAgIHF1ZXJ5U2V0OiB0aGlzLnF1ZXJ5U2V0LFxyXG4gICAgICAgIGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IDAsXHJcbiAgICAgICAgZW5kT2ZQYXNzV3JpdGVJbmRleDogMSxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBtaXBtYXBzIGluZGV4XHJcbiAgICBjb25zdCBtaXBJbmRleCA9IHRoaXMubWlwbWFwc0NvbnRyb2xsZXIuZ2V0VmFsdWUoKSA/IDEgOiAwO1xyXG5cclxuICAgIC8vIHJlbmRlciBwaXBlbGluZSh3LyBNU0FBLCB3L28gTVNBQSkgaW5kZXhcclxuICAgIGNvbnN0IHJlbmRlclBpcGVsaW5lSW5kZXggPSB0aGlzLm1zYWFDb250cm9sbGVyLmdldFZhbHVlKCkgPyAxIDogMDtcclxuXHJcbiAgICAvLyB0ZXh0dXJlIGluZGV4XHJcbiAgICBjb25zdCB0ZXh0dXJlSW5kZXggPSAobWlwSW5kZXggPyAxIDogMCkgKyAocmVuZGVyUGlwZWxpbmVJbmRleCA/IDIgOiAwKTtcclxuXHJcbiAgICAvLyBza3lib3ggaW5kZXhcclxuICAgIGNvbnN0IHNreWJveEluZGV4ID0gdGhpcy5za3lib3hDb250cm9sbGVyLmdldFZhbHVlKCkgPT09IFwiUHVyZSBTa3lcIiA/IDAgOiAxO1xyXG5cclxuICAgIC8vIGN1YmVtYXAgaW5kZXhcclxuICAgIGNvbnN0IGN1YmVtYXBJbmRleCA9XHJcbiAgICAgIChtaXBJbmRleCA/IDEgOiAwKSArXHJcbiAgICAgIChyZW5kZXJQaXBlbGluZUluZGV4ID8gMiA6IDApICtcclxuICAgICAgKHNreWJveEluZGV4ID8gNCA6IDApO1xyXG5cclxuICAgIC8vIHNreWJveCB0ZXh0dXJlIGluZGV4XHJcbiAgICBjb25zdCBza3lib3hUZXh0dXJlSW5kZXggPVxyXG4gICAgICAocmVuZGVyUGlwZWxpbmVJbmRleCA/IDEgOiAwKSArIChza3lib3hJbmRleCA/IDIgOiAwKTtcclxuXHJcbiAgICBjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyhyZW5kZXJQYXNzRGVzY3JpcHRvcik7XHJcbiAgICBwYXNzRW5jb2Rlci5zZXRQaXBlbGluZSh0aGlzLnJlbmRlclBpcGVsaW5lc1tyZW5kZXJQaXBlbGluZUluZGV4XSk7XHJcbiAgICBwYXNzRW5jb2Rlci5zZXRWZXJ0ZXhCdWZmZXIoMCwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xyXG4gICAgcGFzc0VuY29kZXIuc2V0SW5kZXhCdWZmZXIodGhpcy5pbmRleEJ1ZmZlciwgXCJ1aW50MTZcIik7XHJcbiAgICBwYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgdGhpcy5iaW5kR3JvdXBzWzBdW3JlbmRlclBpcGVsaW5lSW5kZXhdKTtcclxuICAgIHBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgxLCB0aGlzLmJpbmRHcm91cHNbMV1bdGV4dHVyZUluZGV4XSk7XHJcbiAgICBwYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMiwgdGhpcy5iaW5kR3JvdXBzWzJdW2N1YmVtYXBJbmRleF0pO1xyXG4gICAgcGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDMsIHRoaXMuYmluZEdyb3Vwc1szXVtzYW1wbGVySW5kZXhdKTtcclxuICAgIHBhc3NFbmNvZGVyLmRyYXdJbmRleGVkKHRoaXMuZ2VvbWV0cmllc1swXS5pbmRpY2VzLmxlbmd0aCk7XHJcblxyXG4gICAgcGFzc0VuY29kZXIuc2V0UGlwZWxpbmUodGhpcy5za3lib3hSZW5kZXJQaXBlbGluZXNbcmVuZGVyUGlwZWxpbmVJbmRleF0pO1xyXG4gICAgcGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIHRoaXMuc2t5Ym94QmluZEdyb3Vwc1swXVtyZW5kZXJQaXBlbGluZUluZGV4XSk7XHJcbiAgICBwYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMSwgdGhpcy5za3lib3hCaW5kR3JvdXBzWzFdW3NreWJveFRleHR1cmVJbmRleF0pO1xyXG4gICAgcGFzc0VuY29kZXIuZHJhdygzKTtcclxuXHJcbiAgICBwYXNzRW5jb2Rlci5lbmQoKTtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNUaW1lc3RhbXApIHtcclxuICAgICAgY29tbWFuZEVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KFxyXG4gICAgICAgIHRoaXMucXVlcnlTZXQsXHJcbiAgICAgICAgMCxcclxuICAgICAgICB0aGlzLnF1ZXJ5U2V0LmNvdW50LFxyXG4gICAgICAgIHRoaXMucmVzb2x2ZUJ1ZmZlcixcclxuICAgICAgICAwXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoXCJ1bm1hcHBlZFwiID09PSB0aGlzLnJlc3VsdEJ1ZmZlci5tYXBTdGF0ZSkge1xyXG4gICAgICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcclxuICAgICAgICAgIHRoaXMucmVzb2x2ZUJ1ZmZlcixcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICB0aGlzLnJlc3VsdEJ1ZmZlcixcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICB0aGlzLnJlc3VsdEJ1ZmZlci5zaXplXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcclxuXHJcbiAgICBjcHVUaW1lQXZnLnZhbHVlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XHJcbiAgICB0aGlzLmNwdVRpbWVDb250cm9sbGVyLnNldFZhbHVlKGNwdVRpbWVBdmcudmFsdWUudG9GaXhlZCgxKSk7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzVGltZXN0YW1wICYmIFwidW5tYXBwZWRcIiA9PT0gdGhpcy5yZXN1bHRCdWZmZXIubWFwU3RhdGUpIHtcclxuICAgICAgdGhpcy5yZXN1bHRCdWZmZXIubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpID0+IHtcclxuICAgICAgICBjb25zdCB0aW1lcyA9IG5ldyBCaWdJbnQ2NEFycmF5KHRoaXMucmVzdWx0QnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpO1xyXG4gICAgICAgIGdwdVRpbWVBdmcudmFsdWUgPSBOdW1iZXIodGltZXNbMV0gLSB0aW1lc1swXSkgLyAxMDAwO1xyXG4gICAgICAgIHRoaXMuZ3B1VGltZUNvbnRyb2xsZXIuc2V0VmFsdWUoZ3B1VGltZUF2Zy52YWx1ZS50b0ZpeGVkKDEpKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXN1bHRCdWZmZXIudW5tYXAoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhd0ZyYW1lKTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIHJhbmQobWluPzogbnVtYmVyLCBtYXg/OiBudW1iZXIpIHtcclxuICBpZiAodW5kZWZpbmVkID09PSBtaW4pIHtcclxuICAgIG1pbiA9IDA7XHJcbiAgICBtYXggPSAxO1xyXG4gIH0gZWxzZSBpZiAodW5kZWZpbmVkID09PSBtYXgpIHtcclxuICAgIG1heCA9IG1pbjtcclxuICAgIG1pbiA9IDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEltYWdlQml0bWFwKHVybDogc3RyaW5nKTogUHJvbWlzZTxJbWFnZUJpdG1hcD4ge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCk7XHJcbiAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcy5ibG9iKCk7XHJcblxyXG4gIHJldHVybiBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCB7IGNvbG9yU3BhY2VDb252ZXJzaW9uOiBcIm5vbmVcIiB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU1pcExldmVsQ291bnQoLi4uc2l6ZXM6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoLi4uc2l6ZXMpO1xyXG5cclxuICByZXR1cm4gKDEgKyBNYXRoLmxvZzIobWF4U2l6ZSkpIHwgMDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUJ5dGVMZW5ndGgodHlwZT86IHN0cmluZyk6IG51bWJlciB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlIFwiZmxvYXQzMlwiOlxyXG4gICAgICByZXR1cm4gNDtcclxuICAgIGNhc2UgXCJmbG9hdDMyeDJcIjpcclxuICAgICAgcmV0dXJuIDg7XHJcbiAgICBjYXNlIFwiZmxvYXQzMngzXCI6XHJcbiAgICAgIHJldHVybiAxMjtcclxuICAgIGNhc2UgXCJmbG9hdDMyeDRcIjpcclxuICAgICAgcmV0dXJuIDE2O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUm9sbGluZ0F2ZXJhZ2Uge1xyXG4gIHByaXZhdGUgdG90YWw6IG51bWJlcjtcclxuICBwcml2YXRlIHNhbXBsZXM6IG51bWJlcltdO1xyXG4gIHByaXZhdGUgY3Vyc29yOiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBzYW1wbGVDb3VudDogbnVtYmVyO1xyXG5cclxuICBwdWJsaWMgY29uc3RydWN0b3Ioc2FtcGxlQ291bnQgPSAxMDApIHtcclxuICAgIHRoaXMudG90YWwgPSAwO1xyXG4gICAgdGhpcy5zYW1wbGVzID0gW107XHJcbiAgICB0aGlzLmN1cnNvciA9IDA7XHJcbiAgICB0aGlzLnNhbXBsZUNvdW50ID0gc2FtcGxlQ291bnQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc2V0IHZhbHVlKHZhbHVlOiBudW1iZXIpIHtcclxuICAgIHRoaXMudG90YWwgKz0gdmFsdWUgLSAodGhpcy5zYW1wbGVzW3RoaXMuY3Vyc29yXSB8fCAwKTtcclxuICAgIHRoaXMuc2FtcGxlc1t0aGlzLmN1cnNvcl0gPSB2YWx1ZTtcclxuICAgIHRoaXMuY3Vyc29yID0gKHRoaXMuY3Vyc29yICsgMSkgJSB0aGlzLnNhbXBsZUNvdW50O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCB2YWx1ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnRvdGFsIC8gdGhpcy5zYW1wbGVzLmxlbmd0aDtcclxuICB9XHJcbn1cclxuIiwiLyogd2dwdS1tYXRyaXhAMy4wLjEsIGxpY2Vuc2UgTUlUICovXG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoT3JpZ2luYWxDb25zdHJ1Y3RvciwgbW9kaWZpZXIpIHtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBPcmlnaW5hbENvbnN0cnVjdG9yIHtcbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICBtb2RpZmllcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH07IC8vIFR5cGUgYXNzZXJ0aW9uIGlzIG5lY2Vzc2FyeSBoZXJlXG59XG5jb25zdCBaZXJvQXJyYXkgPSB3cmFwQ29uc3RydWN0b3IoKEFycmF5KSwgYSA9PiBhLmZpbGwoMCkpO1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5sZXQgRVBTSUxPTiA9IDAuMDAwMDAxO1xuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIGZvciBFUFNJTE9OIGZvciB2YXJpb3VzIGNoZWNrc1xuICogQHBhcmFtIHYgLSBWYWx1ZSB0byB1c2UgZm9yIEVQU0lMT04uXG4gKiBAcmV0dXJucyBwcmV2aW91cyB2YWx1ZSBvZiBFUFNJTE9OO1xuICovXG5mdW5jdGlvbiBzZXRFcHNpbG9uKHYpIHtcbiAgICBjb25zdCBvbGQgPSBFUFNJTE9OO1xuICAgIEVQU0lMT04gPSB2O1xuICAgIHJldHVybiBvbGQ7XG59XG4vKipcbiAqIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gKiBAcGFyYW0gZGVncmVlcyAtIEFuZ2xlIGluIGRlZ3JlZXNcbiAqIEByZXR1cm5zIGFuZ2xlIGNvbnZlcnRlZCB0byByYWRpYW5zXG4gKi9cbmZ1bmN0aW9uIGRlZ1RvUmFkKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XG59XG4vKipcbiAqIENvbnZlcnQgcmFkaWFucyB0byBkZWdyZWVzXG4gKiBAcGFyYW0gcmFkaWFucyAtIEFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIGFuZ2xlIGNvbnZlcnRlZCB0byBkZWdyZWVzXG4gKi9cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59XG4vKipcbiAqIExlcnBzIGJldHdlZW4gYSBhbmQgYiB2aWEgdFxuICogQHBhcmFtIGEgLSBzdGFydGluZyB2YWx1ZVxuICogQHBhcmFtIGIgLSBlbmRpbmcgdmFsdWVcbiAqIEBwYXJhbSB0IC0gdmFsdWUgd2hlcmUgMCA9IGEgYW5kIDEgPSBiXG4gKiBAcmV0dXJucyBhICsgKGIgLSBhKSAqIHRcbiAqL1xuZnVuY3Rpb24gbGVycChhLCBiLCB0KSB7XG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogdDtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgb3Bwb3NpdGUgb2YgbGVycC4gR2l2ZW4gYSBhbmQgYiBhbmQgYSB2YWx1ZSBiZXR3ZWVuXG4gKiBhIGFuZCBiIHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuIDAgaWYgYSwgMSBpZiBiLlxuICogTm90ZTogbm8gY2xhbXBpbmcgaXMgZG9uZS5cbiAqIEBwYXJhbSBhIC0gc3RhcnQgdmFsdWVcbiAqIEBwYXJhbSBiIC0gZW5kIHZhbHVlXG4gKiBAcGFyYW0gdiAtIHZhbHVlIGJldHdlZW4gYSBhbmQgYlxuICogQHJldHVybnMgKHYgLSBhKSAvIChiIC0gYSlcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoYSwgYiwgdikge1xuICAgIGNvbnN0IGQgPSBiIC0gYTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGIgLSBhKSA8IEVQU0lMT04pXG4gICAgICAgID8gYVxuICAgICAgICA6ICh2IC0gYSkgLyBkO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBldWNsaWRlYW4gbW9kdWxvXG4gKlxuICogYGBgXG4gKiAvLyB0YWJsZSBmb3IgbiAvIDNcbiAqIC01LCAtNCwgLTMsIC0yLCAtMSwgIDAsICAxLCAgMiwgIDMsICA0LCAgNSAgIDwtIG5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogLTIgIC0xICAtMCAgLTIgIC0xICAgMCwgIDEsICAyLCAgMCwgIDEsICAyICAgPC0gbiAlIDNcbiAqICAxICAgMiAgIDAgICAxICAgMiAgIDAsICAxLCAgMiwgIDAsICAxLCAgMiAgIDwtIGV1Y2xpZGVhbk1vZHVsZShuLCAzKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG4gLSBkaXZpZGVuZFxuICogQHBhcmFtIG0gLSBkaXZpc29yXG4gKiBAcmV0dXJucyB0aGUgZXVjbGlkZWFuIG1vZHVsbyBvZiBuIC8gbVxuICovXG5mdW5jdGlvbiBldWNsaWRlYW5Nb2R1bG8obiwgbSkge1xuICAgIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbn1cblxudmFyIHV0aWxzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQgRVBTSUxPTiAoKSB7IHJldHVybiBFUFNJTE9OOyB9LFxuICAgIGRlZ1RvUmFkOiBkZWdUb1JhZCxcbiAgICBldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcbiAgICBpbnZlcnNlTGVycDogaW52ZXJzZUxlcnAsXG4gICAgbGVycDogbGVycCxcbiAgICByYWRUb0RlZzogcmFkVG9EZWcsXG4gICAgc2V0RXBzaWxvbjogc2V0RXBzaWxvblxufTtcblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW0gdHlwZWQgQVBJIGZvciBWZWMzXG4gKi9cbmZ1bmN0aW9uIGdldEFQSUltcGwkNShDdG9yKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFZlYzI7IG1heSBiZSBjYWxsZWQgd2l0aCB4LCB5LCB6IHRvIHNldCBpbml0aWFsIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFNpbmNlIHBhc3NpbmcgaW4gYSByYXcgSmF2YVNjcmlwdCBhcnJheVxuICAgICAqIGlzIHZhbGlkIGluIGFsbCBjaXJjdW1zdGFuY2VzLCBpZiB5b3Ugd2FudCB0b1xuICAgICAqIGZvcmNlIGEgSmF2YVNjcmlwdCBhcnJheSBpbnRvIGEgVmVjMidzIHNwZWNpZmllZCB0eXBlXG4gICAgICogaXQgd291bGQgYmUgZmFzdGVyIHRvIHVzZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgdiA9IHZlYzIuY2xvbmUoc29tZUpTQXJyYXkpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHggPSAwLCB5ID0gMCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3RvcigyKTtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgICAgIGlmICh5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBWZWMyOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuIChzYW1lIGFzIGNyZWF0ZSlcbiAgICAgKiBAcGFyYW0geCAtIEluaXRpYWwgeCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geSAtIEluaXRpYWwgeSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBjb25zdCBmcm9tVmFsdWVzID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBvZiBhIFZlYzJcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMi5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMi5jb3B5fVxuICAgICAqXG4gICAgICogQHBhcmFtIHggZmlyc3QgdmFsdWVcbiAgICAgKiBAcGFyYW0geSBzZWNvbmQgdmFsdWVcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHdpdGggaXRzIGVsZW1lbnRzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQoeCwgeSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4O1xuICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGguY2VpbCB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGNlaWwgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2VpbCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguY2VpbCh2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5jZWlsKHZbMV0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGguZmxvb3IgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBmbG9vciBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbG9vcih2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguZmxvb3IodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguZmxvb3IodlsxXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgTWF0aC5yb3VuZCB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHJvdW5kIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdW5kKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5yb3VuZCh2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5yb3VuZCh2WzFdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xhbXAgZWFjaCBlbGVtZW50IG9mIHZlY3RvciBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gbWF4IC0gTWluIHZhbHVlLCBkZWZhdWx0IDBcbiAgICAgKiBAcGFyYW0gbWluIC0gTWF4IHZhbHVlLCBkZWZhdWx0IDFcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgdGhlIGNsYW1wZWQgdmFsdWUgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAodiwgbWluID0gMCwgbWF4ID0gMSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdlswXSkpO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdlsxXSkpO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGEgYW5kIGIgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgc3VtIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byB2ZWN0b3JzLCBzY2FsaW5nIHRoZSAybmQ7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHNjYWxlIC0gQW1vdW50IHRvIHNjYWxlIGJcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhICsgYiAqIHNjYWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFNjYWxlZChhLCBiLCBzY2FsZSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdGhlIDIgdmVjdG9ycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGF4ID0gYVswXTtcbiAgICAgICAgY29uc3QgYXkgPSBhWzFdO1xuICAgICAgICBjb25zdCBieCA9IGJbMF07XG4gICAgICAgIGNvbnN0IGJ5ID0gYlsxXTtcbiAgICAgICAgY29uc3QgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSk7XG4gICAgICAgIGNvbnN0IG1hZzIgPSBNYXRoLnNxcnQoYnggKiBieCArIGJ5ICogYnkpO1xuICAgICAgICBjb25zdCBtYWcgPSBtYWcxICogbWFnMjtcbiAgICAgICAgY29uc3QgY29zaW5lID0gbWFnICYmIGRvdChhLCBiKSAvIG1hZztcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHNBcHByb3hpbWF0ZWx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0gLSBiWzBdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IEVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50LlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdCAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHZlY3RvcnMuXG4gICAgICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIGFuZCBpbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IHZlY3RvciB0LCByZXR1cm5zXG4gICAgICogYSArIHQgKiAoYiAtIGEpLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gY29lZmZpY2llbnRzIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGVkIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZXJwVihhLCBiLCB0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyB0WzBdICogKGJbMF0gLSBhWzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSArIHRbMV0gKiAoYlsxXSAtIGFbMV0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWF4IHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgcmV0dXJuc1xuICAgICAqIFttYXgoYVswXSwgYlswXSksIG1heChhWzFdLCBiWzFdKSwgbWF4KGFbMl0sIGJbMl0pXS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4IGNvbXBvbmVudHMgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIG1pbiB2YWx1ZXMgb2YgdHdvIHZlY3RvcnMuXG4gICAgICogR2l2ZW4gdmVjdG9ycyBhIGFuZCBiIHJldHVybnNcbiAgICAgKiBbbWluKGFbMF0sIGJbMF0pLCBtaW4oYVsxXSwgYlsxXSksIG1pbihhWzJdLCBiWzJdKV0uXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1pbiBjb21wb25lbnRzIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bFNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gKiBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdICogaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhci4gKHNhbWUgYXMgbXVsU2NhbGFyKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG11bFNjYWxhcjtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdIC8gaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAvIGs7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2UgYSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnNlKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMSAvIHZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IDEgLyB2WzFdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgYSB2ZWN0b3IuIChzYW1lIGFzIGludmVyc2UpXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBpbnZlcnQgPSBpbnZlcnNlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIGEgY3Jvc3MgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcm9zcyhhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSB6O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYm90aCB2ZWN0b3JzIGhhdmVcbiAgICAgKiB0aHJlZSBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodjAgKiB2MCArIHYxICogdjEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvciAoc2FtZSBhcyBsZW5ndGgpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW4gPSBsZW5ndGg7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGhTcSh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICByZXR1cm4gdjAgKiB2MCArIHYxICogdjE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoU3EpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IGxlblNxID0gbGVuZ3RoU3E7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50cyAoc2FtZSBhcyBkaXN0YW5jZSlcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzdGFuY2VTcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50cyAoc2FtZSBhcyBkaXN0YW5jZVNxKVxuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgY29uc3QgZGlzdFNxID0gZGlzdGFuY2VTcTtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGl0cyBFdWNsaWRlYW4gbGVuZ3RoIGFuZCByZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGguc3FydCh2MCAqIHYwICsgdjEgKiB2MSk7XG4gICAgICAgIGlmIChsZW4gPiAwLjAwMDAxKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB2MCAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IHYxIC8gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyAtdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSAtdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gLXZbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzIuY2xvbmV9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayB2ZWMyLmNyZWF0ZX0gYW5kIHtAbGluayB2ZWMyLnNldH1cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGEgdmVjdG9yLiAoc2FtZSBhcyB7QGxpbmsgdmVjMi5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMi5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMi5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICogYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguIChzYW1lIGFzIG11bClcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHByb2R1Y3RzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBtdWwgPSBtdWx0aXBseTtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcXVvdGllbnRzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZpZGUoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdIC8gYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguIChzYW1lIGFzIGRpdmlkZSlcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHF1b3RpZW50cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3QgZGl2ID0gZGl2aWRlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByYW5kb20gdW5pdCB2ZWN0b3IgKiBzY2FsZVxuICAgICAqIEBwYXJhbSBzY2FsZSAtIERlZmF1bHQgMVxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJhbmRvbSB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKHNjYWxlID0gMSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5jb3MoYW5nbGUpICogc2NhbGU7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGguc2luKGFuZ2xlKSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBaZXJvJ3MgYSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB6ZXJvZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm8oZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gVmVjMiBieSA0eDQgbWF0cml4XG4gICAgICogQHBhcmFtIHYgLSB0aGUgdmVjdG9yXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBvcHRpb25hbCBWZWMyIHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NCh2LCBtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdO1xuICAgICAgICBjb25zdCB5ID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzBdID0geCAqIG1bMF0gKyB5ICogbVs0XSArIG1bMTJdO1xuICAgICAgICBuZXdEc3RbMV0gPSB4ICogbVsxXSArIHkgKiBtWzVdICsgbVsxM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdmVjNCBieSAzeDMgbWF0cml4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdiAtIHRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG9wdGlvbmFsIFZlYzIgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKHYsIG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDIpKTtcbiAgICAgICAgY29uc3QgeCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHkgPSB2WzFdO1xuICAgICAgICBuZXdEc3RbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBhIDJEIHZlY3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzIgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gICAgICogQHJldHVybnMgdGhlIHJvdGF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHJhZCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICAvLyBUcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBjb25zdCBwMCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBjb25zdCBwMSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBjb25zdCBzaW5DID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgY29uc3QgY29zQyA9IE1hdGguY29zKHJhZCk7XG4gICAgICAgIC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICAgICAgbmV3RHN0WzBdID0gcDAgKiBjb3NDIC0gcDEgKiBzaW5DICsgYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gcDAgKiBzaW5DICsgcDEgKiBjb3NDICsgYlsxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJlYXQgYSAyRCB2ZWN0b3IgYXMgYSBkaXJlY3Rpb24gYW5kIHNldCBpdCdzIGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzIgdG8gbGVuZ3RoZW5cbiAgICAgKiBAcGFyYW0gbGVuIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoZW5lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRMZW5ndGgoYSwgbGVuLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigyKSk7XG4gICAgICAgIG5vcm1hbGl6ZShhLCBuZXdEc3QpO1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKG5ld0RzdCwgbGVuLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYSB2ZWN0b3IgaXMgbm90IGxvbmdlciB0aGFuIGEgbWF4IGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzIgdG8gbGltaXRcbiAgICAgKiBAcGFyYW0gbWF4TGVuIFRoZSBsb25nZXN0IGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3RvclxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IsIHNob3J0ZW5lZCB0byBtYXhMZW4gaWYgaXQncyB0b28gbG9uZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKGEsIG1heExlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICBpZiAobGVuZ3RoKGEpID4gbWF4TGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0TGVuZ3RoKGEsIG1heExlbiwgbmV3RHN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weShhLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZlY3RvciBleGFjdGx5IGJldHdlZW4gMiBlbmRwb2ludCB2ZWN0b3JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSBFbmRwb2ludCAxXG4gICAgICogQHBhcmFtIGIgRW5kcG9pbnQgMlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IgZXhhY3RseSByZXNpZGluZyBiZXR3ZWVuIGVuZHBvaW50cyAxIGFuZCAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWlkcG9pbnQoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMikpO1xuICAgICAgICByZXR1cm4gbGVycChhLCBiLCAwLjUsIG5ld0RzdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgZnJvbVZhbHVlcyxcbiAgICAgICAgc2V0LFxuICAgICAgICBjZWlsLFxuICAgICAgICBmbG9vcixcbiAgICAgICAgcm91bmQsXG4gICAgICAgIGNsYW1wLFxuICAgICAgICBhZGQsXG4gICAgICAgIGFkZFNjYWxlZCxcbiAgICAgICAgYW5nbGUsXG4gICAgICAgIHN1YnRyYWN0LFxuICAgICAgICBzdWIsXG4gICAgICAgIGVxdWFsc0FwcHJveGltYXRlbHksXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgbGVycCxcbiAgICAgICAgbGVycFYsXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICBtdWxTY2FsYXIsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBkaXZTY2FsYXIsXG4gICAgICAgIGludmVyc2UsXG4gICAgICAgIGludmVydCxcbiAgICAgICAgY3Jvc3MsXG4gICAgICAgIGRvdCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBsZW4sXG4gICAgICAgIGxlbmd0aFNxLFxuICAgICAgICBsZW5TcSxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGRpc3QsXG4gICAgICAgIGRpc3RhbmNlU3EsXG4gICAgICAgIGRpc3RTcSxcbiAgICAgICAgbm9ybWFsaXplLFxuICAgICAgICBuZWdhdGUsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGNsb25lLFxuICAgICAgICBtdWx0aXBseSxcbiAgICAgICAgbXVsLFxuICAgICAgICBkaXZpZGUsXG4gICAgICAgIGRpdixcbiAgICAgICAgcmFuZG9tLFxuICAgICAgICB6ZXJvLFxuICAgICAgICB0cmFuc2Zvcm1NYXQ0LFxuICAgICAgICB0cmFuc2Zvcm1NYXQzLFxuICAgICAgICByb3RhdGUsXG4gICAgICAgIHNldExlbmd0aCxcbiAgICAgICAgdHJ1bmNhdGUsXG4gICAgICAgIG1pZHBvaW50LFxuICAgIH07XG59XG5jb25zdCBjYWNoZSQ1ID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0QVBJJDUoQ3Rvcikge1xuICAgIGxldCBhcGkgPSBjYWNoZSQ1LmdldChDdG9yKTtcbiAgICBpZiAoIWFwaSkge1xuICAgICAgICBhcGkgPSBnZXRBUElJbXBsJDUoQ3Rvcik7XG4gICAgICAgIGNhY2hlJDUuc2V0KEN0b3IsIGFwaSk7XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBHcmVnZyBUYXZhcmVzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGEgdHlwZWQgQVBJIGZvciBNYXQzXG4gKiAqL1xuZnVuY3Rpb24gZ2V0QVBJSW1wbCQ0KEN0b3IpIHtcbiAgICBjb25zdCB2ZWMyID0gZ2V0QVBJJDUoQ3Rvcik7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgTWF0MyBmcm9tIHZhbHVlc1xuICAgICAqXG4gICAgICogTm90ZTogU2luY2UgcGFzc2luZyBpbiBhIHJhdyBKYXZhU2NyaXB0IGFycmF5XG4gICAgICogaXMgdmFsaWQgaW4gYWxsIGNpcmN1bXN0YW5jZXMsIGlmIHlvdSB3YW50IHRvXG4gICAgICogZm9yY2UgYSBKYXZhU2NyaXB0IGFycmF5IGludG8gYSBNYXQzJ3Mgc3BlY2lmaWVkIHR5cGVcbiAgICAgKiBpdCB3b3VsZCBiZSBmYXN0ZXIgdG8gdXNlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBtID0gbWF0My5jbG9uZShzb21lSlNBcnJheSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdjAgLSB2YWx1ZSBmb3IgZWxlbWVudCAwXG4gICAgICogQHBhcmFtIHYxIC0gdmFsdWUgZm9yIGVsZW1lbnQgMVxuICAgICAqIEBwYXJhbSB2MiAtIHZhbHVlIGZvciBlbGVtZW50IDJcbiAgICAgKiBAcGFyYW0gdjMgLSB2YWx1ZSBmb3IgZWxlbWVudCAzXG4gICAgICogQHBhcmFtIHY0IC0gdmFsdWUgZm9yIGVsZW1lbnQgNFxuICAgICAqIEBwYXJhbSB2NSAtIHZhbHVlIGZvciBlbGVtZW50IDVcbiAgICAgKiBAcGFyYW0gdjYgLSB2YWx1ZSBmb3IgZWxlbWVudCA2XG4gICAgICogQHBhcmFtIHY3IC0gdmFsdWUgZm9yIGVsZW1lbnQgN1xuICAgICAqIEBwYXJhbSB2OCAtIHZhbHVlIGZvciBlbGVtZW50IDhcbiAgICAgKiBAcmV0dXJucyBtYXRyaXggY3JlYXRlZCBmcm9tIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3RvcigxMik7XG4gICAgICAgIC8vIHRvIG1ha2UgdGhlIGFycmF5IGhvbW9nZW5vdXNcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIGlmICh2MCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB2MDtcbiAgICAgICAgICAgIGlmICh2MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gdjE7XG4gICAgICAgICAgICAgICAgaWYgKHYyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gdjI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2MyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbNF0gPSB2MztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzVdID0gdjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHY1ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzZdID0gdjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbOF0gPSB2NjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzldID0gdjc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHY4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzEwXSA9IHY4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBNYXQzXG4gICAgICogQWxzbyBzZWUge0BsaW5rIG1hdDMuY3JlYXRlfSBhbmQge0BsaW5rIG1hdDMuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2MCAtIHZhbHVlIGZvciBlbGVtZW50IDBcbiAgICAgKiBAcGFyYW0gdjEgLSB2YWx1ZSBmb3IgZWxlbWVudCAxXG4gICAgICogQHBhcmFtIHYyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMlxuICAgICAqIEBwYXJhbSB2MyAtIHZhbHVlIGZvciBlbGVtZW50IDNcbiAgICAgKiBAcGFyYW0gdjQgLSB2YWx1ZSBmb3IgZWxlbWVudCA0XG4gICAgICogQHBhcmFtIHY1IC0gdmFsdWUgZm9yIGVsZW1lbnQgNVxuICAgICAqIEBwYXJhbSB2NiAtIHZhbHVlIGZvciBlbGVtZW50IDZcbiAgICAgKiBAcGFyYW0gdjcgLSB2YWx1ZSBmb3IgZWxlbWVudCA3XG4gICAgICogQHBhcmFtIHY4IC0gdmFsdWUgZm9yIGVsZW1lbnQgOFxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgTWF0MyBzZXQgZnJvbSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHYwO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MTtcbiAgICAgICAgbmV3RHN0WzJdID0gdjI7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IHYzO1xuICAgICAgICBuZXdEc3RbNV0gPSB2NDtcbiAgICAgICAgbmV3RHN0WzZdID0gdjU7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHY2O1xuICAgICAgICBuZXdEc3RbOV0gPSB2NztcbiAgICAgICAgbmV3RHN0WzEwXSA9IHY4O1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdDMgZnJvbSB0aGUgdXBwZXIgbGVmdCAzeDMgcGFydCBvZiBhIE1hdDRcbiAgICAgKiBAcGFyYW0gbTQgLSBzb3VyY2UgbWF0cml4XG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBNYXQzIG1hZGUgZnJvbSBtNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21NYXQ0KG00LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBtNFswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbTRbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IG00WzJdO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSBtNFs0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gbTRbNV07XG4gICAgICAgIG5ld0RzdFs2XSA9IG00WzZdO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSBtNFs4XTtcbiAgICAgICAgbmV3RHN0WzldID0gbTRbOV07XG4gICAgICAgIG5ld0RzdFsxMF0gPSBtNFsxMF07XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWF0MyByb3RhdGlvbiBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBNYXQzIG1hZGUgZnJvbSBxXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVF1YXQocSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHkgPSBxWzFdO1xuICAgICAgICBjb25zdCB6ID0gcVsyXTtcbiAgICAgICAgY29uc3QgdyA9IHFbM107XG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB5eCA9IHkgKiB4MjtcbiAgICAgICAgY29uc3QgeXkgPSB5ICogeTI7XG4gICAgICAgIGNvbnN0IHp4ID0geiAqIHgyO1xuICAgICAgICBjb25zdCB6eSA9IHogKiB5MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLSB5eSAtIHp6O1xuICAgICAgICBuZXdEc3RbMV0gPSB5eCArIHd6O1xuICAgICAgICBuZXdEc3RbMl0gPSB6eCAtIHd5O1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSB5eCAtIHd6O1xuICAgICAgICBuZXdEc3RbNV0gPSAxIC0geHggLSB6ejtcbiAgICAgICAgbmV3RHN0WzZdID0genkgKyB3eDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0genggKyB3eTtcbiAgICAgICAgbmV3RHN0WzldID0genkgLSB3eDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmVnYXRlcyBhIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyAtbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gLW1bMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IC1tWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSAtbVsyXTtcbiAgICAgICAgbmV3RHN0WzRdID0gLW1bNF07XG4gICAgICAgIG5ld0RzdFs1XSA9IC1tWzVdO1xuICAgICAgICBuZXdEc3RbNl0gPSAtbVs2XTtcbiAgICAgICAgbmV3RHN0WzhdID0gLW1bOF07XG4gICAgICAgIG5ld0RzdFs5XSA9IC1tWzldO1xuICAgICAgICBuZXdEc3RbMTBdID0gLW1bMTBdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBtYXRyaXguIChzYW1lIGFzIHtAbGluayBtYXQzLmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgbWF0My5jcmVhdGV9IGFuZCB7QGxpbmsgbWF0My5zZXR9XG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHkobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbVsyXTtcbiAgICAgICAgbmV3RHN0WzRdID0gbVs0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gbVs1XTtcbiAgICAgICAgbmV3RHN0WzZdID0gbVs2XTtcbiAgICAgICAgbmV3RHN0WzhdID0gbVs4XTtcbiAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG1bMTBdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBtYXRyaXggKHNhbWUgYXMge0BsaW5rIG1hdDMuY29weX0pXG4gICAgICogQWxzbyBzZWUge0BsaW5rIG1hdDMuY3JlYXRlfSBhbmQge0BsaW5rIG1hdDMuc2V0fVxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIG1hdHJpeC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2YgbS5cbiAgICAgKi9cbiAgICBjb25zdCBjbG9uZSA9IGNvcHk7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiBtYXRyaWNlcyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBiIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbWF0cmljZXMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHNBcHByb3hpbWF0ZWx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0gLSBiWzBdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMl0gLSBiWzJdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNF0gLSBiWzRdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNV0gLSBiWzVdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbNl0gLSBiWzZdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbOF0gLSBiWzhdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbOV0gLSBiWzldKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMTBdIC0gYlsxMF0pIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiBtYXRyaWNlcyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBiIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbWF0cmljZXMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJlxuICAgICAgICAgICAgYVsxXSA9PT0gYlsxXSAmJlxuICAgICAgICAgICAgYVsyXSA9PT0gYlsyXSAmJlxuICAgICAgICAgICAgYVs0XSA9PT0gYls0XSAmJlxuICAgICAgICAgICAgYVs1XSA9PT0gYls1XSAmJlxuICAgICAgICAgICAgYVs2XSA9PT0gYls2XSAmJlxuICAgICAgICAgICAgYVs4XSA9PT0gYls4XSAmJlxuICAgICAgICAgICAgYVs5XSA9PT0gYls5XSAmJlxuICAgICAgICAgICAgYVsxMF0gPT09IGJbMTBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgMy1ieS0zIGlkZW50aXR5IG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSAzLWJ5LTMgaWRlbnRpdHkgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgdHJhbnNwb3NlIG9mIGEgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc3Bvc2Ugb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc3Bvc2UobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgaWYgKG5ld0RzdCA9PT0gbSkge1xuICAgICAgICAgICAgbGV0IHQ7XG4gICAgICAgICAgICAvLyAwIDEgMlxuICAgICAgICAgICAgLy8gNCA1IDZcbiAgICAgICAgICAgIC8vIDggOSAxMFxuICAgICAgICAgICAgdCA9IG1bMV07XG4gICAgICAgICAgICBtWzFdID0gbVs0XTtcbiAgICAgICAgICAgIG1bNF0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bMl07XG4gICAgICAgICAgICBtWzJdID0gbVs4XTtcbiAgICAgICAgICAgIG1bOF0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bNl07XG4gICAgICAgICAgICBtWzZdID0gbVs5XTtcbiAgICAgICAgICAgIG1bOV0gPSB0O1xuICAgICAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbMF0gPSBtMDA7XG4gICAgICAgIG5ld0RzdFsxXSA9IG0xMDtcbiAgICAgICAgbmV3RHN0WzJdID0gbTIwO1xuICAgICAgICBuZXdEc3RbNF0gPSBtMDE7XG4gICAgICAgIG5ld0RzdFs1XSA9IG0xMTtcbiAgICAgICAgbmV3RHN0WzZdID0gbTIxO1xuICAgICAgICBuZXdEc3RbOF0gPSBtMDI7XG4gICAgICAgIG5ld0RzdFs5XSA9IG0xMjtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG0yMjtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGludmVyc2Ugb2YgYSAzLWJ5LTMgbWF0cml4LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnNlIG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJzZShtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBiMDEgPSBtMjIgKiBtMTEgLSBtMTIgKiBtMjE7XG4gICAgICAgIGNvbnN0IGIxMSA9IC1tMjIgKiBtMTAgKyBtMTIgKiBtMjA7XG4gICAgICAgIGNvbnN0IGIyMSA9IG0yMSAqIG0xMCAtIG0xMSAqIG0yMDtcbiAgICAgICAgY29uc3QgaW52RGV0ID0gMSAvIChtMDAgKiBiMDEgKyBtMDEgKiBiMTEgKyBtMDIgKiBiMjEpO1xuICAgICAgICBuZXdEc3RbMF0gPSBiMDEgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFsxXSA9ICgtbTIyICogbTAxICsgbTAyICogbTIxKSAqIGludkRldDtcbiAgICAgICAgbmV3RHN0WzJdID0gKG0xMiAqIG0wMSAtIG0wMiAqIG0xMSkgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFs0XSA9IGIxMSAqIGludkRldDtcbiAgICAgICAgbmV3RHN0WzVdID0gKG0yMiAqIG0wMCAtIG0wMiAqIG0yMCkgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFs2XSA9ICgtbTEyICogbTAwICsgbTAyICogbTEwKSAqIGludkRldDtcbiAgICAgICAgbmV3RHN0WzhdID0gYjIxICogaW52RGV0O1xuICAgICAgICBuZXdEc3RbOV0gPSAoLW0yMSAqIG0wMCArIG0wMSAqIG0yMCkgKiBpbnZEZXQ7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAobTExICogbTAwIC0gbTAxICogbTEwKSAqIGludkRldDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbSAtIHRoZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmFudChtKSB7XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gICAgICAgIHJldHVybiBtMDAgKiAobTExICogbTIyIC0gbTIxICogbTEyKSAtXG4gICAgICAgICAgICBtMTAgKiAobTAxICogbTIyIC0gbTIxICogbTAyKSArXG4gICAgICAgICAgICBtMjAgKiAobTAxICogbTEyIC0gbTExICogbTAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGludmVyc2Ugb2YgYSAzLWJ5LTMgbWF0cml4LiAoc2FtZSBhcyBpbnZlcnNlKVxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnNlIG9mIG0uXG4gICAgICovXG4gICAgY29uc3QgaW52ZXJ0ID0gaW52ZXJzZTtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byAzLWJ5LTMgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodFxuICAgICAqIEBwYXJhbSBhIC0gVGhlIG1hdHJpeCBvbiB0aGUgbGVmdC5cbiAgICAgKiBAcGFyYW0gYiAtIFRoZSBtYXRyaXggb24gdGhlIHJpZ2h0LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCBwcm9kdWN0IG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgYTAwID0gYVswXTtcbiAgICAgICAgY29uc3QgYTAxID0gYVsxXTtcbiAgICAgICAgY29uc3QgYTAyID0gYVsyXTtcbiAgICAgICAgY29uc3QgYTEwID0gYVs0ICsgMF07XG4gICAgICAgIGNvbnN0IGExMSA9IGFbNCArIDFdO1xuICAgICAgICBjb25zdCBhMTIgPSBhWzQgKyAyXTtcbiAgICAgICAgY29uc3QgYTIwID0gYVs4ICsgMF07XG4gICAgICAgIGNvbnN0IGEyMSA9IGFbOCArIDFdO1xuICAgICAgICBjb25zdCBhMjIgPSBhWzggKyAyXTtcbiAgICAgICAgY29uc3QgYjAwID0gYlswXTtcbiAgICAgICAgY29uc3QgYjAxID0gYlsxXTtcbiAgICAgICAgY29uc3QgYjAyID0gYlsyXTtcbiAgICAgICAgY29uc3QgYjEwID0gYls0ICsgMF07XG4gICAgICAgIGNvbnN0IGIxMSA9IGJbNCArIDFdO1xuICAgICAgICBjb25zdCBiMTIgPSBiWzQgKyAyXTtcbiAgICAgICAgY29uc3QgYjIwID0gYls4ICsgMF07XG4gICAgICAgIGNvbnN0IGIyMSA9IGJbOCArIDFdO1xuICAgICAgICBjb25zdCBiMjIgPSBiWzggKyAyXTtcbiAgICAgICAgbmV3RHN0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgICAgICBuZXdEc3RbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgICAgIG5ld0RzdFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICAgICAgbmV3RHN0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgICAgICBuZXdEc3RbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgICAgIG5ld0RzdFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICAgICAgbmV3RHN0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgICAgICBuZXdEc3RbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIDMtYnktMyBtYXRyaWNlcyB3aXRoIGEgb24gdGhlIGxlZnQgYW5kIGIgb24gdGhlIHJpZ2h0IChzYW1lIGFzIG11bHRpcGx5KVxuICAgICAqIEBwYXJhbSBhIC0gVGhlIG1hdHJpeCBvbiB0aGUgbGVmdC5cbiAgICAgKiBAcGFyYW0gYiAtIFRoZSBtYXRyaXggb24gdGhlIHJpZ2h0LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCBwcm9kdWN0IG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3QgbXVsID0gbXVsdGlwbHk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgMy1ieS0zIG1hdHJpeCB0byB0aGUgZ2l2ZW5cbiAgICAgKiB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGEgLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggd2l0aCB0cmFuc2xhdGlvbiBzZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0VHJhbnNsYXRpb24oYSwgdiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gaWRlbnRpdHkoKSk7XG4gICAgICAgIGlmIChhICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IGFbMF07XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSBhWzFdO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gYVsyXTtcbiAgICAgICAgICAgIG5ld0RzdFs0XSA9IGFbNF07XG4gICAgICAgICAgICBuZXdEc3RbNV0gPSBhWzVdO1xuICAgICAgICAgICAgbmV3RHN0WzZdID0gYVs2XTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEc3RbOF0gPSB2WzBdO1xuICAgICAgICBuZXdEc3RbOV0gPSB2WzFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgMy1ieS0zIG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDNcbiAgICAgKiBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyB2ZWMyLmNyZWF0ZSgpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVs4XTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVs5XTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBheGlzIG9mIGEgM3gzIG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDIgZW50cmllc1xuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzIDAgPSB4LCAxID0geSxcbiAgICAgKiBAcmV0dXJucyBUaGUgYXhpcyBjb21wb25lbnQgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBeGlzKG0sIGF4aXMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IHZlYzIuY3JlYXRlKCkpO1xuICAgICAgICBjb25zdCBvZmYgPSBheGlzICogNDtcbiAgICAgICAgbmV3RHN0WzBdID0gbVtvZmYgKyAwXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVtvZmYgKyAxXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBheGlzIG9mIGEgM3gzIG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDIgZW50cmllc1xuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIHRoZSBheGlzIHZlY3RvclxuICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXMgIDAgPSB4LCAxID0geTtcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIG1hdHJpeCB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCB3aXRoIGF4aXMgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEF4aXMobSwgdiwgYXhpcywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPT09IG0gPyBtIDogY29weShtLCBkc3QpKTtcbiAgICAgICAgY29uc3Qgb2ZmID0gYXhpcyAqIDQ7XG4gICAgICAgIG5ld0RzdFtvZmYgKyAwXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFtvZmYgKyAxXSA9IHZbMV07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8vLyoqXG4gICAgLy8gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGNvbXBvbmVudCBvZiB0aGUgbWF0cml4XG4gICAgLy8gKiBAcGFyYW0gbSAtIFRoZSBNYXRyaXhcbiAgICAvLyAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAvLyAqL1xuICAgIGZ1bmN0aW9uIGdldFNjYWxpbmcobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gdmVjMi5jcmVhdGUoKSk7XG4gICAgICAgIGNvbnN0IHh4ID0gbVswXTtcbiAgICAgICAgY29uc3QgeHkgPSBtWzFdO1xuICAgICAgICBjb25zdCB5eCA9IG1bNF07XG4gICAgICAgIGNvbnN0IHl5ID0gbVs1XTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5zcXJ0KHh4ICogeHggKyB4eSAqIHh5KTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5zcXJ0KHl4ICogeXggKyB5eSAqIHl5KTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIDMtYnktMyBtYXRyaXggd2hpY2ggdHJhbnNsYXRlcyBieSB0aGUgZ2l2ZW4gdmVjdG9yIHYuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yIGJ5IHdoaWNoIHRvIHRyYW5zbGF0ZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2xhdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRpb24odiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzldID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGdpdmVuIDMtYnktMyBtYXRyaXggYnkgdGhlIGdpdmVuIHZlY3RvciB2LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IgYnkgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zbGF0ZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShtLCB2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgbTAwID0gbVswXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVsxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVsyXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTIwID0gbVsyICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMjEgPSBtWzIgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMiAqIDQgKyAyXTtcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gbTAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gbTAxO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gbTAyO1xuICAgICAgICAgICAgbmV3RHN0WzRdID0gbTEwO1xuICAgICAgICAgICAgbmV3RHN0WzVdID0gbTExO1xuICAgICAgICAgICAgbmV3RHN0WzZdID0gbTEyO1xuICAgICAgICB9XG4gICAgICAgIG5ld0RzdFs4XSA9IG0wMCAqIHYwICsgbTEwICogdjEgKyBtMjA7XG4gICAgICAgIG5ld0RzdFs5XSA9IG0wMSAqIHYwICsgbTExICogdjEgKyBtMjE7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBtMDIgKiB2MCArIG0xMiAqIHYxICsgbTIyO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgMy1ieS0zIG1hdHJpeCB3aGljaCByb3RhdGVzICBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRpb24gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBjO1xuICAgICAgICBuZXdEc3RbMV0gPSBzO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAtcztcbiAgICAgICAgbmV3RHN0WzVdID0gYztcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIDMtYnktMyBtYXRyaXggIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlKG0sIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxMikpO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBjICogbTAwICsgcyAqIG0xMDtcbiAgICAgICAgbmV3RHN0WzFdID0gYyAqIG0wMSArIHMgKiBtMTE7XG4gICAgICAgIG5ld0RzdFsyXSA9IGMgKiBtMDIgKyBzICogbTEyO1xuICAgICAgICBuZXdEc3RbNF0gPSBjICogbTEwIC0gcyAqIG0wMDtcbiAgICAgICAgbmV3RHN0WzVdID0gYyAqIG0xMSAtIHMgKiBtMDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IGMgKiBtMTIgLSBzICogbTAyO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBtWzhdO1xuICAgICAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBtWzEwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgMy1ieS0zIG1hdHJpeCB3aGljaCBzY2FsZXMgaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50IGdpdmVuIGJ5XG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdGhlIGdpdmVuIHZlY3RvcjsgYXNzdW1lcyB0aGUgdmVjdG9yIGhhcyB0aHJlZVxuICAgICAqIGVudHJpZXMuXG4gICAgICogQHBhcmFtIHYgLSBBIHZlY3RvciBvZlxuICAgICAqICAgICAyIGVudHJpZXMgc3BlY2lmeWluZyB0aGUgZmFjdG9yIGJ5IHdoaWNoIHRvIHNjYWxlIGluIGVhY2ggZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxpbmcgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjYWxpbmcodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgZ2l2ZW4gMy1ieS0zIG1hdHJpeCBpbiBlYWNoIGRpbWVuc2lvbiBieSBhbiBhbW91bnRcbiAgICAgKiBnaXZlbiBieSB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXggdG8gYmUgbW9kaWZpZWQuXG4gICAgICogQHBhcmFtIHYgLSBBIHZlY3RvciBvZiAyIGVudHJpZXMgc3BlY2lmeWluZyB0aGVcbiAgICAgKiAgICAgZmFjdG9yIGJ5IHdoaWNoIHRvIHNjYWxlIGluIGVhY2ggZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NhbGUobSwgdiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTIpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFswXSA9IHYwICogbVswICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gdjAgKiBtWzAgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFs0XSA9IHYxICogbVsxICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbNV0gPSB2MSAqIG1bMSAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzZdID0gdjEgKiBtWzEgKiA0ICsgMl07XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFs4XSA9IG1bOF07XG4gICAgICAgICAgICBuZXdEc3RbOV0gPSBtWzldO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IG1bMTBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSAzLWJ5LTMgbWF0cml4IHdoaWNoIHNjYWxlcyB1bmlmb3JtbHkgaW4gZWFjaCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0gcyAtIEFtb3VudCB0byBzY2FsZVxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxpbmcgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaWZvcm1TY2FsaW5nKHMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHM7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHM7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIGdpdmVuIDMtYnktMyBtYXRyaXggaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50XG4gICAgICogZ2l2ZW4uXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSBzIC0gQW1vdW50IHRvIHNjYWxlLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pZm9ybVNjYWxlKG0sIHMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDEyKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHMgKiBtWzAgKiA0ICsgMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHMgKiBtWzAgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHMgKiBtWzAgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFs0XSA9IHMgKiBtWzEgKiA0ICsgMF07XG4gICAgICAgIG5ld0RzdFs1XSA9IHMgKiBtWzEgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IHMgKiBtWzEgKiA0ICsgMl07XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFs4XSA9IG1bOF07XG4gICAgICAgICAgICBuZXdEc3RbOV0gPSBtWzldO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IG1bMTBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNsb25lLFxuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHNldCxcbiAgICAgICAgZnJvbU1hdDQsXG4gICAgICAgIGZyb21RdWF0LFxuICAgICAgICBuZWdhdGUsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGVxdWFsc0FwcHJveGltYXRlbHksXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgaWRlbnRpdHksXG4gICAgICAgIHRyYW5zcG9zZSxcbiAgICAgICAgaW52ZXJzZSxcbiAgICAgICAgaW52ZXJ0LFxuICAgICAgICBkZXRlcm1pbmFudCxcbiAgICAgICAgbXVsLFxuICAgICAgICBtdWx0aXBseSxcbiAgICAgICAgc2V0VHJhbnNsYXRpb24sXG4gICAgICAgIGdldFRyYW5zbGF0aW9uLFxuICAgICAgICBnZXRBeGlzLFxuICAgICAgICBzZXRBeGlzLFxuICAgICAgICBnZXRTY2FsaW5nLFxuICAgICAgICB0cmFuc2xhdGlvbixcbiAgICAgICAgdHJhbnNsYXRlLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgcm90YXRlLFxuICAgICAgICBzY2FsaW5nLFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgdW5pZm9ybVNjYWxpbmcsXG4gICAgICAgIHVuaWZvcm1TY2FsZSxcbiAgICB9O1xufVxuY29uc3QgY2FjaGUkNCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEFQSSQ0KEN0b3IpIHtcbiAgICBsZXQgYXBpID0gY2FjaGUkNC5nZXQoQ3Rvcik7XG4gICAgaWYgKCFhcGkpIHtcbiAgICAgICAgYXBpID0gZ2V0QVBJSW1wbCQ0KEN0b3IpO1xuICAgICAgICBjYWNoZSQ0LnNldChDdG9yLCBhcGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXBpO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMjIgR3JlZ2cgVGF2YXJlc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIEdlbmVyYXRlcyBhbSB0eXBlZCBBUEkgZm9yIFZlYzNcbiAqICovXG5mdW5jdGlvbiBnZXRBUElJbXBsJDMoQ3Rvcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2ZWMzOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHgsIHksIHopIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gbmV3IEN0b3IoMyk7XG4gICAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHg7XG4gICAgICAgICAgICBpZiAoeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0geTtcbiAgICAgICAgICAgICAgICBpZiAoeiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IHo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2ZWMzOyBtYXkgYmUgY2FsbGVkIHdpdGggeCwgeSwgeiB0byBzZXQgaW5pdGlhbCB2YWx1ZXMuIChzYW1lIGFzIGNyZWF0ZSlcbiAgICAgKiBAcGFyYW0geCAtIEluaXRpYWwgeCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geSAtIEluaXRpYWwgeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geiAtIEluaXRpYWwgeiB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBjb25zdCBmcm9tVmFsdWVzID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBvZiBhIFZlYzNcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMy5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMy5jb3B5fVxuICAgICAqXG4gICAgICogQHBhcmFtIHggZmlyc3QgdmFsdWVcbiAgICAgKiBAcGFyYW0geSBzZWNvbmQgdmFsdWVcbiAgICAgKiBAcGFyYW0geiB0aGlyZCB2YWx1ZVxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3Igd2l0aCBpdHMgZWxlbWVudHMgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldCh4LCB5LCB6LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHg7XG4gICAgICAgIG5ld0RzdFsxXSA9IHk7XG4gICAgICAgIG5ld0RzdFsyXSA9IHo7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgTWF0aC5jZWlsIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgY2VpbCBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjZWlsKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5jZWlsKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLmNlaWwodlsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGguY2VpbCh2WzJdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLmZsb29yIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZmxvb3Igb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxvb3IodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLmZsb29yKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLmZsb29yKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLmZsb29yKHZbMl0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGgucm91bmQgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSByb3VuZCBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgucm91bmQodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgucm91bmQodlsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGgucm91bmQodlsyXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3IgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIG1heCAtIE1pbiB2YWx1ZSwgZGVmYXVsdCAwXG4gICAgICogQHBhcmFtIG1pbiAtIE1heCB2YWx1ZSwgZGVmYXVsdCAxXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IHRoZSBjbGFtcGVkIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKHYsIG1pbiA9IDAsIG1heCA9IDEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMF0pKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMV0pKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMl0pKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmVjdG9yczsgYXNzdW1lcyBhIGFuZCBiIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIGJbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIHZlY3RvcnMsIHNjYWxpbmcgdGhlIDJuZDsgYXNzdW1lcyBhIGFuZCBiIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBBbW91bnQgdG8gc2NhbGUgYlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgc3VtIG9mIGEgKyBiICogc2NhbGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkU2NhbGVkKGEsIGIsIHNjYWxlLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgVGhlIGFuZ2xlIGluIHJhZGlhbnMgYmV0d2VlbiB0aGUgMiB2ZWN0b3JzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYXggPSBhWzBdO1xuICAgICAgICBjb25zdCBheSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGF6ID0gYVsyXTtcbiAgICAgICAgY29uc3QgYnggPSBiWzBdO1xuICAgICAgICBjb25zdCBieSA9IGJbMV07XG4gICAgICAgIGNvbnN0IGJ6ID0gYlsyXTtcbiAgICAgICAgY29uc3QgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopO1xuICAgICAgICBjb25zdCBtYWcyID0gTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieik7XG4gICAgICAgIGNvbnN0IG1hZyA9IG1hZzEgKiBtYWcyO1xuICAgICAgICBjb25zdCBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0d28gdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBkaWZmZXJlbmNlIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHNBcHByb3hpbWF0ZWx5KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0gLSBiWzBdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMl0gLSBiWzJdKSA8IEVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgdmVjdG9ycyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHZlY3RvcnMgYXJlIGV4YWN0bHkgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiBhbmQgaW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudCB0LCByZXR1cm5zXG4gICAgICogYSArIHQgKiAoYiAtIGEpLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gY29lZmZpY2llbnQuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVycChhLCBiLCB0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyB0ICogKGJbMF0gLSBhWzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSArIHQgKiAoYlsxXSAtIGFbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICsgdCAqIChiWzJdIC0gYVsyXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiBhbmQgaW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudCB2ZWN0b3IgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50cyB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVycFYoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdFswXSAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0WzFdICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHRbMl0gKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbWF4IHZhbHVlcyBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgcmV0dXJuc1xuICAgICAqIFttYXgoYVswXSwgYlswXSksIG1heChhWzFdLCBiWzFdKSwgbWF4KGFbMl0sIGJbMl0pXS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF4IGNvbXBvbmVudHMgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBtaW4gdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gICAgICogW21pbihhWzBdLCBiWzBdKSwgbWluKGFbMV0sIGJbMV0pLCBtaW4oYVsyXSwgYlsyXSldLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtaW4gY29tcG9uZW50cyB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsU2NhbGFyKHYsIGssIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXSAqIGs7XG4gICAgICAgIG5ld0RzdFsxXSA9IHZbMV0gKiBrO1xuICAgICAgICBuZXdEc3RbMl0gPSB2WzJdICogaztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhci4gKHNhbWUgYXMgbXVsU2NhbGFyKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG11bFNjYWxhcjtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2NhbGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXZTY2FsYXIodiwgaywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSB2WzBdIC8gaztcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXSAvIGs7XG4gICAgICAgIG5ld0RzdFsyXSA9IHZbMl0gLyBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIGEgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnRlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJzZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLyB2WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAxIC8gdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gMSAvIHZbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVydCBhIHZlY3Rvci4gKHNhbWUgYXMgaW52ZXJzZSlcbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW52ZXJ0ZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IGludmVydCA9IGludmVyc2U7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnM7IGFzc3VtZXMgYm90aCB2ZWN0b3JzIGhhdmVcbiAgICAgKiB0aHJlZSBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgYSBjcm9zcyBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyb3NzKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgdDEgPSBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdO1xuICAgICAgICBjb25zdCB0MiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV07XG4gICAgICAgIG5ld0RzdFsxXSA9IHQxO1xuICAgICAgICBuZXdEc3RbMl0gPSB0MjtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzOyBhc3N1bWVzIGJvdGggdmVjdG9ycyBoYXZlXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb3QoYSwgYikge1xuICAgICAgICByZXR1cm4gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYlsxXSkgKyAoYVsyXSAqIGJbMl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2MCAqIHYwICsgdjEgKiB2MSArIHYyICogdjIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvciAoc2FtZSBhcyBsZW5ndGgpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW4gPSBsZW5ndGg7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGhTcSh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIHJldHVybiB2MCAqIHYwICsgdjEgKiB2MSArIHYyICogdjI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoU3EpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IGxlblNxID0gbGVuZ3RoU3E7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIGNvbnN0IGR6ID0gYVsyXSAtIGJbMl07XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgKHNhbWUgYXMgZGlzdGFuY2UpXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgY29uc3QgZGlzdCA9IGRpc3RhbmNlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc3RhbmNlU3EoYSwgYikge1xuICAgICAgICBjb25zdCBkeCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBjb25zdCBkeSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBjb25zdCBkeiA9IGFbMl0gLSBiWzJdO1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzIChzYW1lIGFzIGRpc3RhbmNlU3EpXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBjb25zdCBkaXN0U3EgPSBkaXN0YW5jZVNxO1xuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIEV1Y2xpZGVhbiBsZW5ndGggYW5kIHJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLnNxcnQodjAgKiB2MCArIHYxICogdjEgKyB2MiAqIHYyKTtcbiAgICAgICAgaWYgKGxlbiA+IDAuMDAwMDEpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHYwIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gdjEgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSB2MiAvIGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGEgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIC12LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IC12WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAtdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gLXZbMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzMuY2xvbmV9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayB2ZWMzLmNyZWF0ZX0gYW5kIHtAbGluayB2ZWMzLnNldH1cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGEgdmVjdG9yLiAoc2FtZSBhcyB7QGxpbmsgdmVjMy5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjMy5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjMy5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICogYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiAoc2FtZSBhcyBtdWwpXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3QgbXVsID0gbXVsdGlwbHk7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdmVjdG9yIG9mIHF1b3RpZW50cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGl2aWRlKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAvIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC4gKHNhbWUgYXMgZGl2aWRlKVxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcXVvdGllbnRzIG9mIGVudHJpZXMgb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBjb25zdCBkaXYgPSBkaXZpZGU7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJhbmRvbSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBEZWZhdWx0IDFcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByYW5kb20gdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShzY2FsZSA9IDEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IHogPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICAgIGNvbnN0IHpTY2FsZSA9IE1hdGguc3FydCgxIC0geiAqIHopICogc2NhbGU7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguY29zKGFuZ2xlKSAqIHpTY2FsZTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5zaW4oYW5nbGUpICogelNjYWxlO1xuICAgICAgICBuZXdEc3RbMl0gPSB6ICogc2NhbGU7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFplcm8ncyBhIHZlY3RvclxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHplcm9lZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gemVybyhkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybSB2ZWMzIGJ5IDR4NCBtYXRyaXhcbiAgICAgKiBAcGFyYW0gdiAtIHRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG9wdGlvbmFsIHZlYzMgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KHYsIG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgeCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHkgPSB2WzFdO1xuICAgICAgICBjb25zdCB6ID0gdlsyXTtcbiAgICAgICAgY29uc3QgdyA9IChtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0pIHx8IDE7XG4gICAgICAgIG5ld0RzdFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICAgICAgICBuZXdEc3RbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICAgICAgbmV3RHN0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gdmVjMyBieSB1cHBlciAzeDMgbWF0cml4IGluc2lkZSA0eDQgbWF0cml4LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIGRpcmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG9wdGlvbmFsIHZlYzMgdG8gc3RvcmUgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm1lZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NFVwcGVyM3gzKHYsIG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgbmV3RHN0WzBdID0gdjAgKiBtWzAgKiA0ICsgMF0gKyB2MSAqIG1bMSAqIDQgKyAwXSArIHYyICogbVsyICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXSArIHYxICogbVsxICogNCArIDFdICsgdjIgKiBtWzIgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHYwICogbVswICogNCArIDJdICsgdjEgKiBtWzEgKiA0ICsgMl0gKyB2MiAqIG1bMiAqIDQgKyAyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB2ZWMzIGJ5IDN4MyBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2IC0gdGhlIHZlY3RvclxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gb3B0aW9uYWwgdmVjMyB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHRyYW5zZm9ybWVkIHZlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDModiwgbSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCB4ID0gdlswXTtcbiAgICAgICAgY29uc3QgeSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHogPSB2WzJdO1xuICAgICAgICBuZXdEc3RbMF0gPSB4ICogbVswXSArIHkgKiBtWzRdICsgeiAqIG1bOF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNV0gKyB6ICogbVs5XTtcbiAgICAgICAgbmV3RHN0WzJdID0geCAqIG1bMl0gKyB5ICogbVs2XSArIHogKiBtWzEwXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB2ZWMzIGJ5IFF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gdiAtIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHEgLSB0aGUgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gYnlcbiAgICAgKiBAcGFyYW0gZHN0IC0gb3B0aW9uYWwgdmVjMyB0byBzdG9yZSByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHRyYW5zZm9ybWVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdCh2LCBxLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHF4ID0gcVswXTtcbiAgICAgICAgY29uc3QgcXkgPSBxWzFdO1xuICAgICAgICBjb25zdCBxeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHcyID0gcVszXSAqIDI7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdO1xuICAgICAgICBjb25zdCB5ID0gdlsxXTtcbiAgICAgICAgY29uc3QgeiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHV2WCA9IHF5ICogeiAtIHF6ICogeTtcbiAgICAgICAgY29uc3QgdXZZID0gcXogKiB4IC0gcXggKiB6O1xuICAgICAgICBjb25zdCB1dlogPSBxeCAqIHkgLSBxeSAqIHg7XG4gICAgICAgIG5ld0RzdFswXSA9IHggKyB1dlggKiB3MiArIChxeSAqIHV2WiAtIHF6ICogdXZZKSAqIDI7XG4gICAgICAgIG5ld0RzdFsxXSA9IHkgKyB1dlkgKiB3MiArIChxeiAqIHV2WCAtIHF4ICogdXZaKSAqIDI7XG4gICAgICAgIG5ld0RzdFsyXSA9IHogKyB1dlogKiB3MiArIChxeCAqIHV2WSAtIHF5ICogdXZYKSAqIDI7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDQtYnktNCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzXG4gICAgICogZW50cmllcy5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBuZXdEc3RbMF0gPSBtWzEyXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxM107XG4gICAgICAgIG5ld0RzdFsyXSA9IG1bMTRdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXMgMCA9IHgsIDEgPSB5LCAyID0gejtcbiAgICAgKiBAcmV0dXJucyBUaGUgYXhpcyBjb21wb25lbnQgb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBeGlzKG0sIGF4aXMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3Qgb2ZmID0gYXhpcyAqIDQ7XG4gICAgICAgIG5ld0RzdFswXSA9IG1bb2ZmICsgMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bb2ZmICsgMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IG1bb2ZmICsgMl07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjYWxpbmcgY29tcG9uZW50IG9mIHRoZSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBNYXRyaXhcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIHZlY3RvciB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2NhbGluZyhtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIGNvbnN0IHh4ID0gbVswXTtcbiAgICAgICAgY29uc3QgeHkgPSBtWzFdO1xuICAgICAgICBjb25zdCB4eiA9IG1bMl07XG4gICAgICAgIGNvbnN0IHl4ID0gbVs0XTtcbiAgICAgICAgY29uc3QgeXkgPSBtWzVdO1xuICAgICAgICBjb25zdCB5eiA9IG1bNl07XG4gICAgICAgIGNvbnN0IHp4ID0gbVs4XTtcbiAgICAgICAgY29uc3QgenkgPSBtWzldO1xuICAgICAgICBjb25zdCB6eiA9IG1bMTBdO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLnNxcnQoeHggKiB4eCArIHh5ICogeHkgKyB4eiAqIHh6KTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5zcXJ0KHl4ICogeXggKyB5eSAqIHl5ICsgeXogKiB5eik7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGguc3FydCh6eCAqIHp4ICsgenkgKiB6eSArIHp6ICogenopO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgcm90YXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVYKGEsIGIsIHJhZCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCBwID0gW107XG4gICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgICAgICBwWzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgICAgICAvL3BlcmZvcm0gcm90YXRpb25cbiAgICAgICAgclswXSA9IHBbMF07XG4gICAgICAgIHJbMV0gPSBwWzFdICogTWF0aC5jb3MocmFkKSAtIHBbMl0gKiBNYXRoLnNpbihyYWQpO1xuICAgICAgICByWzJdID0gcFsxXSAqIE1hdGguc2luKHJhZCkgKyBwWzJdICogTWF0aC5jb3MocmFkKTtcbiAgICAgICAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgICAgICBuZXdEc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gclsxXSArIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHJbMl0gKyBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgcm90YXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVZKGEsIGIsIHJhZCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBjb25zdCBwID0gW107XG4gICAgICAgIGNvbnN0IHIgPSBbXTtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICAgICAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBwWzFdID0gYVsxXSAtIGJbMV07XG4gICAgICAgIHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgLy8gcGVyZm9ybSByb3RhdGlvblxuICAgICAgICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgICAgICAgclsxXSA9IHBbMV07XG4gICAgICAgIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpO1xuICAgICAgICAvLyB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgICAgICBuZXdEc3RbMF0gPSByWzBdICsgYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gclsxXSArIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHJbMl0gKyBiWzJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgdmVjdG9yIHRvIHNldC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWihhLCBiLCByYWQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDMpKTtcbiAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgIC8vIHRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgICAgIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgICAgICAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBwWzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIC8vIHBlcmZvcm0gcm90YXRpb25cbiAgICAgICAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gICAgICAgIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICAgICAgICByWzJdID0gcFsyXTtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICAgICAgbmV3RHN0WzBdID0gclswXSArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHJbMV0gKyBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSByWzJdICsgYlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJlYXQgYSAzRCB2ZWN0b3IgYXMgYSBkaXJlY3Rpb24gYW5kIHNldCBpdCdzIGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzMgdG8gbGVuZ3RoZW5cbiAgICAgKiBAcGFyYW0gbGVuIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoZW5lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRMZW5ndGgoYSwgbGVuLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigzKSk7XG4gICAgICAgIG5vcm1hbGl6ZShhLCBuZXdEc3QpO1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKG5ld0RzdCwgbGVuLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYSB2ZWN0b3IgaXMgbm90IGxvbmdlciB0aGFuIGEgbWF4IGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzMgdG8gbGltaXRcbiAgICAgKiBAcGFyYW0gbWF4TGVuIFRoZSBsb25nZXN0IGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3RvclxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IsIHNob3J0ZW5lZCB0byBtYXhMZW4gaWYgaXQncyB0b28gbG9uZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKGEsIG1heExlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICBpZiAobGVuZ3RoKGEpID4gbWF4TGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0TGVuZ3RoKGEsIG1heExlbiwgbmV3RHN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weShhLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZlY3RvciBleGFjdGx5IGJldHdlZW4gMiBlbmRwb2ludCB2ZWN0b3JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSBFbmRwb2ludCAxXG4gICAgICogQHBhcmFtIGIgRW5kcG9pbnQgMlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IgZXhhY3RseSByZXNpZGluZyBiZXR3ZWVuIGVuZHBvaW50cyAxIGFuZCAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWlkcG9pbnQoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMykpO1xuICAgICAgICByZXR1cm4gbGVycChhLCBiLCAwLjUsIG5ld0RzdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgZnJvbVZhbHVlcyxcbiAgICAgICAgc2V0LFxuICAgICAgICBjZWlsLFxuICAgICAgICBmbG9vcixcbiAgICAgICAgcm91bmQsXG4gICAgICAgIGNsYW1wLFxuICAgICAgICBhZGQsXG4gICAgICAgIGFkZFNjYWxlZCxcbiAgICAgICAgYW5nbGUsXG4gICAgICAgIHN1YnRyYWN0LFxuICAgICAgICBzdWIsXG4gICAgICAgIGVxdWFsc0FwcHJveGltYXRlbHksXG4gICAgICAgIGVxdWFscyxcbiAgICAgICAgbGVycCxcbiAgICAgICAgbGVycFYsXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICBtdWxTY2FsYXIsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBkaXZTY2FsYXIsXG4gICAgICAgIGludmVyc2UsXG4gICAgICAgIGludmVydCxcbiAgICAgICAgY3Jvc3MsXG4gICAgICAgIGRvdCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBsZW4sXG4gICAgICAgIGxlbmd0aFNxLFxuICAgICAgICBsZW5TcSxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGRpc3QsXG4gICAgICAgIGRpc3RhbmNlU3EsXG4gICAgICAgIGRpc3RTcSxcbiAgICAgICAgbm9ybWFsaXplLFxuICAgICAgICBuZWdhdGUsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGNsb25lLFxuICAgICAgICBtdWx0aXBseSxcbiAgICAgICAgbXVsLFxuICAgICAgICBkaXZpZGUsXG4gICAgICAgIGRpdixcbiAgICAgICAgcmFuZG9tLFxuICAgICAgICB6ZXJvLFxuICAgICAgICB0cmFuc2Zvcm1NYXQ0LFxuICAgICAgICB0cmFuc2Zvcm1NYXQ0VXBwZXIzeDMsXG4gICAgICAgIHRyYW5zZm9ybU1hdDMsXG4gICAgICAgIHRyYW5zZm9ybVF1YXQsXG4gICAgICAgIGdldFRyYW5zbGF0aW9uLFxuICAgICAgICBnZXRBeGlzLFxuICAgICAgICBnZXRTY2FsaW5nLFxuICAgICAgICByb3RhdGVYLFxuICAgICAgICByb3RhdGVZLFxuICAgICAgICByb3RhdGVaLFxuICAgICAgICBzZXRMZW5ndGgsXG4gICAgICAgIHRydW5jYXRlLFxuICAgICAgICBtaWRwb2ludCxcbiAgICB9O1xufVxuY29uc3QgY2FjaGUkMyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEFQSSQzKEN0b3IpIHtcbiAgICBsZXQgYXBpID0gY2FjaGUkMy5nZXQoQ3Rvcik7XG4gICAgaWYgKCFhcGkpIHtcbiAgICAgICAgYXBpID0gZ2V0QVBJSW1wbCQzKEN0b3IpO1xuICAgICAgICBjYWNoZSQzLnNldChDdG9yLCBhcGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXBpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHR5cGVkIEFQSSBmb3IgTWF0NFxuICogKi9cbmZ1bmN0aW9uIGdldEFQSUltcGwkMihDdG9yKSB7XG4gICAgY29uc3QgdmVjMyA9IGdldEFQSSQzKEN0b3IpO1xuICAgIC8qKlxuICAgICAqIDR4NCBNYXRyaXggbWF0aCBtYXRoIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEFsbW9zdCBhbGwgZnVuY3Rpb25zIHRha2UgYW4gb3B0aW9uYWwgYG5ld0RzdGAgYXJndW1lbnQuIElmIGl0IGlzIG5vdCBwYXNzZWQgaW4gdGhlXG4gICAgICogZnVuY3Rpb25zIHdpbGwgY3JlYXRlIGEgbmV3IG1hdHJpeC4gSW4gb3RoZXIgd29yZHMgeW91IGNhbiBkbyB0aGlzXG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgbWF0ID0gbWF0NC50cmFuc2xhdGlvbihbMSwgMiwgM10pOyAgLy8gQ3JlYXRlcyBhIG5ldyB0cmFuc2xhdGlvbiBtYXRyaXhcbiAgICAgKlxuICAgICAqIG9yXG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgbWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgKiAgICAgbWF0NC50cmFuc2xhdGlvbihbMSwgMiwgM10sIG1hdCk7ICAvLyBQdXRzIHRyYW5zbGF0aW9uIG1hdHJpeCBpbiBtYXQuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3Qgc3R5bGUgaXMgb2Z0ZW4gZWFzaWVyIGJ1dCBkZXBlbmRpbmcgb24gd2hlcmUgaXQncyB1c2VkIGl0IGdlbmVyYXRlcyBnYXJiYWdlIHdoZXJlXG4gICAgICogYXMgdGhlcmUgaXMgYWxtb3N0IG5ldmVyIGFsbG9jYXRpb24gd2l0aCB0aGUgc2Vjb25kIHN0eWxlLlxuICAgICAqXG4gICAgICogSXQgaXMgYWx3YXlzIHNhdmUgdG8gcGFzcyBhbnkgbWF0cml4IGFzIHRoZSBkZXN0aW5hdGlvbi4gU28gZm9yIGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBjb25zdCBtYXQgPSBtYXQ0LmlkZW50aXR5KCk7XG4gICAgICogICAgIGNvbnN0IHRyYW5zID0gbWF0NC50cmFuc2xhdGlvbihbMSwgMiwgM10pO1xuICAgICAqICAgICBtYXQ0Lm11bHRpcGx5KG1hdCwgdHJhbnMsIG1hdCk7ICAvLyBNdWx0aXBsaWVzIG1hdCAqIHRyYW5zIGFuZCBwdXRzIHJlc3VsdCBpbiBtYXQuXG4gICAgICpcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBNYXQ0IGZyb20gdmFsdWVzXG4gICAgICpcbiAgICAgKiBOb3RlOiBTaW5jZSBwYXNzaW5nIGluIGEgcmF3IEphdmFTY3JpcHQgYXJyYXlcbiAgICAgKiBpcyB2YWxpZCBpbiBhbGwgY2lyY3Vtc3RhbmNlcywgaWYgeW91IHdhbnQgdG9cbiAgICAgKiBmb3JjZSBhIEphdmFTY3JpcHQgYXJyYXkgaW50byBhIE1hdDQncyBzcGVjaWZpZWQgdHlwZVxuICAgICAqIGl0IHdvdWxkIGJlIGZhc3RlciB0byB1c2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IG0gPSBtYXQ0LmNsb25lKHNvbWVKU0FycmF5KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2MCAtIHZhbHVlIGZvciBlbGVtZW50IDBcbiAgICAgKiBAcGFyYW0gdjEgLSB2YWx1ZSBmb3IgZWxlbWVudCAxXG4gICAgICogQHBhcmFtIHYyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMlxuICAgICAqIEBwYXJhbSB2MyAtIHZhbHVlIGZvciBlbGVtZW50IDNcbiAgICAgKiBAcGFyYW0gdjQgLSB2YWx1ZSBmb3IgZWxlbWVudCA0XG4gICAgICogQHBhcmFtIHY1IC0gdmFsdWUgZm9yIGVsZW1lbnQgNVxuICAgICAqIEBwYXJhbSB2NiAtIHZhbHVlIGZvciBlbGVtZW50IDZcbiAgICAgKiBAcGFyYW0gdjcgLSB2YWx1ZSBmb3IgZWxlbWVudCA3XG4gICAgICogQHBhcmFtIHY4IC0gdmFsdWUgZm9yIGVsZW1lbnQgOFxuICAgICAqIEBwYXJhbSB2OSAtIHZhbHVlIGZvciBlbGVtZW50IDlcbiAgICAgKiBAcGFyYW0gdjEwIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTBcbiAgICAgKiBAcGFyYW0gdjExIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTFcbiAgICAgKiBAcGFyYW0gdjEyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTJcbiAgICAgKiBAcGFyYW0gdjEzIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTNcbiAgICAgKiBAcGFyYW0gdjE0IC0gdmFsdWUgZm9yIGVsZW1lbnQgMTRcbiAgICAgKiBAcGFyYW0gdjE1IC0gdmFsdWUgZm9yIGVsZW1lbnQgMTVcbiAgICAgKiBAcmV0dXJucyBjcmVhdGVkIGZyb20gdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSwgdjEwLCB2MTEsIHYxMiwgdjEzLCB2MTQsIHYxNSkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3RvcigxNik7XG4gICAgICAgIGlmICh2MCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSB2MDtcbiAgICAgICAgICAgIGlmICh2MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gdjE7XG4gICAgICAgICAgICAgICAgaWYgKHYyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gdjI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2MyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbM10gPSB2MztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzRdID0gdjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHY1ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzVdID0gdjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbNl0gPSB2NjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2NyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzddID0gdjc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHY4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzhdID0gdjg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2OSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEc3RbOV0gPSB2OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxMF0gPSB2MTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYxMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxMV0gPSB2MTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzEyXSA9IHYxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxM10gPSB2MTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYxNCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RzdFsxNF0gPSB2MTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2MTUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzE1XSA9IHYxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBNYXQ0XG4gICAgICogQWxzbyBzZWUge0BsaW5rIG1hdDQuY3JlYXRlfSBhbmQge0BsaW5rIG1hdDQuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2MCAtIHZhbHVlIGZvciBlbGVtZW50IDBcbiAgICAgKiBAcGFyYW0gdjEgLSB2YWx1ZSBmb3IgZWxlbWVudCAxXG4gICAgICogQHBhcmFtIHYyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMlxuICAgICAqIEBwYXJhbSB2MyAtIHZhbHVlIGZvciBlbGVtZW50IDNcbiAgICAgKiBAcGFyYW0gdjQgLSB2YWx1ZSBmb3IgZWxlbWVudCA0XG4gICAgICogQHBhcmFtIHY1IC0gdmFsdWUgZm9yIGVsZW1lbnQgNVxuICAgICAqIEBwYXJhbSB2NiAtIHZhbHVlIGZvciBlbGVtZW50IDZcbiAgICAgKiBAcGFyYW0gdjcgLSB2YWx1ZSBmb3IgZWxlbWVudCA3XG4gICAgICogQHBhcmFtIHY4IC0gdmFsdWUgZm9yIGVsZW1lbnQgOFxuICAgICAqIEBwYXJhbSB2OSAtIHZhbHVlIGZvciBlbGVtZW50IDlcbiAgICAgKiBAcGFyYW0gdjEwIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTBcbiAgICAgKiBAcGFyYW0gdjExIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTFcbiAgICAgKiBAcGFyYW0gdjEyIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTJcbiAgICAgKiBAcGFyYW0gdjEzIC0gdmFsdWUgZm9yIGVsZW1lbnQgMTNcbiAgICAgKiBAcGFyYW0gdjE0IC0gdmFsdWUgZm9yIGVsZW1lbnQgMTRcbiAgICAgKiBAcGFyYW0gdjE1IC0gdmFsdWUgZm9yIGVsZW1lbnQgMTVcbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIE1hdDQgY3JlYXRlZCBmcm9tIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQodjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHYwO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MTtcbiAgICAgICAgbmV3RHN0WzJdID0gdjI7XG4gICAgICAgIG5ld0RzdFszXSA9IHYzO1xuICAgICAgICBuZXdEc3RbNF0gPSB2NDtcbiAgICAgICAgbmV3RHN0WzVdID0gdjU7XG4gICAgICAgIG5ld0RzdFs2XSA9IHY2O1xuICAgICAgICBuZXdEc3RbN10gPSB2NztcbiAgICAgICAgbmV3RHN0WzhdID0gdjg7XG4gICAgICAgIG5ld0RzdFs5XSA9IHY5O1xuICAgICAgICBuZXdEc3RbMTBdID0gdjEwO1xuICAgICAgICBuZXdEc3RbMTFdID0gdjExO1xuICAgICAgICBuZXdEc3RbMTJdID0gdjEyO1xuICAgICAgICBuZXdEc3RbMTNdID0gdjEzO1xuICAgICAgICBuZXdEc3RbMTRdID0gdjE0O1xuICAgICAgICBuZXdEc3RbMTVdID0gdjE1O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWF0NCBmcm9tIGEgTWF0M1xuICAgICAqIEBwYXJhbSBtMyAtIHNvdXJjZSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIE1hdDQgbWFkZSBmcm9tIG0zXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU1hdDMobTMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IG0zWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBtM1sxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbTNbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IG0zWzRdO1xuICAgICAgICBuZXdEc3RbNV0gPSBtM1s1XTtcbiAgICAgICAgbmV3RHN0WzZdID0gbTNbNl07XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IG0zWzhdO1xuICAgICAgICBuZXdEc3RbOV0gPSBtM1s5XTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG0zWzEwXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWF0NCByb3RhdGlvbiBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBNYXQ0IG1hZGUgZnJvbSBxXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVF1YXQocSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHkgPSBxWzFdO1xuICAgICAgICBjb25zdCB6ID0gcVsyXTtcbiAgICAgICAgY29uc3QgdyA9IHFbM107XG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB5eCA9IHkgKiB4MjtcbiAgICAgICAgY29uc3QgeXkgPSB5ICogeTI7XG4gICAgICAgIGNvbnN0IHp4ID0geiAqIHgyO1xuICAgICAgICBjb25zdCB6eSA9IHogKiB5MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLSB5eSAtIHp6O1xuICAgICAgICBuZXdEc3RbMV0gPSB5eCArIHd6O1xuICAgICAgICBuZXdEc3RbMl0gPSB6eCAtIHd5O1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSB5eCAtIHd6O1xuICAgICAgICBuZXdEc3RbNV0gPSAxIC0geHggLSB6ejtcbiAgICAgICAgbmV3RHN0WzZdID0genkgKyB3eDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0genggKyB3eTtcbiAgICAgICAgbmV3RHN0WzldID0genkgLSB3eDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgYSBtYXRyaXguXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgLW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IC1tWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAtbVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gLW1bMl07XG4gICAgICAgIG5ld0RzdFszXSA9IC1tWzNdO1xuICAgICAgICBuZXdEc3RbNF0gPSAtbVs0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gLW1bNV07XG4gICAgICAgIG5ld0RzdFs2XSA9IC1tWzZdO1xuICAgICAgICBuZXdEc3RbN10gPSAtbVs3XTtcbiAgICAgICAgbmV3RHN0WzhdID0gLW1bOF07XG4gICAgICAgIG5ld0RzdFs5XSA9IC1tWzldO1xuICAgICAgICBuZXdEc3RbMTBdID0gLW1bMTBdO1xuICAgICAgICBuZXdEc3RbMTFdID0gLW1bMTFdO1xuICAgICAgICBuZXdEc3RbMTJdID0gLW1bMTJdO1xuICAgICAgICBuZXdEc3RbMTNdID0gLW1bMTNdO1xuICAgICAgICBuZXdEc3RbMTRdID0gLW1bMTRdO1xuICAgICAgICBuZXdEc3RbMTVdID0gLW1bMTVdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYSBtYXRyaXguIChzYW1lIGFzIHtAbGluayBtYXQ0LmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgbWF0NC5jcmVhdGV9IGFuZCB7QGxpbmsgbWF0NC5zZXR9XG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBUaGUgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHkobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gbVswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gbVsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbVsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gbVszXTtcbiAgICAgICAgbmV3RHN0WzRdID0gbVs0XTtcbiAgICAgICAgbmV3RHN0WzVdID0gbVs1XTtcbiAgICAgICAgbmV3RHN0WzZdID0gbVs2XTtcbiAgICAgICAgbmV3RHN0WzddID0gbVs3XTtcbiAgICAgICAgbmV3RHN0WzhdID0gbVs4XTtcbiAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IG1bMTBdO1xuICAgICAgICBuZXdEc3RbMTFdID0gbVsxMV07XG4gICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IG1bMTNdO1xuICAgICAgICBuZXdEc3RbMTRdID0gbVsxNF07XG4gICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgbWF0cml4IChzYW1lIGFzIHtAbGluayBtYXQ0LmNvcHl9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayBtYXQ0LmNyZWF0ZX0gYW5kIHtAbGluayBtYXQ0LnNldH1cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIFRoZSBtYXRyaXguIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIG0uXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgbWF0cmljZXMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgbWF0cml4LlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCBtYXRyaXguXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBtYXRyaWNlcyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsc0FwcHJveGltYXRlbHkoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYVswXSAtIGJbMF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxXSAtIGJbMV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsyXSAtIGJbMl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVszXSAtIGJbM10pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs0XSAtIGJbNF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs1XSAtIGJbNV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs2XSAtIGJbNl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs3XSAtIGJbN10pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs4XSAtIGJbOF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVs5XSAtIGJbOV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxMF0gLSBiWzEwXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzExXSAtIGJbMTFdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMTJdIC0gYlsxMl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxM10gLSBiWzEzXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzE0XSAtIGJbMTRdKSA8IEVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGFbMTVdIC0gYlsxNV0pIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiBtYXRyaWNlcyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCBtYXRyaXguXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIG1hdHJpY2VzIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiZcbiAgICAgICAgICAgIGFbMV0gPT09IGJbMV0gJiZcbiAgICAgICAgICAgIGFbMl0gPT09IGJbMl0gJiZcbiAgICAgICAgICAgIGFbM10gPT09IGJbM10gJiZcbiAgICAgICAgICAgIGFbNF0gPT09IGJbNF0gJiZcbiAgICAgICAgICAgIGFbNV0gPT09IGJbNV0gJiZcbiAgICAgICAgICAgIGFbNl0gPT09IGJbNl0gJiZcbiAgICAgICAgICAgIGFbN10gPT09IGJbN10gJiZcbiAgICAgICAgICAgIGFbOF0gPT09IGJbOF0gJiZcbiAgICAgICAgICAgIGFbOV0gPT09IGJbOV0gJiZcbiAgICAgICAgICAgIGFbMTBdID09PSBiWzEwXSAmJlxuICAgICAgICAgICAgYVsxMV0gPT09IGJbMTFdICYmXG4gICAgICAgICAgICBhWzEyXSA9PT0gYlsxMl0gJiZcbiAgICAgICAgICAgIGFbMTNdID09PSBiWzEzXSAmJlxuICAgICAgICAgICAgYVsxNF0gPT09IGJbMTRdICYmXG4gICAgICAgICAgICBhWzE1XSA9PT0gYlsxNV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgaWRlbnRpdHkgbWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIDQtYnktNCBpZGVudGl0eSBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgdGhlIHRyYW5zcG9zZSBvZiBhIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNwb3NlIG9mIG0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNwb3NlKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGlmIChuZXdEc3QgPT09IG0pIHtcbiAgICAgICAgICAgIGxldCB0O1xuICAgICAgICAgICAgdCA9IG1bMV07XG4gICAgICAgICAgICBtWzFdID0gbVs0XTtcbiAgICAgICAgICAgIG1bNF0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bMl07XG4gICAgICAgICAgICBtWzJdID0gbVs4XTtcbiAgICAgICAgICAgIG1bOF0gPSB0O1xuICAgICAgICAgICAgdCA9IG1bM107XG4gICAgICAgICAgICBtWzNdID0gbVsxMl07XG4gICAgICAgICAgICBtWzEyXSA9IHQ7XG4gICAgICAgICAgICB0ID0gbVs2XTtcbiAgICAgICAgICAgIG1bNl0gPSBtWzldO1xuICAgICAgICAgICAgbVs5XSA9IHQ7XG4gICAgICAgICAgICB0ID0gbVs3XTtcbiAgICAgICAgICAgIG1bN10gPSBtWzEzXTtcbiAgICAgICAgICAgIG1bMTNdID0gdDtcbiAgICAgICAgICAgIHQgPSBtWzExXTtcbiAgICAgICAgICAgIG1bMTFdID0gbVsxNF07XG4gICAgICAgICAgICBtWzE0XSA9IHQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTMxID0gbVszICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMzIgPSBtWzMgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMyAqIDQgKyAzXTtcbiAgICAgICAgbmV3RHN0WzBdID0gbTAwO1xuICAgICAgICBuZXdEc3RbMV0gPSBtMTA7XG4gICAgICAgIG5ld0RzdFsyXSA9IG0yMDtcbiAgICAgICAgbmV3RHN0WzNdID0gbTMwO1xuICAgICAgICBuZXdEc3RbNF0gPSBtMDE7XG4gICAgICAgIG5ld0RzdFs1XSA9IG0xMTtcbiAgICAgICAgbmV3RHN0WzZdID0gbTIxO1xuICAgICAgICBuZXdEc3RbN10gPSBtMzE7XG4gICAgICAgIG5ld0RzdFs4XSA9IG0wMjtcbiAgICAgICAgbmV3RHN0WzldID0gbTEyO1xuICAgICAgICBuZXdEc3RbMTBdID0gbTIyO1xuICAgICAgICBuZXdEc3RbMTFdID0gbTMyO1xuICAgICAgICBuZXdEc3RbMTJdID0gbTAzO1xuICAgICAgICBuZXdEc3RbMTNdID0gbTEzO1xuICAgICAgICBuZXdEc3RbMTRdID0gbTIzO1xuICAgICAgICBuZXdEc3RbMTVdID0gbTMzO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgaW52ZXJzZSBvZiBhIDQtYnktNCBtYXRyaXguXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVyc2Ugb2YgbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnNlKG0sIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMCAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTAxID0gbVswICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzAgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0wMyA9IG1bMCAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTEwID0gbVsxICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMTEgPSBtWzEgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bMSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTEzID0gbVsxICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0zMCA9IG1bMyAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTMxID0gbVszICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMzIgPSBtWzMgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0zMyA9IG1bMyAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgdG1wMCA9IG0yMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wMSA9IG0zMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wMiA9IG0xMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wMyA9IG0zMiAqIG0xMztcbiAgICAgICAgY29uc3QgdG1wNCA9IG0xMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wNSA9IG0yMiAqIG0xMztcbiAgICAgICAgY29uc3QgdG1wNiA9IG0wMiAqIG0zMztcbiAgICAgICAgY29uc3QgdG1wNyA9IG0zMiAqIG0wMztcbiAgICAgICAgY29uc3QgdG1wOCA9IG0wMiAqIG0yMztcbiAgICAgICAgY29uc3QgdG1wOSA9IG0yMiAqIG0wMztcbiAgICAgICAgY29uc3QgdG1wMTAgPSBtMDIgKiBtMTM7XG4gICAgICAgIGNvbnN0IHRtcDExID0gbTEyICogbTAzO1xuICAgICAgICBjb25zdCB0bXAxMiA9IG0yMCAqIG0zMTtcbiAgICAgICAgY29uc3QgdG1wMTMgPSBtMzAgKiBtMjE7XG4gICAgICAgIGNvbnN0IHRtcDE0ID0gbTEwICogbTMxO1xuICAgICAgICBjb25zdCB0bXAxNSA9IG0zMCAqIG0xMTtcbiAgICAgICAgY29uc3QgdG1wMTYgPSBtMTAgKiBtMjE7XG4gICAgICAgIGNvbnN0IHRtcDE3ID0gbTIwICogbTExO1xuICAgICAgICBjb25zdCB0bXAxOCA9IG0wMCAqIG0zMTtcbiAgICAgICAgY29uc3QgdG1wMTkgPSBtMzAgKiBtMDE7XG4gICAgICAgIGNvbnN0IHRtcDIwID0gbTAwICogbTIxO1xuICAgICAgICBjb25zdCB0bXAyMSA9IG0yMCAqIG0wMTtcbiAgICAgICAgY29uc3QgdG1wMjIgPSBtMDAgKiBtMTE7XG4gICAgICAgIGNvbnN0IHRtcDIzID0gbTEwICogbTAxO1xuICAgICAgICBjb25zdCB0MCA9ICh0bXAwICogbTExICsgdG1wMyAqIG0yMSArIHRtcDQgKiBtMzEpIC1cbiAgICAgICAgICAgICh0bXAxICogbTExICsgdG1wMiAqIG0yMSArIHRtcDUgKiBtMzEpO1xuICAgICAgICBjb25zdCB0MSA9ICh0bXAxICogbTAxICsgdG1wNiAqIG0yMSArIHRtcDkgKiBtMzEpIC1cbiAgICAgICAgICAgICh0bXAwICogbTAxICsgdG1wNyAqIG0yMSArIHRtcDggKiBtMzEpO1xuICAgICAgICBjb25zdCB0MiA9ICh0bXAyICogbTAxICsgdG1wNyAqIG0xMSArIHRtcDEwICogbTMxKSAtXG4gICAgICAgICAgICAodG1wMyAqIG0wMSArIHRtcDYgKiBtMTEgKyB0bXAxMSAqIG0zMSk7XG4gICAgICAgIGNvbnN0IHQzID0gKHRtcDUgKiBtMDEgKyB0bXA4ICogbTExICsgdG1wMTEgKiBtMjEpIC1cbiAgICAgICAgICAgICh0bXA0ICogbTAxICsgdG1wOSAqIG0xMSArIHRtcDEwICogbTIxKTtcbiAgICAgICAgY29uc3QgZCA9IDEgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBkICogdDA7XG4gICAgICAgIG5ld0RzdFsxXSA9IGQgKiB0MTtcbiAgICAgICAgbmV3RHN0WzJdID0gZCAqIHQyO1xuICAgICAgICBuZXdEc3RbM10gPSBkICogdDM7XG4gICAgICAgIG5ld0RzdFs0XSA9IGQgKiAoKHRtcDEgKiBtMTAgKyB0bXAyICogbTIwICsgdG1wNSAqIG0zMCkgLVxuICAgICAgICAgICAgKHRtcDAgKiBtMTAgKyB0bXAzICogbTIwICsgdG1wNCAqIG0zMCkpO1xuICAgICAgICBuZXdEc3RbNV0gPSBkICogKCh0bXAwICogbTAwICsgdG1wNyAqIG0yMCArIHRtcDggKiBtMzApIC1cbiAgICAgICAgICAgICh0bXAxICogbTAwICsgdG1wNiAqIG0yMCArIHRtcDkgKiBtMzApKTtcbiAgICAgICAgbmV3RHN0WzZdID0gZCAqICgodG1wMyAqIG0wMCArIHRtcDYgKiBtMTAgKyB0bXAxMSAqIG0zMCkgLVxuICAgICAgICAgICAgKHRtcDIgKiBtMDAgKyB0bXA3ICogbTEwICsgdG1wMTAgKiBtMzApKTtcbiAgICAgICAgbmV3RHN0WzddID0gZCAqICgodG1wNCAqIG0wMCArIHRtcDkgKiBtMTAgKyB0bXAxMCAqIG0yMCkgLVxuICAgICAgICAgICAgKHRtcDUgKiBtMDAgKyB0bXA4ICogbTEwICsgdG1wMTEgKiBtMjApKTtcbiAgICAgICAgbmV3RHN0WzhdID0gZCAqICgodG1wMTIgKiBtMTMgKyB0bXAxNSAqIG0yMyArIHRtcDE2ICogbTMzKSAtXG4gICAgICAgICAgICAodG1wMTMgKiBtMTMgKyB0bXAxNCAqIG0yMyArIHRtcDE3ICogbTMzKSk7XG4gICAgICAgIG5ld0RzdFs5XSA9IGQgKiAoKHRtcDEzICogbTAzICsgdG1wMTggKiBtMjMgKyB0bXAyMSAqIG0zMykgLVxuICAgICAgICAgICAgKHRtcDEyICogbTAzICsgdG1wMTkgKiBtMjMgKyB0bXAyMCAqIG0zMykpO1xuICAgICAgICBuZXdEc3RbMTBdID0gZCAqICgodG1wMTQgKiBtMDMgKyB0bXAxOSAqIG0xMyArIHRtcDIyICogbTMzKSAtXG4gICAgICAgICAgICAodG1wMTUgKiBtMDMgKyB0bXAxOCAqIG0xMyArIHRtcDIzICogbTMzKSk7XG4gICAgICAgIG5ld0RzdFsxMV0gPSBkICogKCh0bXAxNyAqIG0wMyArIHRtcDIwICogbTEzICsgdG1wMjMgKiBtMjMpIC1cbiAgICAgICAgICAgICh0bXAxNiAqIG0wMyArIHRtcDIxICogbTEzICsgdG1wMjIgKiBtMjMpKTtcbiAgICAgICAgbmV3RHN0WzEyXSA9IGQgKiAoKHRtcDE0ICogbTIyICsgdG1wMTcgKiBtMzIgKyB0bXAxMyAqIG0xMikgLVxuICAgICAgICAgICAgKHRtcDE2ICogbTMyICsgdG1wMTIgKiBtMTIgKyB0bXAxNSAqIG0yMikpO1xuICAgICAgICBuZXdEc3RbMTNdID0gZCAqICgodG1wMjAgKiBtMzIgKyB0bXAxMiAqIG0wMiArIHRtcDE5ICogbTIyKSAtXG4gICAgICAgICAgICAodG1wMTggKiBtMjIgKyB0bXAyMSAqIG0zMiArIHRtcDEzICogbTAyKSk7XG4gICAgICAgIG5ld0RzdFsxNF0gPSBkICogKCh0bXAxOCAqIG0xMiArIHRtcDIzICogbTMyICsgdG1wMTUgKiBtMDIpIC1cbiAgICAgICAgICAgICh0bXAyMiAqIG0zMiArIHRtcDE0ICogbTAyICsgdG1wMTkgKiBtMTIpKTtcbiAgICAgICAgbmV3RHN0WzE1XSA9IGQgKiAoKHRtcDIyICogbTIyICsgdG1wMTYgKiBtMDIgKyB0bXAyMSAqIG0xMikgLVxuICAgICAgICAgICAgKHRtcDIwICogbTEyICsgdG1wMjMgKiBtMjIgKyB0bXAxNyAqIG0wMikpO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxuICAgICAqIEBwYXJhbSBtIC0gdGhlIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHRoZSBkZXRlcm1pbmFudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVybWluYW50KG0pIHtcbiAgICAgICAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTAzID0gbVswICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTMwID0gbVszICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMzEgPSBtWzMgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0zMiA9IG1bMyAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTMzID0gbVszICogNCArIDNdO1xuICAgICAgICBjb25zdCB0bXAwID0gbTIyICogbTMzO1xuICAgICAgICBjb25zdCB0bXAxID0gbTMyICogbTIzO1xuICAgICAgICBjb25zdCB0bXAyID0gbTEyICogbTMzO1xuICAgICAgICBjb25zdCB0bXAzID0gbTMyICogbTEzO1xuICAgICAgICBjb25zdCB0bXA0ID0gbTEyICogbTIzO1xuICAgICAgICBjb25zdCB0bXA1ID0gbTIyICogbTEzO1xuICAgICAgICBjb25zdCB0bXA2ID0gbTAyICogbTMzO1xuICAgICAgICBjb25zdCB0bXA3ID0gbTMyICogbTAzO1xuICAgICAgICBjb25zdCB0bXA4ID0gbTAyICogbTIzO1xuICAgICAgICBjb25zdCB0bXA5ID0gbTIyICogbTAzO1xuICAgICAgICBjb25zdCB0bXAxMCA9IG0wMiAqIG0xMztcbiAgICAgICAgY29uc3QgdG1wMTEgPSBtMTIgKiBtMDM7XG4gICAgICAgIGNvbnN0IHQwID0gKHRtcDAgKiBtMTEgKyB0bXAzICogbTIxICsgdG1wNCAqIG0zMSkgLVxuICAgICAgICAgICAgKHRtcDEgKiBtMTEgKyB0bXAyICogbTIxICsgdG1wNSAqIG0zMSk7XG4gICAgICAgIGNvbnN0IHQxID0gKHRtcDEgKiBtMDEgKyB0bXA2ICogbTIxICsgdG1wOSAqIG0zMSkgLVxuICAgICAgICAgICAgKHRtcDAgKiBtMDEgKyB0bXA3ICogbTIxICsgdG1wOCAqIG0zMSk7XG4gICAgICAgIGNvbnN0IHQyID0gKHRtcDIgKiBtMDEgKyB0bXA3ICogbTExICsgdG1wMTAgKiBtMzEpIC1cbiAgICAgICAgICAgICh0bXAzICogbTAxICsgdG1wNiAqIG0xMSArIHRtcDExICogbTMxKTtcbiAgICAgICAgY29uc3QgdDMgPSAodG1wNSAqIG0wMSArIHRtcDggKiBtMTEgKyB0bXAxMSAqIG0yMSkgLVxuICAgICAgICAgICAgKHRtcDQgKiBtMDEgKyB0bXA5ICogbTExICsgdG1wMTAgKiBtMjEpO1xuICAgICAgICByZXR1cm4gbTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBpbnZlcnNlIG9mIGEgNC1ieS00IG1hdHJpeC4gKHNhbWUgYXMgaW52ZXJzZSlcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW52ZXJzZSBvZiBtLlxuICAgICAqL1xuICAgIGNvbnN0IGludmVydCA9IGludmVyc2U7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gNC1ieS00IG1hdHJpY2VzIHdpdGggYSBvbiB0aGUgbGVmdCBhbmQgYiBvbiB0aGUgcmlnaHRcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgbWF0cml4IG9uIHRoZSByaWdodC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IGEwMCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGEwMSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGEwMiA9IGFbMl07XG4gICAgICAgIGNvbnN0IGEwMyA9IGFbM107XG4gICAgICAgIGNvbnN0IGExMCA9IGFbNCArIDBdO1xuICAgICAgICBjb25zdCBhMTEgPSBhWzQgKyAxXTtcbiAgICAgICAgY29uc3QgYTEyID0gYVs0ICsgMl07XG4gICAgICAgIGNvbnN0IGExMyA9IGFbNCArIDNdO1xuICAgICAgICBjb25zdCBhMjAgPSBhWzggKyAwXTtcbiAgICAgICAgY29uc3QgYTIxID0gYVs4ICsgMV07XG4gICAgICAgIGNvbnN0IGEyMiA9IGFbOCArIDJdO1xuICAgICAgICBjb25zdCBhMjMgPSBhWzggKyAzXTtcbiAgICAgICAgY29uc3QgYTMwID0gYVsxMiArIDBdO1xuICAgICAgICBjb25zdCBhMzEgPSBhWzEyICsgMV07XG4gICAgICAgIGNvbnN0IGEzMiA9IGFbMTIgKyAyXTtcbiAgICAgICAgY29uc3QgYTMzID0gYVsxMiArIDNdO1xuICAgICAgICBjb25zdCBiMDAgPSBiWzBdO1xuICAgICAgICBjb25zdCBiMDEgPSBiWzFdO1xuICAgICAgICBjb25zdCBiMDIgPSBiWzJdO1xuICAgICAgICBjb25zdCBiMDMgPSBiWzNdO1xuICAgICAgICBjb25zdCBiMTAgPSBiWzQgKyAwXTtcbiAgICAgICAgY29uc3QgYjExID0gYls0ICsgMV07XG4gICAgICAgIGNvbnN0IGIxMiA9IGJbNCArIDJdO1xuICAgICAgICBjb25zdCBiMTMgPSBiWzQgKyAzXTtcbiAgICAgICAgY29uc3QgYjIwID0gYls4ICsgMF07XG4gICAgICAgIGNvbnN0IGIyMSA9IGJbOCArIDFdO1xuICAgICAgICBjb25zdCBiMjIgPSBiWzggKyAyXTtcbiAgICAgICAgY29uc3QgYjIzID0gYls4ICsgM107XG4gICAgICAgIGNvbnN0IGIzMCA9IGJbMTIgKyAwXTtcbiAgICAgICAgY29uc3QgYjMxID0gYlsxMiArIDFdO1xuICAgICAgICBjb25zdCBiMzIgPSBiWzEyICsgMl07XG4gICAgICAgIGNvbnN0IGIzMyA9IGJbMTIgKyAzXTtcbiAgICAgICAgbmV3RHN0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyICsgYTMwICogYjAzO1xuICAgICAgICBuZXdEc3RbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDIgKyBhMzEgKiBiMDM7XG4gICAgICAgIG5ld0RzdFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMiArIGEzMiAqIGIwMztcbiAgICAgICAgbmV3RHN0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyICsgYTMzICogYjAzO1xuICAgICAgICBuZXdEc3RbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTIgKyBhMzAgKiBiMTM7XG4gICAgICAgIG5ld0RzdFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMiArIGEzMSAqIGIxMztcbiAgICAgICAgbmV3RHN0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyICsgYTMyICogYjEzO1xuICAgICAgICBuZXdEc3RbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTIgKyBhMzMgKiBiMTM7XG4gICAgICAgIG5ld0RzdFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMiArIGEzMCAqIGIyMztcbiAgICAgICAgbmV3RHN0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyICsgYTMxICogYjIzO1xuICAgICAgICBuZXdEc3RbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyICsgYTMyICogYjIzO1xuICAgICAgICBuZXdEc3RbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyICsgYTMzICogYjIzO1xuICAgICAgICBuZXdEc3RbMTJdID0gYTAwICogYjMwICsgYTEwICogYjMxICsgYTIwICogYjMyICsgYTMwICogYjMzO1xuICAgICAgICBuZXdEc3RbMTNdID0gYTAxICogYjMwICsgYTExICogYjMxICsgYTIxICogYjMyICsgYTMxICogYjMzO1xuICAgICAgICBuZXdEc3RbMTRdID0gYTAyICogYjMwICsgYTEyICogYjMxICsgYTIyICogYjMyICsgYTMyICogYjMzO1xuICAgICAgICBuZXdEc3RbMTVdID0gYTAzICogYjMwICsgYTEzICogYjMxICsgYTIzICogYjMyICsgYTMzICogYjMzO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byA0LWJ5LTQgbWF0cmljZXMgd2l0aCBhIG9uIHRoZSBsZWZ0IGFuZCBiIG9uIHRoZSByaWdodCAoc2FtZSBhcyBtdWx0aXBseSlcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBtYXRyaXggb24gdGhlIGxlZnQuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgbWF0cml4IG9uIHRoZSByaWdodC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRyaXggcHJvZHVjdCBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IG11bCA9IG11bHRpcGx5O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBhIDQtYnktNCBtYXRyaXggdG8gdGhlIGdpdmVuXG4gICAgICogdmVjdG9yLlxuICAgICAqIEBwYXJhbSBhIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWF0cml4IHdpdGggdHJhbnNsYXRpb24gc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0aW9uKGEsIHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IGlkZW50aXR5KCkpO1xuICAgICAgICBpZiAoYSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSBhWzBdO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gYVsxXTtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IGFbMl07XG4gICAgICAgICAgICBuZXdEc3RbM10gPSBhWzNdO1xuICAgICAgICAgICAgbmV3RHN0WzRdID0gYVs0XTtcbiAgICAgICAgICAgIG5ld0RzdFs1XSA9IGFbNV07XG4gICAgICAgICAgICBuZXdEc3RbNl0gPSBhWzZdO1xuICAgICAgICAgICAgbmV3RHN0WzddID0gYVs3XTtcbiAgICAgICAgICAgIG5ld0RzdFs4XSA9IGFbOF07XG4gICAgICAgICAgICBuZXdEc3RbOV0gPSBhWzldO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IGFbMTBdO1xuICAgICAgICAgICAgbmV3RHN0WzExXSA9IGFbMTFdO1xuICAgICAgICB9XG4gICAgICAgIG5ld0RzdFsxMl0gPSB2WzBdO1xuICAgICAgICBuZXdEc3RbMTNdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IHZbMl07XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvLy8qKlxuICAgIC8vICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gY29tcG9uZW50IG9mIGEgNC1ieS00IG1hdHJpeCBhcyBhIHZlY3RvciB3aXRoIDNcbiAgICAvLyAqIGVudHJpZXMuXG4gICAgLy8gKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgLy8gKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgIC8vICogQHJldHVybnMgVGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiBtLlxuICAgIC8vICovXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24obSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gdmVjMy5jcmVhdGUoKSk7XG4gICAgICAgIG5ld0RzdFswXSA9IG1bMTJdO1xuICAgICAgICBuZXdEc3RbMV0gPSBtWzEzXTtcbiAgICAgICAgbmV3RHN0WzJdID0gbVsxNF07XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXhpcyBvZiBhIDR4NCBtYXRyaXggYXMgYSB2ZWN0b3Igd2l0aCAzIGVudHJpZXNcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpcyAwID0geCwgMSA9IHksIDIgPSB6O1xuICAgICAqIEByZXR1cm5zIFRoZSBheGlzIGNvbXBvbmVudCBvZiBtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF4aXMobSwgYXhpcywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gdmVjMy5jcmVhdGUoKSk7XG4gICAgICAgIGNvbnN0IG9mZiA9IGF4aXMgKiA0O1xuICAgICAgICBuZXdEc3RbMF0gPSBtW29mZiArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBtW29mZiArIDFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBtW29mZiArIDJdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIGF4aXMgb2YgYSA0eDQgbWF0cml4IGFzIGEgdmVjdG9yIHdpdGggMyBlbnRyaWVzXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSB2IC0gdGhlIGF4aXMgdmVjdG9yXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpcyAgMCA9IHgsIDEgPSB5LCAyID0gejtcbiAgICAgKiBAcGFyYW0gZHN0IC0gVGhlIG1hdHJpeCB0byBzZXQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG1hdHJpeCB3aXRoIGF4aXMgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEF4aXMobSwgdiwgYXhpcywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPT09IG0pID8gZHN0IDogY29weShtLCBkc3QpO1xuICAgICAgICBjb25zdCBvZmYgPSBheGlzICogNDtcbiAgICAgICAgbmV3RHN0W29mZiArIDBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0W29mZiArIDFdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0W29mZiArIDJdID0gdlsyXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLy8vKipcbiAgICAvLyAqIFJldHVybnMgdGhlIHNjYWxpbmcgY29tcG9uZW50IG9mIHRoZSBtYXRyaXhcbiAgICAvLyAqIEBwYXJhbSBtIC0gVGhlIE1hdHJpeFxuICAgIC8vICogQHBhcmFtIGRzdCAtIFRoZSB2ZWN0b3IgdG8gc2V0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgIC8vICovXG4gICAgZnVuY3Rpb24gZ2V0U2NhbGluZyhtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyB2ZWMzLmNyZWF0ZSgpKTtcbiAgICAgICAgY29uc3QgeHggPSBtWzBdO1xuICAgICAgICBjb25zdCB4eSA9IG1bMV07XG4gICAgICAgIGNvbnN0IHh6ID0gbVsyXTtcbiAgICAgICAgY29uc3QgeXggPSBtWzRdO1xuICAgICAgICBjb25zdCB5eSA9IG1bNV07XG4gICAgICAgIGNvbnN0IHl6ID0gbVs2XTtcbiAgICAgICAgY29uc3QgenggPSBtWzhdO1xuICAgICAgICBjb25zdCB6eSA9IG1bOV07XG4gICAgICAgIGNvbnN0IHp6ID0gbVsxMF07XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguc3FydCh4eCAqIHh4ICsgeHkgKiB4eSArIHh6ICogeHopO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLnNxcnQoeXggKiB5eCArIHl5ICogeXkgKyB5eiAqIHl6KTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5zcXJ0KHp4ICogenggKyB6eSAqIHp5ICsgenogKiB6eik7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IHBlcnNwZWN0aXZlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBnaXZlbiB0aGUgYW5ndWxhciBoZWlnaHRcbiAgICAgKiBvZiB0aGUgZnJ1c3R1bSwgdGhlIGFzcGVjdCByYXRpbywgYW5kIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgVGhlXG4gICAgICogYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW0gZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gIFRoZSBnaXZlblxuICAgICAqIGFuZ2xlIGlzIHRoZSB2ZXJ0aWNhbCBhbmdsZSBvZiB0aGUgZnJ1c3R1bSwgYW5kIHRoZSBob3Jpem9udGFsIGFuZ2xlIGlzXG4gICAgICogZGV0ZXJtaW5lZCB0byBwcm9kdWNlIHRoZSBnaXZlbiBhc3BlY3QgcmF0aW8uICBUaGUgYXJndW1lbnRzIG5lYXIgYW5kIGZhciBhcmVcbiAgICAgKiB0aGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgTm90ZSB0aGF0IG5lYXIgYW5kIGZhclxuICAgICAqIGFyZSBub3QgeiBjb29yZGluYXRlcywgYnV0IHJhdGhlciB0aGV5IGFyZSBkaXN0YW5jZXMgYWxvbmcgdGhlIG5lZ2F0aXZlXG4gICAgICogei1heGlzLiAgVGhlIG1hdHJpeCBnZW5lcmF0ZWQgc2VuZHMgdGhlIHZpZXdpbmcgZnJ1c3R1bSB0byB0aGUgdW5pdCBib3guXG4gICAgICogV2UgYXNzdW1lIGEgdW5pdCBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZFxuICAgICAqIGZyb20gMCB0byAxIGluIHRoZSB6IGRpbWVuc2lvbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIHlvdSBwYXNzIGBJbmZpbml0eWAgZm9yIHpGYXIgdGhlbiBpdCB3aWxsIHByb2R1Y2UgYSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqIHJldHVybnMgLUluZmluaXR5IGZvciBaIHdoZW4gdHJhbnNmb3JtaW5nIGNvb3JkaW5hdGVzIHdpdGggWiA8PSAwIGFuZCArSW5maW5pdHkgZm9yIFpcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGRPZlZpZXdZSW5SYWRpYW5zIC0gVGhlIGNhbWVyYSBhbmdsZSBmcm9tIHRvcCB0byBib3R0b20gKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBhc3BlY3QgLSBUaGUgYXNwZWN0IHJhdGlvIHdpZHRoIC8gaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB6TmVhciAtIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICAgICAqICAgICBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZS5cbiAgICAgKiBAcGFyYW0gekZhciAtIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICAgICAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHBlcnNwZWN0aXZlIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwZXJzcGVjdGl2ZShmaWVsZE9mVmlld1lJblJhZGlhbnMsIGFzcGVjdCwgek5lYXIsIHpGYXIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IGYgPSBNYXRoLnRhbihNYXRoLlBJICogMC41IC0gMC41ICogZmllbGRPZlZpZXdZSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzBdID0gZiAvIGFzcGVjdDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gZjtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gMDtcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzExXSA9IC0xO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAwO1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHpGYXIpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZUludiA9IDEgLyAoek5lYXIgLSB6RmFyKTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSB6RmFyICogcmFuZ2VJbnY7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gekZhciAqIHpOZWFyICogcmFuZ2VJbnY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gLTE7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gLXpOZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IHJldmVyc2UteiBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGFuZ3VsYXIgaGVpZ2h0XG4gICAgICogb2YgdGhlIGZydXN0dW0sIHRoZSBhc3BlY3QgcmF0aW8sIGFuZCB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIFRoZVxuICAgICAqIGFyZ3VtZW50cyBkZWZpbmUgYSBmcnVzdHVtIGV4dGVuZGluZyBpbiB0aGUgbmVnYXRpdmUgeiBkaXJlY3Rpb24uICBUaGUgZ2l2ZW5cbiAgICAgKiBhbmdsZSBpcyB0aGUgdmVydGljYWwgYW5nbGUgb2YgdGhlIGZydXN0dW0sIGFuZCB0aGUgaG9yaXpvbnRhbCBhbmdsZSBpc1xuICAgICAqIGRldGVybWluZWQgdG8gcHJvZHVjZSB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLiAgVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlXG4gICAgICogdGhlIGRpc3RhbmNlcyB0byB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIE5vdGUgdGhhdCBuZWFyIGFuZCBmYXJcbiAgICAgKiBhcmUgbm90IHogY29vcmRpbmF0ZXMsIGJ1dCByYXRoZXIgdGhleSBhcmUgZGlzdGFuY2VzIGFsb25nIHRoZSBuZWdhdGl2ZVxuICAgICAqIHotYXhpcy4gIFRoZSBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LlxuICAgICAqIFdlIGFzc3VtZSBhIHVuaXQgYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmRcbiAgICAgKiBmcm9tIDEgKGF0IC16TmVhcikgdG8gMCAoYXQgLXpGYXIpIGluIHRoZSB6IGRpbWVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZE9mVmlld1lJblJhZGlhbnMgLSBUaGUgY2FtZXJhIGFuZ2xlIGZyb20gdG9wIHRvIGJvdHRvbSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGFzcGVjdCAtIFRoZSBhc3BlY3QgcmF0aW8gd2lkdGggLyBoZWlnaHQuXG4gICAgICogQHBhcmFtIHpOZWFyIC0gVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gICAgICogICAgIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSB6RmFyIC0gVGhlIGRlcHRoIChuZWdhdGl2ZSB6IGNvb3JkaW5hdGUpXG4gICAgICogICAgIG9mIHRoZSBmYXIgY2xpcHBpbmcgcGxhbmUuIChkZWZhdWx0ID0gSW5maW5pdHkpXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVyc3BlY3RpdmUgbWF0cml4LlxuICAgICAqLyBmdW5jdGlvbiBwZXJzcGVjdGl2ZVJldmVyc2VaKGZpZWxkT2ZWaWV3WUluUmFkaWFucywgYXNwZWN0LCB6TmVhciwgekZhciA9IEluZmluaXR5LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBmID0gMSAvIE1hdGgudGFuKGZpZWxkT2ZWaWV3WUluUmFkaWFucyAqIDAuNSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IGY7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAtMTtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMDtcbiAgICAgICAgaWYgKHpGYXIgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSB6TmVhcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlSW52ID0gMSAvICh6RmFyIC0gek5lYXIpO1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IHpOZWFyICogcmFuZ2VJbnY7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gekZhciAqIHpOZWFyICogcmFuZ2VJbnY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSA0LWJ5LTQgb3J0aG9nb25hbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdGhhdCB0cmFuc2Zvcm1zIGZyb21cbiAgICAgKiB0aGUgZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LCBib3R0b20sIGFuZCB0b3AgZGltZW5zaW9ucyB0byAtMSArMSBpbiB4LCBhbmQgeVxuICAgICAqIGFuZCAwIHRvICsxIGluIHouXG4gICAgICogQHBhcmFtIGxlZnQgLSBMZWZ0IHNpZGUgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gUmlnaHQgc2lkZSBvZiB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gYm90dG9tIC0gQm90dG9tIG9mIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB0b3AgLSBUb3Agb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIG5lYXIgLSBUaGUgZGVwdGggKG5lZ2F0aXZlIHogY29vcmRpbmF0ZSlcbiAgICAgKiAgICAgb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUuXG4gICAgICogQHBhcmFtIGZhciAtIFRoZSBkZXB0aCAobmVnYXRpdmUgeiBjb29yZGluYXRlKVxuICAgICAqICAgICBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lLlxuICAgICAqIEBwYXJhbSBkc3QgLSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3J0aG8obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDIgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMiAvICh0b3AgLSBib3R0b20pO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAocmlnaHQgKyBsZWZ0KSAvIChsZWZ0IC0gcmlnaHQpO1xuICAgICAgICBuZXdEc3RbMTNdID0gKHRvcCArIGJvdHRvbSkgLyAoYm90dG9tIC0gdG9wKTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IG5lYXIgLyAobmVhciAtIGZhcik7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LFxuICAgICAqIHRvcCwgYm90dG9tLCBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBUaGUgYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW1cbiAgICAgKiBleHRlbmRpbmcgaW4gdGhlIG5lZ2F0aXZlIHogZGlyZWN0aW9uLiBUaGUgYXJndW1lbnRzIG5lYXIgYW5kIGZhciBhcmUgdGhlXG4gICAgICogZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBOb3RlIHRoYXQgbmVhciBhbmQgZmFyIGFyZSBub3RcbiAgICAgKiB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmUgei1heGlzLiBUaGVcbiAgICAgKiBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LiBXZSBhc3N1bWUgYSB1bml0XG4gICAgICogYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmQgZnJvbSAwIHRvIDEgaW4gdGhlIHpcbiAgICAgKiBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGxlZnQgLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcGxhbmUgb2YgdGhlIGJveC5cbiAgICAgKiBAcGFyYW0gYm90dG9tIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHRvcCAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIG5lYXIgLSBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBuZWFyIHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIGZhciAtIFRoZSBuZWdhdGl2ZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGZhciBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSBkc3QgLSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcnVzdHVtKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBkeCA9IChyaWdodCAtIGxlZnQpO1xuICAgICAgICBjb25zdCBkeSA9ICh0b3AgLSBib3R0b20pO1xuICAgICAgICBjb25zdCBkeiA9IChuZWFyIC0gZmFyKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMiAqIG5lYXIgLyBkeDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMiAqIG5lYXIgLyBkeTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gKGxlZnQgKyByaWdodCkgLyBkeDtcbiAgICAgICAgbmV3RHN0WzldID0gKHRvcCArIGJvdHRvbSkgLyBkeTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IGZhciAvIGR6O1xuICAgICAgICBuZXdEc3RbMTFdID0gLTE7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IG5lYXIgKiBmYXIgLyBkejtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDA7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IHJldmVyc2UteiBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LFxuICAgICAqIHRvcCwgYm90dG9tLCBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBUaGUgYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW1cbiAgICAgKiBleHRlbmRpbmcgaW4gdGhlIG5lZ2F0aXZlIHogZGlyZWN0aW9uLiBUaGUgYXJndW1lbnRzIG5lYXIgYW5kIGZhciBhcmUgdGhlXG4gICAgICogZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBOb3RlIHRoYXQgbmVhciBhbmQgZmFyIGFyZSBub3RcbiAgICAgKiB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmUgei1heGlzLiBUaGVcbiAgICAgKiBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LiBXZSBhc3N1bWUgYSB1bml0XG4gICAgICogYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmQgZnJvbSAxICgtbmVhcikgdG8gMCAoLWZhcikgaW4gdGhlIHpcbiAgICAgKiBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIGxlZnQgLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcGxhbmUgb2YgdGhlIGJveC5cbiAgICAgKiBAcGFyYW0gYm90dG9tIC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHRvcCAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIG5lYXIgLSBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBuZWFyIHBsYW5lIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIGZhciAtIFRoZSBuZWdhdGl2ZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGZhciBwbGFuZSBvZiB0aGUgYm94LlxuICAgICAqIEBwYXJhbSBkc3QgLSBPdXRwdXQgbWF0cml4LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcnVzdHVtUmV2ZXJzZVoobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgPSBJbmZpbml0eSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgZHggPSAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgZHkgPSAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgbmV3RHN0WzBdID0gMiAqIG5lYXIgLyBkeDtcbiAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMiAqIG5lYXIgLyBkeTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gKGxlZnQgKyByaWdodCkgLyBkeDtcbiAgICAgICAgbmV3RHN0WzldID0gKHRvcCArIGJvdHRvbSkgLyBkeTtcbiAgICAgICAgbmV3RHN0WzExXSA9IC0xO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAwO1xuICAgICAgICBpZiAoZmFyID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgbmV3RHN0WzEwXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gbmVhcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlSW52ID0gMSAvIChmYXIgLSBuZWFyKTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBuZWFyICogcmFuZ2VJbnY7XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gZmFyICogbmVhciAqIHJhbmdlSW52O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIGNvbnN0IHhBeGlzID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB5QXhpcyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgekF4aXMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgNC1ieS00IGFpbSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBtYXRyaXggd2hpY2ggcG9zaXRpb25zIGFuIG9iamVjdCBhaW1pbmcgZG93biBwb3NpdGl2ZSBaLlxuICAgICAqIHRvd2FyZCB0aGUgdGFyZ2V0LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBpcyAqKk5PVCoqIHRoZSBpbnZlcnNlIG9mIGxvb2tBdCBhcyBsb29rQXQgbG9va3MgYXQgbmVnYXRpdmUgWi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgcG9zaXRpb24gbWVhbnQgdG8gYmUgYWltZWQgYXQuXG4gICAgICogQHBhcmFtIHVwIC0gQSB2ZWN0b3IgcG9pbnRpbmcgdXAuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYWltIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhaW0ocG9zaXRpb24sIHRhcmdldCwgdXAsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuc3VidHJhY3QodGFyZ2V0LCBwb3NpdGlvbiwgekF4aXMpLCB6QXhpcyk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3ModXAsIHpBeGlzLCB4QXhpcyksIHhBeGlzKTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodmVjMy5jcm9zcyh6QXhpcywgeEF4aXMsIHlBeGlzKSwgeUF4aXMpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzFdID0geEF4aXNbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IHhBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSB5QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzVdID0geUF4aXNbMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IHlBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSB6QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzldID0gekF4aXNbMV07XG4gICAgICAgIG5ld0RzdFsxMF0gPSB6QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSBwb3NpdGlvblswXTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IHBvc2l0aW9uWzFdO1xuICAgICAgICBuZXdEc3RbMTRdID0gcG9zaXRpb25bMl07XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCBjYW1lcmEgYWltIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIG1hdHJpeCB3aGljaCBwb3NpdGlvbnMgYW4gb2JqZWN0IGFpbWluZyBkb3duIG5lZ2F0aXZlIFouXG4gICAgICogdG93YXJkIHRoZSB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIGlzIHRoZSBpbnZlcnNlIG9mIGBsb29rQXRgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXllIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBwb3NpdGlvbiBtZWFudCB0byBiZSBhaW1lZCBhdC5cbiAgICAgKiBAcGFyYW0gdXAgLSBBIHZlY3RvciBwb2ludGluZyB1cC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBhaW0gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbWVyYUFpbShleWUsIHRhcmdldCwgdXAsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuc3VidHJhY3QoZXllLCB0YXJnZXQsIHpBeGlzKSwgekF4aXMpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHVwLCB6QXhpcywgeEF4aXMpLCB4QXhpcyk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYzMuY3Jvc3MoekF4aXMsIHhBeGlzLCB5QXhpcyksIHlBeGlzKTtcbiAgICAgICAgbmV3RHN0WzBdID0geEF4aXNbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHhBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSB4QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0geUF4aXNbMF07XG4gICAgICAgIG5ld0RzdFs1XSA9IHlBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbNl0gPSB5QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gekF4aXNbMF07XG4gICAgICAgIG5ld0RzdFs5XSA9IHpBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gekF4aXNbMl07XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gZXllWzBdO1xuICAgICAgICBuZXdEc3RbMTNdID0gZXllWzFdO1xuICAgICAgICBuZXdEc3RbMTRdID0gZXllWzJdO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSA0LWJ5LTQgdmlldyB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSB2aWV3IG1hdHJpeCB3aGljaCB0cmFuc2Zvcm1zIGFsbCBvdGhlciBvYmplY3RzXG4gICAgICogdG8gYmUgaW4gdGhlIHNwYWNlIG9mIHRoZSB2aWV3IGRlZmluZWQgYnkgdGhlIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXllIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBwb3NpdGlvbiBtZWFudCB0byBiZSBhaW1lZCBhdC5cbiAgICAgKiBAcGFyYW0gdXAgLSBBIHZlY3RvciBwb2ludGluZyB1cC5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBsb29rLWF0IG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb29rQXQoZXllLCB0YXJnZXQsIHVwLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLnN1YnRyYWN0KGV5ZSwgdGFyZ2V0LCB6QXhpcyksIHpBeGlzKTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodmVjMy5jcm9zcyh1cCwgekF4aXMsIHhBeGlzKSwgeEF4aXMpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2ZWMzLmNyb3NzKHpBeGlzLCB4QXhpcywgeUF4aXMpLCB5QXhpcyk7XG4gICAgICAgIG5ld0RzdFswXSA9IHhBeGlzWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB5QXhpc1swXTtcbiAgICAgICAgbmV3RHN0WzJdID0gekF4aXNbMF07XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IHhBeGlzWzFdO1xuICAgICAgICBuZXdEc3RbNV0gPSB5QXhpc1sxXTtcbiAgICAgICAgbmV3RHN0WzZdID0gekF4aXNbMV07XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IHhBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbOV0gPSB5QXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzEwXSA9IHpBeGlzWzJdO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IC0oeEF4aXNbMF0gKiBleWVbMF0gKyB4QXhpc1sxXSAqIGV5ZVsxXSArIHhBeGlzWzJdICogZXllWzJdKTtcbiAgICAgICAgbmV3RHN0WzEzXSA9IC0oeUF4aXNbMF0gKiBleWVbMF0gKyB5QXhpc1sxXSAqIGV5ZVsxXSArIHlBeGlzWzJdICogZXllWzJdKTtcbiAgICAgICAgbmV3RHN0WzE0XSA9IC0oekF4aXNbMF0gKiBleWVbMF0gKyB6QXhpc1sxXSAqIGV5ZVsxXSArIHpBeGlzWzJdICogZXllWzJdKTtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHRyYW5zbGF0ZXMgYnkgdGhlIGdpdmVuIHZlY3RvciB2LlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3RvciBieVxuICAgICAqICAgICB3aGljaCB0byB0cmFuc2xhdGUuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNsYXRpb24gbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0aW9uKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDE7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IDE7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSAxO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFsxM10gPSB2WzFdO1xuICAgICAgICBuZXdEc3RbMTRdID0gdlsyXTtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYnkgdGhlIGdpdmVuIHZlY3RvciB2LlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IgYnlcbiAgICAgKiAgICAgd2hpY2ggdG8gdHJhbnNsYXRlLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zbGF0ZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShtLCB2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzFdO1xuICAgICAgICBjb25zdCBtMDIgPSBtWzJdO1xuICAgICAgICBjb25zdCBtMDMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzEgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bMSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTEyID0gbVsxICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMTMgPSBtWzEgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bMiAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTIxID0gbVsyICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMjIgPSBtWzIgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bMiAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgbTMwID0gbVszICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMzEgPSBtWzMgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0zMiA9IG1bMyAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTMzID0gbVszICogNCArIDNdO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSBtMDA7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSBtMDE7XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSBtMDI7XG4gICAgICAgICAgICBuZXdEc3RbM10gPSBtMDM7XG4gICAgICAgICAgICBuZXdEc3RbNF0gPSBtMTA7XG4gICAgICAgICAgICBuZXdEc3RbNV0gPSBtMTE7XG4gICAgICAgICAgICBuZXdEc3RbNl0gPSBtMTI7XG4gICAgICAgICAgICBuZXdEc3RbN10gPSBtMTM7XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBtMjA7XG4gICAgICAgICAgICBuZXdEc3RbOV0gPSBtMjE7XG4gICAgICAgICAgICBuZXdEc3RbMTBdID0gbTIyO1xuICAgICAgICAgICAgbmV3RHN0WzExXSA9IG0yMztcbiAgICAgICAgfVxuICAgICAgICBuZXdEc3RbMTJdID0gbTAwICogdjAgKyBtMTAgKiB2MSArIG0yMCAqIHYyICsgbTMwO1xuICAgICAgICBuZXdEc3RbMTNdID0gbTAxICogdjAgKyBtMTEgKiB2MSArIG0yMSAqIHYyICsgbTMxO1xuICAgICAgICBuZXdEc3RbMTRdID0gbTAyICogdjAgKyBtMTIgKiB2MSArIG0yMiAqIHYyICsgbTMyO1xuICAgICAgICBuZXdEc3RbMTVdID0gbTAzICogdjAgKyBtMTMgKiB2MSArIG0yMyAqIHYyICsgbTMzO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgeC1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRpb25YKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSAxO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICBuZXdEc3RbNF0gPSAwO1xuICAgICAgICBuZXdEc3RbNV0gPSBjO1xuICAgICAgICBuZXdEc3RbNl0gPSBzO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAtcztcbiAgICAgICAgbmV3RHN0WzEwXSA9IGM7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHgtYXhpcyBieSB0aGUgZ2l2ZW5cbiAgICAgKiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWChtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgbTEwID0gbVs0XTtcbiAgICAgICAgY29uc3QgbTExID0gbVs1XTtcbiAgICAgICAgY29uc3QgbTEyID0gbVs2XTtcbiAgICAgICAgY29uc3QgbTEzID0gbVs3XTtcbiAgICAgICAgY29uc3QgbTIwID0gbVs4XTtcbiAgICAgICAgY29uc3QgbTIxID0gbVs5XTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsxMF07XG4gICAgICAgIGNvbnN0IG0yMyA9IG1bMTFdO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbNF0gPSBjICogbTEwICsgcyAqIG0yMDtcbiAgICAgICAgbmV3RHN0WzVdID0gYyAqIG0xMSArIHMgKiBtMjE7XG4gICAgICAgIG5ld0RzdFs2XSA9IGMgKiBtMTIgKyBzICogbTIyO1xuICAgICAgICBuZXdEc3RbN10gPSBjICogbTEzICsgcyAqIG0yMztcbiAgICAgICAgbmV3RHN0WzhdID0gYyAqIG0yMCAtIHMgKiBtMTA7XG4gICAgICAgIG5ld0RzdFs5XSA9IGMgKiBtMjEgLSBzICogbTExO1xuICAgICAgICBuZXdEc3RbMTBdID0gYyAqIG0yMiAtIHMgKiBtMTI7XG4gICAgICAgIG5ld0RzdFsxMV0gPSBjICogbTIzIC0gcyAqIG0xMztcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gbVswXTtcbiAgICAgICAgICAgIG5ld0RzdFsxXSA9IG1bMV07XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSBtWzJdO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gbVszXTtcbiAgICAgICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSBtWzE0XTtcbiAgICAgICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgeS1heGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRpb25ZKGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgICAgICBuZXdEc3RbMF0gPSBjO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAtcztcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0gMDtcbiAgICAgICAgbmV3RHN0WzVdID0gMTtcbiAgICAgICAgbmV3RHN0WzZdID0gMDtcbiAgICAgICAgbmV3RHN0WzddID0gMDtcbiAgICAgICAgbmV3RHN0WzhdID0gcztcbiAgICAgICAgbmV3RHN0WzldID0gMDtcbiAgICAgICAgbmV3RHN0WzEwXSA9IGM7XG4gICAgICAgIG5ld0RzdFsxMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTJdID0gMDtcbiAgICAgICAgbmV3RHN0WzEzXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNF0gPSAwO1xuICAgICAgICBuZXdEc3RbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIHktYXhpcyBieSB0aGUgZ2l2ZW5cbiAgICAgKiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWShtLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoMTYpKTtcbiAgICAgICAgY29uc3QgbTAwID0gbVswICogNCArIDBdO1xuICAgICAgICBjb25zdCBtMDEgPSBtWzAgKiA0ICsgMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMCAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgbTAzID0gbVswICogNCArIDNdO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzIgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bMiAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTIyID0gbVsyICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzIgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIG5ld0RzdFswXSA9IGMgKiBtMDAgLSBzICogbTIwO1xuICAgICAgICBuZXdEc3RbMV0gPSBjICogbTAxIC0gcyAqIG0yMTtcbiAgICAgICAgbmV3RHN0WzJdID0gYyAqIG0wMiAtIHMgKiBtMjI7XG4gICAgICAgIG5ld0RzdFszXSA9IGMgKiBtMDMgLSBzICogbTIzO1xuICAgICAgICBuZXdEc3RbOF0gPSBjICogbTIwICsgcyAqIG0wMDtcbiAgICAgICAgbmV3RHN0WzldID0gYyAqIG0yMSArIHMgKiBtMDE7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBjICogbTIyICsgcyAqIG0wMjtcbiAgICAgICAgbmV3RHN0WzExXSA9IGMgKiBtMjMgKyBzICogbTAzO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbNF0gPSBtWzRdO1xuICAgICAgICAgICAgbmV3RHN0WzVdID0gbVs1XTtcbiAgICAgICAgICAgIG5ld0RzdFs2XSA9IG1bNl07XG4gICAgICAgICAgICBuZXdEc3RbN10gPSBtWzddO1xuICAgICAgICAgICAgbmV3RHN0WzEyXSA9IG1bMTJdO1xuICAgICAgICAgICAgbmV3RHN0WzEzXSA9IG1bMTNdO1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IG1bMTRdO1xuICAgICAgICAgICAgbmV3RHN0WzE1XSA9IG1bMTVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSB6LWF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgKGluIHJhZGlhbnMpLlxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGlvblooYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIG5ld0RzdFswXSA9IGM7XG4gICAgICAgIG5ld0RzdFsxXSA9IHM7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IC1zO1xuICAgICAgICBuZXdEc3RbNV0gPSBjO1xuICAgICAgICBuZXdEc3RbNl0gPSAwO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSAwO1xuICAgICAgICBuZXdEc3RbOV0gPSAwO1xuICAgICAgICBuZXdEc3RbMTBdID0gMTtcbiAgICAgICAgbmV3RHN0WzExXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMl0gPSAwO1xuICAgICAgICBuZXdEc3RbMTNdID0gMDtcbiAgICAgICAgbmV3RHN0WzE0XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBnaXZlbiA0LWJ5LTQgbWF0cml4IGFyb3VuZCB0aGUgei1heGlzIGJ5IHRoZSBnaXZlblxuICAgICAqIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVaKG0sIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBjb25zdCBtMDAgPSBtWzAgKiA0ICsgMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMCAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbTAyID0gbVswICogNCArIDJdO1xuICAgICAgICBjb25zdCBtMDMgPSBtWzAgKiA0ICsgM107XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bMSAqIDQgKyAwXTtcbiAgICAgICAgY29uc3QgbTExID0gbVsxICogNCArIDFdO1xuICAgICAgICBjb25zdCBtMTIgPSBtWzEgKiA0ICsgMl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bMSAqIDQgKyAzXTtcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYyAqIG0wMCArIHMgKiBtMTA7XG4gICAgICAgIG5ld0RzdFsxXSA9IGMgKiBtMDEgKyBzICogbTExO1xuICAgICAgICBuZXdEc3RbMl0gPSBjICogbTAyICsgcyAqIG0xMjtcbiAgICAgICAgbmV3RHN0WzNdID0gYyAqIG0wMyArIHMgKiBtMTM7XG4gICAgICAgIG5ld0RzdFs0XSA9IGMgKiBtMTAgLSBzICogbTAwO1xuICAgICAgICBuZXdEc3RbNV0gPSBjICogbTExIC0gcyAqIG0wMTtcbiAgICAgICAgbmV3RHN0WzZdID0gYyAqIG0xMiAtIHMgKiBtMDI7XG4gICAgICAgIG5ld0RzdFs3XSA9IGMgKiBtMTMgLSBzICogbTAzO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbOF0gPSBtWzhdO1xuICAgICAgICAgICAgbmV3RHN0WzldID0gbVs5XTtcbiAgICAgICAgICAgIG5ld0RzdFsxMF0gPSBtWzEwXTtcbiAgICAgICAgICAgIG5ld0RzdFsxMV0gPSBtWzExXTtcbiAgICAgICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSBtWzE0XTtcbiAgICAgICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCByb3RhdGVzIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBieSB0aGUgZ2l2ZW5cbiAgICAgKiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzXG4gICAgICogICAgIGFib3V0IHdoaWNoIHRvIHJvdGF0ZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYW5nbGUgcmFkaWFuc1xuICAgICAqICAgICBhcm91bmQgdGhlIGF4aXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXhpc1JvdGF0aW9uKGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBsZXQgeCA9IGF4aXNbMF07XG4gICAgICAgIGxldCB5ID0gYXhpc1sxXTtcbiAgICAgICAgbGV0IHogPSBheGlzWzJdO1xuICAgICAgICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgICAgIHggLz0gbjtcbiAgICAgICAgeSAvPSBuO1xuICAgICAgICB6IC89IG47XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHg7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHk7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHo7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG4gICAgICAgIG5ld0RzdFswXSA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICAgICAgICBuZXdEc3RbMV0gPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lICsgeiAqIHM7XG4gICAgICAgIG5ld0RzdFsyXSA9IHggKiB6ICogb25lTWludXNDb3NpbmUgLSB5ICogcztcbiAgICAgICAgbmV3RHN0WzNdID0gMDtcbiAgICAgICAgbmV3RHN0WzRdID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICAgICAgICBuZXdEc3RbNV0gPSB5eSArICgxIC0geXkpICogYztcbiAgICAgICAgbmV3RHN0WzZdID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xuICAgICAgICBuZXdEc3RbN10gPSAwO1xuICAgICAgICBuZXdEc3RbOF0gPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeSAqIHM7XG4gICAgICAgIG5ld0RzdFs5XSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgLSB4ICogcztcbiAgICAgICAgbmV3RHN0WzEwXSA9IHp6ICsgKDEgLSB6eikgKiBjO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHJvdGF0ZXMgYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZSBnaXZlblxuICAgICAqIGFuZ2xlLiAoc2FtZSBhcyBheGlzUm90YXRpb24pXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpc1xuICAgICAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIG1hdHJpeCB3aGljaCByb3RhdGVzIGFuZ2xlIHJhZGlhbnNcbiAgICAgKiAgICAgYXJvdW5kIHRoZSBheGlzLlxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0aW9uID0gYXhpc1JvdGF0aW9uO1xuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIDQtYnktNCBtYXRyaXggYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZVxuICAgICAqIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBtIC0gVGhlIG1hdHJpeC5cbiAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzXG4gICAgICogICAgIGFib3V0IHdoaWNoIHRvIHJvdGF0ZS5cbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIChpbiByYWRpYW5zKS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByb3RhdGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBheGlzUm90YXRlKG0sIGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBsZXQgeCA9IGF4aXNbMF07XG4gICAgICAgIGxldCB5ID0gYXhpc1sxXTtcbiAgICAgICAgbGV0IHogPSBheGlzWzJdO1xuICAgICAgICBjb25zdCBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgICAgIHggLz0gbjtcbiAgICAgICAgeSAvPSBuO1xuICAgICAgICB6IC89IG47XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHg7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHk7XG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHo7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IG9uZU1pbnVzQ29zaW5lID0gMSAtIGM7XG4gICAgICAgIGNvbnN0IHIwMCA9IHh4ICsgKDEgLSB4eCkgKiBjO1xuICAgICAgICBjb25zdCByMDEgPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lICsgeiAqIHM7XG4gICAgICAgIGNvbnN0IHIwMiA9IHggKiB6ICogb25lTWludXNDb3NpbmUgLSB5ICogcztcbiAgICAgICAgY29uc3QgcjEwID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSAtIHogKiBzO1xuICAgICAgICBjb25zdCByMTEgPSB5eSArICgxIC0geXkpICogYztcbiAgICAgICAgY29uc3QgcjEyID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xuICAgICAgICBjb25zdCByMjAgPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lICsgeSAqIHM7XG4gICAgICAgIGNvbnN0IHIyMSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgLSB4ICogcztcbiAgICAgICAgY29uc3QgcjIyID0genogKyAoMSAtIHp6KSAqIGM7XG4gICAgICAgIGNvbnN0IG0wMCA9IG1bMF07XG4gICAgICAgIGNvbnN0IG0wMSA9IG1bMV07XG4gICAgICAgIGNvbnN0IG0wMiA9IG1bMl07XG4gICAgICAgIGNvbnN0IG0wMyA9IG1bM107XG4gICAgICAgIGNvbnN0IG0xMCA9IG1bNF07XG4gICAgICAgIGNvbnN0IG0xMSA9IG1bNV07XG4gICAgICAgIGNvbnN0IG0xMiA9IG1bNl07XG4gICAgICAgIGNvbnN0IG0xMyA9IG1bN107XG4gICAgICAgIGNvbnN0IG0yMCA9IG1bOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IG1bOV07XG4gICAgICAgIGNvbnN0IG0yMiA9IG1bMTBdO1xuICAgICAgICBjb25zdCBtMjMgPSBtWzExXTtcbiAgICAgICAgbmV3RHN0WzBdID0gcjAwICogbTAwICsgcjAxICogbTEwICsgcjAyICogbTIwO1xuICAgICAgICBuZXdEc3RbMV0gPSByMDAgKiBtMDEgKyByMDEgKiBtMTEgKyByMDIgKiBtMjE7XG4gICAgICAgIG5ld0RzdFsyXSA9IHIwMCAqIG0wMiArIHIwMSAqIG0xMiArIHIwMiAqIG0yMjtcbiAgICAgICAgbmV3RHN0WzNdID0gcjAwICogbTAzICsgcjAxICogbTEzICsgcjAyICogbTIzO1xuICAgICAgICBuZXdEc3RbNF0gPSByMTAgKiBtMDAgKyByMTEgKiBtMTAgKyByMTIgKiBtMjA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHIxMCAqIG0wMSArIHIxMSAqIG0xMSArIHIxMiAqIG0yMTtcbiAgICAgICAgbmV3RHN0WzZdID0gcjEwICogbTAyICsgcjExICogbTEyICsgcjEyICogbTIyO1xuICAgICAgICBuZXdEc3RbN10gPSByMTAgKiBtMDMgKyByMTEgKiBtMTMgKyByMTIgKiBtMjM7XG4gICAgICAgIG5ld0RzdFs4XSA9IHIyMCAqIG0wMCArIHIyMSAqIG0xMCArIHIyMiAqIG0yMDtcbiAgICAgICAgbmV3RHN0WzldID0gcjIwICogbTAxICsgcjIxICogbTExICsgcjIyICogbTIxO1xuICAgICAgICBuZXdEc3RbMTBdID0gcjIwICogbTAyICsgcjIxICogbTEyICsgcjIyICogbTIyO1xuICAgICAgICBuZXdEc3RbMTFdID0gcjIwICogbTAzICsgcjIxICogbTEzICsgcjIyICogbTIzO1xuICAgICAgICBpZiAobSAhPT0gbmV3RHN0KSB7XG4gICAgICAgICAgICBuZXdEc3RbMTJdID0gbVsxMl07XG4gICAgICAgICAgICBuZXdEc3RbMTNdID0gbVsxM107XG4gICAgICAgICAgICBuZXdEc3RbMTRdID0gbVsxNF07XG4gICAgICAgICAgICBuZXdEc3RbMTVdID0gbVsxNV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBhcm91bmQgdGhlIGdpdmVuIGF4aXMgYnkgdGhlXG4gICAgICogZ2l2ZW4gYW5nbGUuIChzYW1lIGFzIHJvdGF0ZSlcbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXguXG4gICAgICogQHBhcmFtIGF4aXMgLSBUaGUgYXhpc1xuICAgICAqICAgICBhYm91dCB3aGljaCB0byByb3RhdGUuXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSAoaW4gcmFkaWFucykuXG4gICAgICogQHBhcmFtIGRzdCAtIG1hdHJpeCB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm90YXRlZCBtYXRyaXguXG4gICAgICovXG4gICAgY29uc3Qgcm90YXRlID0gYXhpc1JvdGF0ZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgNC1ieS00IG1hdHJpeCB3aGljaCBzY2FsZXMgaW4gZWFjaCBkaW1lbnNpb24gYnkgYW4gYW1vdW50IGdpdmVuIGJ5XG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdGhlIGdpdmVuIHZlY3RvcjsgYXNzdW1lcyB0aGUgdmVjdG9yIGhhcyB0aHJlZVxuICAgICAqIGVudHJpZXMuXG4gICAgICogQHBhcmFtIHYgLSBBIHZlY3RvciBvZlxuICAgICAqICAgICB0aHJlZSBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsaW5nIG1hdHJpeC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY2FsaW5nKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHZbMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSB2WzJdO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBpbiBlYWNoIGRpbWVuc2lvbiBieSBhbiBhbW91bnRcbiAgICAgKiBnaXZlbiBieSB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBpbiB0aGUgZ2l2ZW4gdmVjdG9yOyBhc3N1bWVzIHRoZSB2ZWN0b3IgaGFzXG4gICAgICogdGhyZWUgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gbSAtIFRoZSBtYXRyaXggdG8gYmUgbW9kaWZpZWQuXG4gICAgICogQHBhcmFtIHYgLSBBIHZlY3RvciBvZiB0aHJlZSBlbnRyaWVzIHNwZWNpZnlpbmcgdGhlXG4gICAgICogICAgIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNjYWxlKG0sIHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIG5ld0RzdFswXSA9IHYwICogbVswICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSB2MCAqIG1bMCAqIDQgKyAxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gdjAgKiBtWzAgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFszXSA9IHYwICogbVswICogNCArIDNdO1xuICAgICAgICBuZXdEc3RbNF0gPSB2MSAqIG1bMSAqIDQgKyAwXTtcbiAgICAgICAgbmV3RHN0WzVdID0gdjEgKiBtWzEgKiA0ICsgMV07XG4gICAgICAgIG5ld0RzdFs2XSA9IHYxICogbVsxICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbN10gPSB2MSAqIG1bMSAqIDQgKyAzXTtcbiAgICAgICAgbmV3RHN0WzhdID0gdjIgKiBtWzIgKiA0ICsgMF07XG4gICAgICAgIG5ld0RzdFs5XSA9IHYyICogbVsyICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gdjIgKiBtWzIgKiA0ICsgMl07XG4gICAgICAgIG5ld0RzdFsxMV0gPSB2MiAqIG1bMiAqIDQgKyAzXTtcbiAgICAgICAgaWYgKG0gIT09IG5ld0RzdCkge1xuICAgICAgICAgICAgbmV3RHN0WzEyXSA9IG1bMTJdO1xuICAgICAgICAgICAgbmV3RHN0WzEzXSA9IG1bMTNdO1xuICAgICAgICAgICAgbmV3RHN0WzE0XSA9IG1bMTRdO1xuICAgICAgICAgICAgbmV3RHN0WzE1XSA9IG1bMTVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSA0LWJ5LTQgbWF0cml4IHdoaWNoIHNjYWxlcyBhIHVuaWZvcm0gYW1vdW50IGluIGVhY2ggZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBzIC0gdGhlIGFtb3VudCB0byBzY2FsZVxuICAgICAqIEBwYXJhbSBkc3QgLSBtYXRyaXggdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxpbmcgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaWZvcm1TY2FsaW5nKHMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDE2KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHM7XG4gICAgICAgIG5ld0RzdFsxXSA9IDA7XG4gICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgIG5ld0RzdFszXSA9IDA7XG4gICAgICAgIG5ld0RzdFs0XSA9IDA7XG4gICAgICAgIG5ld0RzdFs1XSA9IHM7XG4gICAgICAgIG5ld0RzdFs2XSA9IDA7XG4gICAgICAgIG5ld0RzdFs3XSA9IDA7XG4gICAgICAgIG5ld0RzdFs4XSA9IDA7XG4gICAgICAgIG5ld0RzdFs5XSA9IDA7XG4gICAgICAgIG5ld0RzdFsxMF0gPSBzO1xuICAgICAgICBuZXdEc3RbMTFdID0gMDtcbiAgICAgICAgbmV3RHN0WzEyXSA9IDA7XG4gICAgICAgIG5ld0RzdFsxM10gPSAwO1xuICAgICAgICBuZXdEc3RbMTRdID0gMDtcbiAgICAgICAgbmV3RHN0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgZ2l2ZW4gNC1ieS00IG1hdHJpeCBpbiBlYWNoIGRpbWVuc2lvbiBieSBhIHVuaWZvcm0gc2NhbGUuXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIEBwYXJhbSBzIC0gVGhlIGFtb3VudCB0byBzY2FsZS5cbiAgICAgKiBAcGFyYW0gZHN0IC0gbWF0cml4IHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaWZvcm1TY2FsZShtLCBzLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3RvcigxNikpO1xuICAgICAgICBuZXdEc3RbMF0gPSBzICogbVswICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBzICogbVswICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBzICogbVswICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbM10gPSBzICogbVswICogNCArIDNdO1xuICAgICAgICBuZXdEc3RbNF0gPSBzICogbVsxICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbNV0gPSBzICogbVsxICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbNl0gPSBzICogbVsxICogNCArIDJdO1xuICAgICAgICBuZXdEc3RbN10gPSBzICogbVsxICogNCArIDNdO1xuICAgICAgICBuZXdEc3RbOF0gPSBzICogbVsyICogNCArIDBdO1xuICAgICAgICBuZXdEc3RbOV0gPSBzICogbVsyICogNCArIDFdO1xuICAgICAgICBuZXdEc3RbMTBdID0gcyAqIG1bMiAqIDQgKyAyXTtcbiAgICAgICAgbmV3RHN0WzExXSA9IHMgKiBtWzIgKiA0ICsgM107XG4gICAgICAgIGlmIChtICE9PSBuZXdEc3QpIHtcbiAgICAgICAgICAgIG5ld0RzdFsxMl0gPSBtWzEyXTtcbiAgICAgICAgICAgIG5ld0RzdFsxM10gPSBtWzEzXTtcbiAgICAgICAgICAgIG5ld0RzdFsxNF0gPSBtWzE0XTtcbiAgICAgICAgICAgIG5ld0RzdFsxNV0gPSBtWzE1XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUsXG4gICAgICAgIHNldCxcbiAgICAgICAgZnJvbU1hdDMsXG4gICAgICAgIGZyb21RdWF0LFxuICAgICAgICBuZWdhdGUsXG4gICAgICAgIGNvcHksXG4gICAgICAgIGNsb25lLFxuICAgICAgICBlcXVhbHNBcHByb3hpbWF0ZWx5LFxuICAgICAgICBlcXVhbHMsXG4gICAgICAgIGlkZW50aXR5LFxuICAgICAgICB0cmFuc3Bvc2UsXG4gICAgICAgIGludmVyc2UsXG4gICAgICAgIGRldGVybWluYW50LFxuICAgICAgICBpbnZlcnQsXG4gICAgICAgIG11bHRpcGx5LFxuICAgICAgICBtdWwsXG4gICAgICAgIHNldFRyYW5zbGF0aW9uLFxuICAgICAgICBnZXRUcmFuc2xhdGlvbixcbiAgICAgICAgZ2V0QXhpcyxcbiAgICAgICAgc2V0QXhpcyxcbiAgICAgICAgZ2V0U2NhbGluZyxcbiAgICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICAgIHBlcnNwZWN0aXZlUmV2ZXJzZVosXG4gICAgICAgIG9ydGhvLFxuICAgICAgICBmcnVzdHVtLFxuICAgICAgICBmcnVzdHVtUmV2ZXJzZVosXG4gICAgICAgIGFpbSxcbiAgICAgICAgY2FtZXJhQWltLFxuICAgICAgICBsb29rQXQsXG4gICAgICAgIHRyYW5zbGF0aW9uLFxuICAgICAgICB0cmFuc2xhdGUsXG4gICAgICAgIHJvdGF0aW9uWCxcbiAgICAgICAgcm90YXRlWCxcbiAgICAgICAgcm90YXRpb25ZLFxuICAgICAgICByb3RhdGVZLFxuICAgICAgICByb3RhdGlvblosXG4gICAgICAgIHJvdGF0ZVosXG4gICAgICAgIGF4aXNSb3RhdGlvbixcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGF4aXNSb3RhdGUsXG4gICAgICAgIHJvdGF0ZSxcbiAgICAgICAgc2NhbGluZyxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIHVuaWZvcm1TY2FsaW5nLFxuICAgICAgICB1bmlmb3JtU2NhbGUsXG4gICAgfTtcbn1cbmNvbnN0IGNhY2hlJDIgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRBUEkkMihDdG9yKSB7XG4gICAgbGV0IGFwaSA9IGNhY2hlJDIuZ2V0KEN0b3IpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICAgIGFwaSA9IGdldEFQSUltcGwkMihDdG9yKTtcbiAgICAgICAgY2FjaGUkMi5zZXQoQ3RvciwgYXBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaTtcbn1cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW0gdHlwZWQgQVBJIGZvciBRdWRcbiAqICovXG5mdW5jdGlvbiBnZXRBUElJbXBsJDEoQ3Rvcikge1xuICAgIGNvbnN0IHZlYzMgPSBnZXRBUEkkMyhDdG9yKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcXVhdDQ7IG1heSBiZSBjYWxsZWQgd2l0aCB4LCB5LCB6IHRvIHNldCBpbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geCAtIEluaXRpYWwgeCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geSAtIEluaXRpYWwgeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geiAtIEluaXRpYWwgeiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gdyAtIEluaXRpYWwgdyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoeCwgeSwgeiwgdykge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3Rvcig0KTtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgICAgIGlmICh5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICAgICAgICAgIGlmICh6ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gejtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUXVhdDsgbWF5IGJlIGNhbGxlZCB3aXRoIHgsIHksIHogdG8gc2V0IGluaXRpYWwgdmFsdWVzLiAoc2FtZSBhcyBjcmVhdGUpXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHcgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBRdWF0XG4gICAgICogQWxzbyBzZWUge0BsaW5rIHF1YXQuY3JlYXRlfSBhbmQge0BsaW5rIHF1YXQuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IGZpcnN0IHZhbHVlXG4gICAgICogQHBhcmFtIHkgc2Vjb25kIHZhbHVlXG4gICAgICogQHBhcmFtIHogdGhpcmQgdmFsdWVcbiAgICAgKiBAcGFyYW0gdyBmb3VydGggdmFsdWVcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHdpdGggaXRzIGVsZW1lbnRzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgdywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4O1xuICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICBuZXdEc3RbMl0gPSB6O1xuICAgICAgICBuZXdEc3RbM10gPSB3O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgIGF4aXMsXG4gICAgICogdGhlbiByZXR1cm5zIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGF4aXMgLSB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gdGhlIGFuZ2xlXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHF1YXRlcm5pb24gdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiBheGlzIGFuZCBhbmdsZVxuICAgICAqKi9cbiAgICBmdW5jdGlvbiBmcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlSW5SYWRpYW5zICogMC41O1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcbiAgICAgICAgbmV3RHN0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IHMgKiBheGlzWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBzICogYXhpc1syXTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGVcbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gY29tcHV0ZSBmcm9tXG4gICAgICogQHBhcmFtIGRzdCAtIFZlYzMgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiBhbmdsZSBhbmQgYXhpc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXhpc0FuZ2xlKHEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IHZlYzMuY3JlYXRlKDMpKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmFjb3MocVszXSkgKiAyO1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUgKiAwLjUpO1xuICAgICAgICBpZiAocyA+IEVQU0lMT04pIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHFbMF0gLyBzO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gcVsxXSAvIHM7XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSBxWzJdIC8gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IDE7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBhbmdsZSwgYXhpczogbmV3RHN0IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIGluIGRlZ3JlZXMgYmV0d2VlbiB0d28gcm90YXRpb25zIGEgYW5kIGIuXG4gICAgICogQHBhcmFtIGEgLSBxdWF0ZXJuaW9uIGFcbiAgICAgKiBAcGFyYW0gYiAtIHF1YXRlcm5pb24gYlxuICAgICAqIEByZXR1cm4gYW5nbGUgaW4gcmFkaWFucyBiZXR3ZWVuIHRoZSB0d28gcXVhdGVybmlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkb3QoYSwgYik7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoMiAqIGQgKiBkIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIHF1YXRlcm5pb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIHRoZSBmaXJzdCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIGIgLSB0aGUgc2Vjb25kIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGEgKiBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBheCA9IGFbMF07XG4gICAgICAgIGNvbnN0IGF5ID0gYVsxXTtcbiAgICAgICAgY29uc3QgYXogPSBhWzJdO1xuICAgICAgICBjb25zdCBhdyA9IGFbM107XG4gICAgICAgIGNvbnN0IGJ4ID0gYlswXTtcbiAgICAgICAgY29uc3QgYnkgPSBiWzFdO1xuICAgICAgICBjb25zdCBieiA9IGJbMl07XG4gICAgICAgIGNvbnN0IGJ3ID0gYlszXTtcbiAgICAgICAgbmV3RHN0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICAgICAgbmV3RHN0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICAgICAgbmV3RHN0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICAgICAgbmV3RHN0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gcXVhdGVybmlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIC0gdGhlIGZpcnN0IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gYiAtIHRoZSBzZWNvbmQgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYSAqIGJcbiAgICAgKi9cbiAgICBjb25zdCBtdWwgPSBtdWx0aXBseTtcbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSBnaXZlbiBxdWF0ZXJuaW9uIGFyb3VuZCB0aGUgWCBheGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBAcGFyYW0gcSAtIHF1YXRlcm5pb24gdG8gcm90YXRlXG4gICAgICogQHBhcmFtIGFuZ2xlSW5SYWRpYW5zIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSByZXN1bHQgb2YgYSAqIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3RhdGVYKHEsIGFuZ2xlSW5SYWRpYW5zLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlSW5SYWRpYW5zICogMC41O1xuICAgICAgICBjb25zdCBxeCA9IHFbMF07XG4gICAgICAgIGNvbnN0IHF5ID0gcVsxXTtcbiAgICAgICAgY29uc3QgcXogPSBxWzJdO1xuICAgICAgICBjb25zdCBxdyA9IHFbM107XG4gICAgICAgIGNvbnN0IGJ4ID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcbiAgICAgICAgY29uc3QgYncgPSBNYXRoLmNvcyhoYWxmQW5nbGUpO1xuICAgICAgICBuZXdEc3RbMF0gPSBxeCAqIGJ3ICsgcXcgKiBieDtcbiAgICAgICAgbmV3RHN0WzFdID0gcXkgKiBidyArIHF6ICogYng7XG4gICAgICAgIG5ld0RzdFsyXSA9IHF6ICogYncgLSBxeSAqIGJ4O1xuICAgICAgICBuZXdEc3RbM10gPSBxdyAqIGJ3IC0gcXggKiBieDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgZ2l2ZW4gcXVhdGVybmlvbiBhcm91bmQgdGhlIFkgYXhpcyBieSB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogQHBhcmFtIHEgLSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSBhbmdsZUluUmFkaWFucyAtIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGEgKiBiXG4gICAgICovXG4gICAgZnVuY3Rpb24gcm90YXRlWShxLCBhbmdsZUluUmFkaWFucywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZUluUmFkaWFucyAqIDAuNTtcbiAgICAgICAgY29uc3QgcXggPSBxWzBdO1xuICAgICAgICBjb25zdCBxeSA9IHFbMV07XG4gICAgICAgIGNvbnN0IHF6ID0gcVsyXTtcbiAgICAgICAgY29uc3QgcXcgPSBxWzNdO1xuICAgICAgICBjb25zdCBieSA9IE1hdGguc2luKGhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGJ3ID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICAgICAgbmV3RHN0WzBdID0gcXggKiBidyAtIHF6ICogYnk7XG4gICAgICAgIG5ld0RzdFsxXSA9IHF5ICogYncgKyBxdyAqIGJ5O1xuICAgICAgICBuZXdEc3RbMl0gPSBxeiAqIGJ3ICsgcXggKiBieTtcbiAgICAgICAgbmV3RHN0WzNdID0gcXcgKiBidyAtIHF5ICogYnk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGdpdmVuIHF1YXRlcm5pb24gYXJvdW5kIHRoZSBaIGF4aXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBwYXJhbSBxIC0gcXVhdGVybmlvbiB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0gYW5nbGVJblJhZGlhbnMgLSBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhICogYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0ZVoocSwgYW5nbGVJblJhZGlhbnMsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgY29uc3QgaGFsZkFuZ2xlID0gYW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHF4ID0gcVswXTtcbiAgICAgICAgY29uc3QgcXkgPSBxWzFdO1xuICAgICAgICBjb25zdCBxeiA9IHFbMl07XG4gICAgICAgIGNvbnN0IHF3ID0gcVszXTtcbiAgICAgICAgY29uc3QgYnogPSBNYXRoLnNpbihoYWxmQW5nbGUpO1xuICAgICAgICBjb25zdCBidyA9IE1hdGguY29zKGhhbGZBbmdsZSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHF4ICogYncgKyBxeSAqIGJ6O1xuICAgICAgICBuZXdEc3RbMV0gPSBxeSAqIGJ3IC0gcXggKiBiejtcbiAgICAgICAgbmV3RHN0WzJdID0gcXogKiBidyArIHF3ICogYno7XG4gICAgICAgIG5ld0RzdFszXSA9IHF3ICogYncgLSBxeiAqIGJ6O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGhlcmljYWxseSBsaW5lYXIgaW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gcXVhdGVybmlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhIC0gc3RhcnRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0gYiAtIGVuZGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSB0IC0gdmFsdWUgd2hlcmUgMCA9IGEgYW5kIDEgPSBiXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhICogYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsZXJwKGEsIGIsIHQsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgY29uc3QgYXggPSBhWzBdO1xuICAgICAgICBjb25zdCBheSA9IGFbMV07XG4gICAgICAgIGNvbnN0IGF6ID0gYVsyXTtcbiAgICAgICAgY29uc3QgYXcgPSBhWzNdO1xuICAgICAgICBsZXQgYnggPSBiWzBdO1xuICAgICAgICBsZXQgYnkgPSBiWzFdO1xuICAgICAgICBsZXQgYnogPSBiWzJdO1xuICAgICAgICBsZXQgYncgPSBiWzNdO1xuICAgICAgICBsZXQgY29zT21lZ2EgPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAgICAgICBpZiAoY29zT21lZ2EgPCAwKSB7XG4gICAgICAgICAgICBjb3NPbWVnYSA9IC1jb3NPbWVnYTtcbiAgICAgICAgICAgIGJ4ID0gLWJ4O1xuICAgICAgICAgICAgYnkgPSAtYnk7XG4gICAgICAgICAgICBieiA9IC1iejtcbiAgICAgICAgICAgIGJ3ID0gLWJ3O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2FsZTA7XG4gICAgICAgIGxldCBzY2FsZTE7XG4gICAgICAgIGlmICgxLjAgLSBjb3NPbWVnYSA+IEVQU0lMT04pIHtcbiAgICAgICAgICAgIGNvbnN0IG9tZWdhID0gTWF0aC5hY29zKGNvc09tZWdhKTtcbiAgICAgICAgICAgIGNvbnN0IHNpbk9tZWdhID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEgLSB0KSAqIG9tZWdhKSAvIHNpbk9tZWdhO1xuICAgICAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbk9tZWdhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICAgICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RHN0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICAgICAgbmV3RHN0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICAgICAgbmV3RHN0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICAgICAgbmV3RHN0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHF1YXRlcm5pb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxIC0gcXVhdGVybmlvbiB0byBjb21wdXRlIHRoZSBpbnZlcnNlIG9mXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhICogYlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVyc2UocSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBjb25zdCBhMCA9IHFbMF07XG4gICAgICAgIGNvbnN0IGExID0gcVsxXTtcbiAgICAgICAgY29uc3QgYTIgPSBxWzJdO1xuICAgICAgICBjb25zdCBhMyA9IHFbM107XG4gICAgICAgIGNvbnN0IGRvdCA9IGEwICogYTAgKyBhMSAqIGExICsgYTIgKiBhMiArIGEzICogYTM7XG4gICAgICAgIGNvbnN0IGludkRvdCA9IGRvdCA/IDEgLyBkb3QgOiAwO1xuICAgICAgICBuZXdEc3RbMF0gPSAtYTAgKiBpbnZEb3Q7XG4gICAgICAgIG5ld0RzdFsxXSA9IC1hMSAqIGludkRvdDtcbiAgICAgICAgbmV3RHN0WzJdID0gLWEyICogaW52RG90O1xuICAgICAgICBuZXdEc3RbM10gPSBhMyAqIGludkRvdDtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgY29uanVnYXRlIG9mIGEgcXVhdGVybmlvblxuICAgICAqIEZvciBxdWF0ZXJuaW9ucyB3aXRoIGEgbWFnbml0dWRlIG9mIDEgKGEgdW5pdCBxdWF0ZXJuaW9uKVxuICAgICAqIHRoaXMgcmV0dXJucyB0aGUgc2FtZSBhcyB0aGUgaW52ZXJzZSBidXQgaXMgZmFzdGVyIHRvIGNhbGN1bGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBxIC0gcXVhdGVybmlvbiB0byBjb21wdXRlIHRoZSBjb25qdWdhdGUgb2YuXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGNvbmp1Z2F0ZSBvZiBxXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uanVnYXRlKHEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gLXFbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IC1xWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSAtcVsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gcVszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gcm90YXRpb24gbWF0cml4LlxuICAgICAqXG4gICAgICogVGhlIGNyZWF0ZWQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtIC0gcm90YXRpb24gbWF0cml4XG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21NYXQobSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICAvKlxuICAgICAgICAwIDEgMlxuICAgICAgICAzIDQgNVxuICAgICAgICA2IDcgOFxuICAgICAgXG4gICAgICAgIDAgMSAyXG4gICAgICAgIDQgNSA2XG4gICAgICAgIDggOSAxMFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgICAgICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgICAgIGNvbnN0IHRyYWNlID0gbVswXSArIG1bNV0gKyBtWzEwXTtcbiAgICAgICAgaWYgKHRyYWNlID4gMC4wKSB7XG4gICAgICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgICAgICBjb25zdCByb290ID0gTWF0aC5zcXJ0KHRyYWNlICsgMSk7IC8vIDJ3XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAwLjUgKiByb290O1xuICAgICAgICAgICAgY29uc3QgaW52Um9vdCA9IDAuNSAvIHJvb3Q7IC8vIDEvKDR3KVxuICAgICAgICAgICAgbmV3RHN0WzBdID0gKG1bNl0gLSBtWzldKSAqIGludlJvb3Q7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAobVs4XSAtIG1bMl0pICogaW52Um9vdDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IChtWzFdIC0gbVs0XSkgKiBpbnZSb290O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgaWYgKG1bNV0gPiBtWzBdKSB7XG4gICAgICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobVsxMF0gPiBtW2kgKiA0ICsgaV0pIHtcbiAgICAgICAgICAgICAgICBpID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGogPSAoaSArIDEpICUgMztcbiAgICAgICAgICAgIGNvbnN0IGsgPSAoaSArIDIpICUgMztcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBNYXRoLnNxcnQobVtpICogNCArIGldIC0gbVtqICogNCArIGpdIC0gbVtrICogNCArIGtdICsgMS4wKTtcbiAgICAgICAgICAgIG5ld0RzdFtpXSA9IDAuNSAqIHJvb3Q7XG4gICAgICAgICAgICBjb25zdCBpbnZSb290ID0gMC41IC8gcm9vdDtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IChtW2ogKiA0ICsga10gLSBtW2sgKiA0ICsgal0pICogaW52Um9vdDtcbiAgICAgICAgICAgIG5ld0RzdFtqXSA9IChtW2ogKiA0ICsgaV0gKyBtW2kgKiA0ICsgal0pICogaW52Um9vdDtcbiAgICAgICAgICAgIG5ld0RzdFtrXSA9IChtW2sgKiA0ICsgaV0gKyBtW2kgKiA0ICsga10pICogaW52Um9vdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiBldWxlciBhbmdsZSB4LCB5LCB6IHVzaW5nIHRoZSBwcm92aWRlZCBpbnRyaW5zaWMgb3JkZXIgZm9yIHRoZSBjb252ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHhBbmdsZUluUmFkaWFucyAtIGFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIHJhZGlhbnMuXG4gICAgICogQHBhcmFtIHlBbmdsZUluUmFkaWFucyAtIGFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWSBheGlzIGluIHJhZGlhbnMuXG4gICAgICogQHBhcmFtIHpBbmdsZUluUmFkaWFucyAtIGFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWiBheGlzIGluIHJhZGlhbnMuXG4gICAgICogQHBhcmFtIG9yZGVyIC0gb3JkZXIgdG8gYXBwbHkgZXVsZXIgYW5nbGVzXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgc2FtZSByb3RhdGlvbiBhcyB0aGUgZXVsZXIgYW5nbGVzIGFwcGxpZWQgaW4gdGhlIGdpdmVuIG9yZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUV1bGVyKHhBbmdsZUluUmFkaWFucywgeUFuZ2xlSW5SYWRpYW5zLCB6QW5nbGVJblJhZGlhbnMsIG9yZGVyLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IHhIYWxmQW5nbGUgPSB4QW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHlIYWxmQW5nbGUgPSB5QW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHpIYWxmQW5nbGUgPSB6QW5nbGVJblJhZGlhbnMgKiAwLjU7XG4gICAgICAgIGNvbnN0IHN4ID0gTWF0aC5zaW4oeEhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGN4ID0gTWF0aC5jb3MoeEhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IHN5ID0gTWF0aC5zaW4oeUhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGN5ID0gTWF0aC5jb3MoeUhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IHN6ID0gTWF0aC5zaW4oekhhbGZBbmdsZSk7XG4gICAgICAgIGNvbnN0IGN6ID0gTWF0aC5jb3MoekhhbGZBbmdsZSk7XG4gICAgICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ3h5eic6XG4gICAgICAgICAgICAgICAgbmV3RHN0WzBdID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IGN4ICogc3kgKiBjeiAtIHN4ICogY3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMl0gPSBjeCAqIGN5ICogc3ogKyBzeCAqIHN5ICogY3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneHp5JzpcbiAgICAgICAgICAgICAgICBuZXdEc3RbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gY3ggKiBzeSAqIGN6IC0gc3ggKiBjeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IGN4ICogY3kgKiBzeiArIHN4ICogc3kgKiBjejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5eHonOlxuICAgICAgICAgICAgICAgIG5ld0RzdFswXSA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSBjeCAqIHN5ICogY3ogLSBzeCAqIGN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3l6eCc6XG4gICAgICAgICAgICAgICAgbmV3RHN0WzBdID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnenh5JzpcbiAgICAgICAgICAgICAgICBuZXdEc3RbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFsyXSA9IGN4ICogY3kgKiBzeiArIHN4ICogc3kgKiBjejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbM10gPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6eXgnOlxuICAgICAgICAgICAgICAgIG5ld0RzdFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XG4gICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICAgICAgICAgICAgICAgIG5ld0RzdFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJvdGF0aW9uIG9yZGVyOiAke29yZGVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIHF1YXRlcm5pb24uIChzYW1lIGFzIHtAbGluayBxdWF0LmNsb25lfSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgcXVhdC5jcmVhdGV9IGFuZCB7QGxpbmsgcXVhdC5zZXR9XG4gICAgICogQHBhcmFtIHEgLSBUaGUgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyBhIGNvcHkgb2YgcVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHkocSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBxWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBxWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBxWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSBxWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYSBxdWF0ZXJuaW9uLiAoc2FtZSBhcyB7QGxpbmsgcXVhdC5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgcXVhdC5jcmVhdGV9IGFuZCB7QGxpbmsgcXVhdC5zZXR9XG4gICAgICogQHBhcmFtIHEgLSBUaGUgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2YgcS5cbiAgICAgKi9cbiAgICBjb25zdCBjbG9uZSA9IGNvcHk7XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gcXVhdGVybmlvbnM7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHF1YXRlcm5pb24gdGhhdCBpcyB0aGUgc3VtIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSArIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICsgYlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSArIGJbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0d28gcXVhdGVybmlvbnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBxdWF0ZXJuaW9uIHRoYXQgaXMgdGhlIGRpZmZlcmVuY2Ugb2YgYSBhbmQgYi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IGFbM10gLSBiWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHF1YXRlcm5pb25zLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCBxdWF0ZXJuaW9uLlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgcXVhdGVybmlvbiB0aGF0IGlzIHRoZSBkaWZmZXJlbmNlIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHF1YXRlcm5pb24gYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bFNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gKiBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdICogaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAqIGs7XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM10gKiBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgcXVhdGVybmlvbiBieSBhIHNjYWxhci4gKHNhbWUgYXMgbXVsU2NhbGFyKVxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGsgLSBUaGUgc2NhbGFyLlxuICAgICAqIEBwYXJhbSBkc3QgLSBxdWF0ZXJuaW9uIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG11bFNjYWxhcjtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gayAtIFRoZSBzY2FsYXIuXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNjYWxlZCBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpdlNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gLyBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdIC8gaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAvIGs7XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM10gLyBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXRlcm5pb25zXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHJldHVybnMgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb3QoYSwgYikge1xuICAgICAgICByZXR1cm4gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYlsxXSkgKyAoYVsyXSAqIGJbMl0pICsgKGFbM10gKiBiWzNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gb24gdHdvIHF1YXRlcm5pb25zLlxuICAgICAqIEdpdmVuIHF1YXRlcm5pb25zIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gY29lZmZpY2llbnQuXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdCAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHQgKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgdCAqIChiWzNdIC0gYVszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsZW5ndGggb2YgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSB2IC0gcXVhdGVybmlvbi5cbiAgICAgKiBAcmV0dXJucyBsZW5ndGggb2YgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGgodikge1xuICAgICAgICBjb25zdCB2MCA9IHZbMF07XG4gICAgICAgIGNvbnN0IHYxID0gdlsxXTtcbiAgICAgICAgY29uc3QgdjIgPSB2WzJdO1xuICAgICAgICBjb25zdCB2MyA9IHZbM107XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodjAgKiB2MCArIHYxICogdjEgKyB2MiAqIHYyICsgdjMgKiB2Myk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBsZW5ndGggb2YgcXVhdGVybmlvbiAoc2FtZSBhcyBsZW5ndGgpXG4gICAgICogQHBhcmFtIHYgLSBxdWF0ZXJuaW9uLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGNvbnN0IGxlbiA9IGxlbmd0aDtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSB2IC0gcXVhdGVybmlvbi5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlbmd0aFNxKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgdjMgPSB2WzNdO1xuICAgICAgICByZXR1cm4gdjAgKiB2MCArIHYxICogdjEgKyB2MiAqIHYyICsgdjMgKiB2MztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHF1YXRlcm5pb24gKHNhbWUgYXMgbGVuZ3RoU3EpXG4gICAgICogQHBhcmFtIHYgLSBxdWF0ZXJuaW9uLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgY29uc3QgbGVuU3EgPSBsZW5ndGhTcTtcbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgcXVhdGVybmlvbiBieSBpdHMgRXVjbGlkZWFuIGxlbmd0aCBhbmQgcmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHYzID0gdlszXTtcbiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjMpO1xuICAgICAgICBpZiAobGVuID4gMC4wMDAwMSkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gdjAgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSB2MSAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IHYyIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gdjMgLyBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIDIgcXVhdGVybmlvbnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgcXVhdGVybmlvbi5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHF1YXRlcm5pb25zIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxzQXBwcm94aW1hdGVseShhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhWzBdIC0gYlswXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzFdIC0gYlsxXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzJdIC0gYlsyXSkgPCBFUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhWzNdIC0gYlszXSkgPCBFUFNJTE9OO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiAyIHF1YXRlcm5pb25zIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHF1YXRlcm5pb24uXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBxdWF0ZXJuaW9ucyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGlkZW50aXR5IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gZHN0IC0gcXVhdGVybmlvbiB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBhbiBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAxO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICBjb25zdCB0ZW1wVmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgeFVuaXRWZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB5VW5pdFZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lIHZlY3RvciB0byBhbm90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFVbml0IC0gdGhlIHN0YXJ0IHZlY3RvclxuICAgICAqIEBwYXJhbSBiVW5pdCAtIHRoZSBlbmQgdmVjdG9yXG4gICAgICogQHBhcmFtIGRzdCAtIHF1YXRlcm5pb24gdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uVG8oYVVuaXQsIGJVbml0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHZlYzMuZG90KGFVbml0LCBiVW5pdCk7XG4gICAgICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3MoeFVuaXRWZWMzLCBhVW5pdCwgdGVtcFZlYzMpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuKHRlbXBWZWMzKSA8IDAuMDAwMDAxKSB7XG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh5VW5pdFZlYzMsIGFVbml0LCB0ZW1wVmVjMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0ZW1wVmVjMywgdGVtcFZlYzMpO1xuICAgICAgICAgICAgZnJvbUF4aXNBbmdsZSh0ZW1wVmVjMywgTWF0aC5QSSwgbmV3RHN0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzJdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyhhVW5pdCwgYlVuaXQsIHRlbXBWZWMzKTtcbiAgICAgICAgICAgIG5ld0RzdFswXSA9IHRlbXBWZWMzWzBdO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gdGVtcFZlYzNbMV07XG4gICAgICAgICAgICBuZXdEc3RbMl0gPSB0ZW1wVmVjM1syXTtcbiAgICAgICAgICAgIG5ld0RzdFszXSA9IDEgKyBkb3Q7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5ld0RzdCwgbmV3RHN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wUXVhdDEgPSBuZXcgQ3Rvcig0KTtcbiAgICBjb25zdCB0ZW1wUXVhdDIgPSBuZXcgQ3Rvcig0KTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIGEgLSB0aGUgZmlyc3QgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBiIC0gdGhlIHNlY29uZCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIGMgLSB0aGUgdGhpcmQgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBkIC0gdGhlIGZvdXJ0aCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50IDAgdG8gMVxuICAgICAqIEByZXR1cm5zIHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNxbGVycChhLCBiLCBjLCBkLCB0LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIHNsZXJwKGEsIGQsIHQsIHRlbXBRdWF0MSk7XG4gICAgICAgIHNsZXJwKGIsIGMsIHQsIHRlbXBRdWF0Mik7XG4gICAgICAgIHNsZXJwKHRlbXBRdWF0MSwgdGVtcFF1YXQyLCAyICogdCAqICgxIC0gdCksIG5ld0RzdCk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgZnJvbVZhbHVlcyxcbiAgICAgICAgc2V0LFxuICAgICAgICBmcm9tQXhpc0FuZ2xlLFxuICAgICAgICB0b0F4aXNBbmdsZSxcbiAgICAgICAgYW5nbGUsXG4gICAgICAgIG11bHRpcGx5LFxuICAgICAgICBtdWwsXG4gICAgICAgIHJvdGF0ZVgsXG4gICAgICAgIHJvdGF0ZVksXG4gICAgICAgIHJvdGF0ZVosXG4gICAgICAgIHNsZXJwLFxuICAgICAgICBpbnZlcnNlLFxuICAgICAgICBjb25qdWdhdGUsXG4gICAgICAgIGZyb21NYXQsXG4gICAgICAgIGZyb21FdWxlcixcbiAgICAgICAgY29weSxcbiAgICAgICAgY2xvbmUsXG4gICAgICAgIGFkZCxcbiAgICAgICAgc3VidHJhY3QsXG4gICAgICAgIHN1YixcbiAgICAgICAgbXVsU2NhbGFyLFxuICAgICAgICBzY2FsZSxcbiAgICAgICAgZGl2U2NhbGFyLFxuICAgICAgICBkb3QsXG4gICAgICAgIGxlcnAsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbGVuLFxuICAgICAgICBsZW5ndGhTcSxcbiAgICAgICAgbGVuU3EsXG4gICAgICAgIG5vcm1hbGl6ZSxcbiAgICAgICAgZXF1YWxzQXBwcm94aW1hdGVseSxcbiAgICAgICAgZXF1YWxzLFxuICAgICAgICBpZGVudGl0eSxcbiAgICAgICAgcm90YXRpb25UbyxcbiAgICAgICAgc3FsZXJwLFxuICAgIH07XG59XG5jb25zdCBjYWNoZSQxID0gbmV3IE1hcCgpO1xuLyoqXG4gKlxuICogUXVhdDQgbWF0aCBmdW5jdGlvbnMuXG4gKlxuICogQWxtb3N0IGFsbCBmdW5jdGlvbnMgdGFrZSBhbiBvcHRpb25hbCBgbmV3RHN0YCBhcmd1bWVudC4gSWYgaXQgaXMgbm90IHBhc3NlZCBpbiB0aGVcbiAqIGZ1bmN0aW9ucyB3aWxsIGNyZWF0ZSBhIG5ldyBgUXVhdDRgLiBJbiBvdGhlciB3b3JkcyB5b3UgY2FuIGRvIHRoaXNcbiAqXG4gKiAgICAgY29uc3QgdiA9IHF1YXQ0LmNyb3NzKHYxLCB2Mik7ICAvLyBDcmVhdGVzIGEgbmV3IFF1YXQ0IHdpdGggdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2Mi5cbiAqXG4gKiBvclxuICpcbiAqICAgICBjb25zdCB2ID0gcXVhdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQuY3Jvc3ModjEsIHYyLCB2KTsgIC8vIFB1dHMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2MiBpbiB2XG4gKlxuICogVGhlIGZpcnN0IHN0eWxlIGlzIG9mdGVuIGVhc2llciBidXQgZGVwZW5kaW5nIG9uIHdoZXJlIGl0J3MgdXNlZCBpdCBnZW5lcmF0ZXMgZ2FyYmFnZSB3aGVyZVxuICogYXMgdGhlcmUgaXMgYWxtb3N0IG5ldmVyIGFsbG9jYXRpb24gd2l0aCB0aGUgc2Vjb25kIHN0eWxlLlxuICpcbiAqIEl0IGlzIGFsd2F5cyBzYWZlIHRvIHBhc3MgYW55IHZlY3RvciBhcyB0aGUgZGVzdGluYXRpb24uIFNvIGZvciBleGFtcGxlXG4gKlxuICogICAgIHF1YXQ0LmNyb3NzKHYxLCB2MiwgdjEpOyAgLy8gUHV0cyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2MSB4IHYyIGluIHYxXG4gKlxuICovXG5mdW5jdGlvbiBnZXRBUEkkMShDdG9yKSB7XG4gICAgbGV0IGFwaSA9IGNhY2hlJDEuZ2V0KEN0b3IpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICAgIGFwaSA9IGdldEFQSUltcGwkMShDdG9yKTtcbiAgICAgICAgY2FjaGUkMS5zZXQoQ3RvciwgYXBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaTtcbn1cblxuLypcbiAqIENvcHlyaWdodCAyMDIyIEdyZWdnIFRhdmFyZXNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW0gdHlwZWQgQVBJIGZvciBWZWM0XG4gKiAqL1xuZnVuY3Rpb24gZ2V0QVBJSW1wbChDdG9yKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHZlYzQ7IG1heSBiZSBjYWxsZWQgd2l0aCB4LCB5LCB6IHRvIHNldCBpbml0aWFsIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geCAtIEluaXRpYWwgeCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geSAtIEluaXRpYWwgeSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geiAtIEluaXRpYWwgeiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gdyAtIEluaXRpYWwgdyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3JlYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoeCwgeSwgeiwgdykge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSBuZXcgQ3Rvcig0KTtcbiAgICAgICAgaWYgKHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0geDtcbiAgICAgICAgICAgIGlmICh5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICAgICAgICAgIGlmICh6ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzJdID0gejtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RHN0WzNdID0gdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdmVjNDsgbWF5IGJlIGNhbGxlZCB3aXRoIHgsIHksIHogdG8gc2V0IGluaXRpYWwgdmFsdWVzLiAoc2FtZSBhcyBjcmVhdGUpXG4gICAgICogQHBhcmFtIHggLSBJbml0aWFsIHggdmFsdWUuXG4gICAgICogQHBhcmFtIHkgLSBJbml0aWFsIHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHogdmFsdWUuXG4gICAgICogQHBhcmFtIHogLSBJbml0aWFsIHcgdmFsdWUuXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgdmVjdG9yXG4gICAgICovXG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgYSBWZWM0XG4gICAgICogQWxzbyBzZWUge0BsaW5rIHZlYzQuY3JlYXRlfSBhbmQge0BsaW5rIHZlYzQuY29weX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IGZpcnN0IHZhbHVlXG4gICAgICogQHBhcmFtIHkgc2Vjb25kIHZhbHVlXG4gICAgICogQHBhcmFtIHogdGhpcmQgdmFsdWVcbiAgICAgKiBAcGFyYW0gdyBmb3VydGggdmFsdWVcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHdpdGggaXRzIGVsZW1lbnRzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgdywgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSB4O1xuICAgICAgICBuZXdEc3RbMV0gPSB5O1xuICAgICAgICBuZXdEc3RbMl0gPSB6O1xuICAgICAgICBuZXdEc3RbM10gPSB3O1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGguY2VpbCB0byBlYWNoIGVsZW1lbnQgb2YgdmVjdG9yXG4gICAgICogQHBhcmFtIHYgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIGNlaWwgb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2VpbCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGguY2VpbCh2WzBdKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5jZWlsKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLmNlaWwodlsyXSk7XG4gICAgICAgIG5ld0RzdFszXSA9IE1hdGguY2VpbCh2WzNdKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBNYXRoLmZsb29yIHRvIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZmxvb3Igb2YgZWFjaCBlbGVtZW50IG9mIHYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxvb3IodiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBNYXRoLmZsb29yKHZbMF0pO1xuICAgICAgICBuZXdEc3RbMV0gPSBNYXRoLmZsb29yKHZbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLmZsb29yKHZbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBNYXRoLmZsb29yKHZbM10pO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hdGgucm91bmQgdG8gZWFjaCBlbGVtZW50IG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSByb3VuZCBvZiBlYWNoIGVsZW1lbnQgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZCh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IE1hdGgucm91bmQodlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgucm91bmQodlsxXSk7XG4gICAgICAgIG5ld0RzdFsyXSA9IE1hdGgucm91bmQodlsyXSk7XG4gICAgICAgIG5ld0RzdFszXSA9IE1hdGgucm91bmQodlszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wIGVhY2ggZWxlbWVudCBvZiB2ZWN0b3IgYmV0d2VlbiBtaW4gYW5kIG1heFxuICAgICAqIEBwYXJhbSB2IC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIG1heCAtIE1pbiB2YWx1ZSwgZGVmYXVsdCAwXG4gICAgICogQHBhcmFtIG1pbiAtIE1heCB2YWx1ZSwgZGVmYXVsdCAxXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IHRoZSBjbGFtcGVkIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBvZiB2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKHYsIG1pbiA9IDAsIG1heCA9IDEsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMF0pKTtcbiAgICAgICAgbmV3RHN0WzFdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMV0pKTtcbiAgICAgICAgbmV3RHN0WzJdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbMl0pKTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZbM10pKTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gdmVjdG9yczsgYXNzdW1lcyBhIGFuZCBiIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gKyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIGJbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IGFbM10gKyBiWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byB2ZWN0b3JzLCBzY2FsaW5nIHRoZSAybmQ7IGFzc3VtZXMgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHNjYWxlIC0gQW1vdW50IHRvIHNjYWxlIGJcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIEEgdmVjdG9yIHRoYXQgaXMgdGhlIHN1bSBvZiBhICsgYiAqIHNjYWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFNjYWxlZChhLCBiLCBzY2FsZSwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdHdvIHZlY3RvcnMuXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgdGhhdCBpcyB0aGUgZGlmZmVyZW5jZSBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gYVswXSAtIGJbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gYVszXSAtIGJbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0d28gdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciB0aGF0IGlzIHRoZSBkaWZmZXJlbmNlIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiB2ZWN0b3JzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdmVjdG9ycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsc0FwcHJveGltYXRlbHkoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYVswXSAtIGJbMF0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsxXSAtIGJbMV0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVsyXSAtIGJbMl0pIDwgRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYVszXSAtIGJbM10pIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgMiB2ZWN0b3JzIGFyZSBleGFjdGx5IGVxdWFsXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdmVjdG9ycyBhcmUgZXhhY3RseSBlcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvbiB0d28gdmVjdG9ycy5cbiAgICAgKiBHaXZlbiB2ZWN0b3JzIGEgYW5kIGIgYW5kIGludGVycG9sYXRpb24gY29lZmZpY2llbnQgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50LlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGxpbmVhciBpbnRlcnBvbGF0ZWQgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdCAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0ICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHQgKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgdCAqIChiWzNdIC0gYVszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9uIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiBhbmQgaW50ZXJwb2xhdGlvbiBjb2VmZmljaWVudCB2ZWN0b3IgdCwgcmV0dXJuc1xuICAgICAqIGEgKyB0ICogKGIgLSBhKS5cbiAgICAgKiBAcGFyYW0gYSAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGNvZWZmaWNpZW50cyB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgbGluZWFyIGludGVycG9sYXRlZCByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVycFYoYSwgYiwgdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICsgdFswXSAqIChiWzBdIC0gYVswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IGFbMV0gKyB0WzFdICogKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSArIHRbMl0gKiAoYlsyXSAtIGFbMl0pO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICsgdFszXSAqIChiWzNdIC0gYVszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBtYXggdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gICAgICogW21heChhWzBdLCBiWzBdKSwgbWF4KGFbMV0sIGJbMV0pLCBtYXgoYVsyXSwgYlsyXSldLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXggY29tcG9uZW50cyB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBtaW4gdmFsdWVzIG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEdpdmVuIHZlY3RvcnMgYSBhbmQgYiByZXR1cm5zXG4gICAgICogW21pbihhWzBdLCBiWzBdKSwgbWluKGFbMV0sIGJbMV0pLCBtaW4oYVsyXSwgYlsyXSldLlxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBtaW4gY29tcG9uZW50cyB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGEsIGIsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgICAgIG5ld0RzdFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgICAgICBuZXdEc3RbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICAgICAgbmV3RHN0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG11bFNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gKiBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdICogaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAqIGs7XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM10gKiBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLiAoc2FtZSBhcyBtdWxTY2FsYXIpXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IHNjYWxlID0gbXVsU2NhbGFyO1xuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBrIC0gVGhlIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBzY2FsZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpdlNjYWxhcih2LCBrLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IHZbMF0gLyBrO1xuICAgICAgICBuZXdEc3RbMV0gPSB2WzFdIC8gaztcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXSAvIGs7XG4gICAgICAgIG5ld0RzdFszXSA9IHZbM10gLyBrO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIGEgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2IC0gVGhlIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnZlcnRlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJzZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IDEgLyB2WzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSAxIC8gdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gMSAvIHZbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IDEgLyB2WzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgYSB2ZWN0b3IuIChzYW1lIGFzIGludmVyc2UpXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIGludmVydGVkIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBpbnZlcnQgPSBpbnZlcnNlO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYVswXSAqIGJbMF0pICsgKGFbMV0gKiBiWzFdKSArIChhWzJdICogYlsyXSkgKyAoYVszXSAqIGJbM10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGxlbmd0aCBvZiB2ZWN0b3IuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2WzBdO1xuICAgICAgICBjb25zdCB2MSA9IHZbMV07XG4gICAgICAgIGNvbnN0IHYyID0gdlsyXTtcbiAgICAgICAgY29uc3QgdjMgPSB2WzNdO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbGVuZ3RoIG9mIHZlY3RvciAoc2FtZSBhcyBsZW5ndGgpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdCBsZW4gPSBsZW5ndGg7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3RvclxuICAgICAqIEBwYXJhbSB2IC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIHNxdWFyZSBvZiB0aGUgbGVuZ3RoIG9mIHZlY3Rvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZW5ndGhTcSh2KSB7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHYzID0gdlszXTtcbiAgICAgICAgcmV0dXJuIHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGxlbmd0aCBvZiB2ZWN0b3IgKHNhbWUgYXMgbGVuZ3RoU3EpXG4gICAgICogQHBhcmFtIHYgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBsZW5ndGggb2YgdmVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0IGxlblNxID0gbGVuZ3RoU3E7XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGNvbnN0IGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIGNvbnN0IGR6ID0gYVsyXSAtIGJbMl07XG4gICAgICAgIGNvbnN0IGR3ID0gYVszXSAtIGJbM107XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6ICsgZHcgKiBkdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzIChzYW1lIGFzIGRpc3RhbmNlKVxuICAgICAqIEBwYXJhbSBhIC0gdmVjdG9yLlxuICAgICAqIEBwYXJhbSBiIC0gdmVjdG9yLlxuICAgICAqIEByZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGNvbnN0IGRpc3QgPSBkaXN0YW5jZTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG4gICAgICogQHBhcmFtIGEgLSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSB2ZWN0b3IuXG4gICAgICogQHJldHVybnMgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXN0YW5jZVNxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgZHggPSBhWzBdIC0gYlswXTtcbiAgICAgICAgY29uc3QgZHkgPSBhWzFdIC0gYlsxXTtcbiAgICAgICAgY29uc3QgZHogPSBhWzJdIC0gYlsyXTtcbiAgICAgICAgY29uc3QgZHcgPSBhWzNdIC0gYlszXTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeiArIGR3ICogZHc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgKHNhbWUgYXMgZGlzdGFuY2VTcSlcbiAgICAgKiBAcGFyYW0gYSAtIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIHZlY3Rvci5cbiAgICAgKiBAcmV0dXJucyBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICAgICAqL1xuICAgIGNvbnN0IGRpc3RTcSA9IGRpc3RhbmNlU3E7XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgRXVjbGlkZWFuIGxlbmd0aCBhbmQgcmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IHYwID0gdlswXTtcbiAgICAgICAgY29uc3QgdjEgPSB2WzFdO1xuICAgICAgICBjb25zdCB2MiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHYzID0gdlszXTtcbiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5zcXJ0KHYwICogdjAgKyB2MSAqIHYxICsgdjIgKiB2MiArIHYzICogdjMpO1xuICAgICAgICBpZiAobGVuID4gMC4wMDAwMSkge1xuICAgICAgICAgICAgbmV3RHN0WzBdID0gdjAgLyBsZW47XG4gICAgICAgICAgICBuZXdEc3RbMV0gPSB2MSAvIGxlbjtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IHYyIC8gbGVuO1xuICAgICAgICAgICAgbmV3RHN0WzNdID0gdjMgLyBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICAgICAgbmV3RHN0WzFdID0gMDtcbiAgICAgICAgICAgIG5ld0RzdFsyXSA9IDA7XG4gICAgICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgYSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgLXYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gLXZbMF07XG4gICAgICAgIG5ld0RzdFsxXSA9IC12WzFdO1xuICAgICAgICBuZXdEc3RbMl0gPSAtdlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gLXZbM107XG4gICAgICAgIHJldHVybiBuZXdEc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhIHZlY3Rvci4gKHNhbWUgYXMge0BsaW5rIHZlYzQuY2xvbmV9KVxuICAgICAqIEFsc28gc2VlIHtAbGluayB2ZWM0LmNyZWF0ZX0gYW5kIHtAbGluayB2ZWM0LnNldH1cbiAgICAgKiBAcGFyYW0gdiAtIFRoZSB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGRzdCAtIHZlY3RvciB0byBob2xkIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBpbiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyBBIGNvcHkgb2Ygdi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5KHYsIGRzdCkge1xuICAgICAgICBjb25zdCBuZXdEc3QgPSAoZHN0ID8/IG5ldyBDdG9yKDQpKTtcbiAgICAgICAgbmV3RHN0WzBdID0gdlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gdlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gdlsyXTtcbiAgICAgICAgbmV3RHN0WzNdID0gdlszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGEgdmVjdG9yLiAoc2FtZSBhcyB7QGxpbmsgdmVjNC5jb3B5fSlcbiAgICAgKiBBbHNvIHNlZSB7QGxpbmsgdmVjNC5jcmVhdGV9IGFuZCB7QGxpbmsgdmVjNC5zZXR9XG4gICAgICogQHBhcmFtIHYgLSBUaGUgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgQSBjb3B5IG9mIHYuXG4gICAgICovXG4gICAgY29uc3QgY2xvbmUgPSBjb3B5O1xuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBwcm9kdWN0cyBvZiBlbnRyaWVzIG9mIGEgYW5kIGIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSBhWzBdICogYlswXTtcbiAgICAgICAgbmV3RHN0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgICAgIG5ld0RzdFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgICAgICBuZXdEc3RbM10gPSBhWzNdICogYlszXTtcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhbm90aGVyIHZlY3RvciAoY29tcG9uZW50LXdpc2UpOyBhc3N1bWVzIGEgYW5kXG4gICAgICogYiBoYXZlIHRoZSBzYW1lIGxlbmd0aC4gKHNhbWUgYXMgbXVsKVxuICAgICAqIEBwYXJhbSBhIC0gT3BlcmFuZCB2ZWN0b3IuXG4gICAgICogQHBhcmFtIGIgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3Igb2YgcHJvZHVjdHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IG11bCA9IG11bHRpcGx5O1xuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciB2ZWN0b3IgKGNvbXBvbmVudC13aXNlKTsgYXNzdW1lcyBhIGFuZFxuICAgICAqIGIgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpdmlkZShhLCBiLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5ld0RzdFswXSA9IGFbMF0gLyBiWzBdO1xuICAgICAgICBuZXdEc3RbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICAgICAgbmV3RHN0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgICAgIG5ld0RzdFszXSA9IGFbM10gLyBiWzNdO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yIChjb21wb25lbnQtd2lzZSk7IGFzc3VtZXMgYSBhbmRcbiAgICAgKiBiIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiAoc2FtZSBhcyBkaXZpZGUpXG4gICAgICogQHBhcmFtIGEgLSBPcGVyYW5kIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYiAtIE9wZXJhbmQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSBkc3QgLSB2ZWN0b3IgdG8gaG9sZCByZXN1bHQuIElmIG5vdCBwYXNzZWQgaW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHZlY3RvciBvZiBxdW90aWVudHMgb2YgZW50cmllcyBvZiBhIGFuZCBiLlxuICAgICAqL1xuICAgIGNvbnN0IGRpdiA9IGRpdmlkZTtcbiAgICAvKipcbiAgICAgKiBaZXJvJ3MgYSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gZHN0IC0gdmVjdG9yIHRvIGhvbGQgcmVzdWx0LiBJZiBub3QgcGFzc2VkIGluIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSB6ZXJvZWQgdmVjdG9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm8oZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBuZXdEc3RbMF0gPSAwO1xuICAgICAgICBuZXdEc3RbMV0gPSAwO1xuICAgICAgICBuZXdEc3RbMl0gPSAwO1xuICAgICAgICBuZXdEc3RbM10gPSAwO1xuICAgICAgICByZXR1cm4gbmV3RHN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gdmVjNCBieSA0eDQgbWF0cml4XG4gICAgICogQHBhcmFtIHYgLSB0aGUgdmVjdG9yXG4gICAgICogQHBhcmFtIG0gLSBUaGUgbWF0cml4LlxuICAgICAqIEBwYXJhbSBkc3QgLSBvcHRpb25hbCB2ZWM0IHRvIHN0b3JlIHJlc3VsdC4gSWYgbm90IHBhc3NlZCBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgdmVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NCh2LCBtLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdO1xuICAgICAgICBjb25zdCB5ID0gdlsxXTtcbiAgICAgICAgY29uc3QgeiA9IHZbMl07XG4gICAgICAgIGNvbnN0IHcgPSB2WzNdO1xuICAgICAgICBuZXdEc3RbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gICAgICAgIG5ld0RzdFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICAgICAgbmV3RHN0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgICAgICAgbmV3RHN0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgICAgICAgcmV0dXJuIG5ld0RzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJlYXQgYSA0RCB2ZWN0b3IgYXMgYSBkaXJlY3Rpb24gYW5kIHNldCBpdCdzIGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzQgdG8gbGVuZ3RoZW5cbiAgICAgKiBAcGFyYW0gbGVuIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoZW5lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRMZW5ndGgoYSwgbGVuLCBkc3QpIHtcbiAgICAgICAgY29uc3QgbmV3RHN0ID0gKGRzdCA/PyBuZXcgQ3Rvcig0KSk7XG4gICAgICAgIG5vcm1hbGl6ZShhLCBuZXdEc3QpO1xuICAgICAgICByZXR1cm4gbXVsU2NhbGFyKG5ld0RzdCwgbGVuLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYSB2ZWN0b3IgaXMgbm90IGxvbmdlciB0aGFuIGEgbWF4IGxlbmd0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIHZlYzQgdG8gbGltaXRcbiAgICAgKiBAcGFyYW0gbWF4TGVuIFRoZSBsb25nZXN0IGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3RvclxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IsIHNob3J0ZW5lZCB0byBtYXhMZW4gaWYgaXQncyB0b28gbG9uZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKGEsIG1heExlbiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICBpZiAobGVuZ3RoKGEpID4gbWF4TGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0TGVuZ3RoKGEsIG1heExlbiwgbmV3RHN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weShhLCBuZXdEc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZlY3RvciBleGFjdGx5IGJldHdlZW4gMiBlbmRwb2ludCB2ZWN0b3JzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSBFbmRwb2ludCAxXG4gICAgICogQHBhcmFtIGIgRW5kcG9pbnQgMlxuICAgICAqIEByZXR1cm5zIFRoZSB2ZWN0b3IgZXhhY3RseSByZXNpZGluZyBiZXR3ZWVuIGVuZHBvaW50cyAxIGFuZCAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWlkcG9pbnQoYSwgYiwgZHN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0RzdCA9IChkc3QgPz8gbmV3IEN0b3IoNCkpO1xuICAgICAgICByZXR1cm4gbGVycChhLCBiLCAwLjUsIG5ld0RzdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgZnJvbVZhbHVlcyxcbiAgICAgICAgc2V0LFxuICAgICAgICBjZWlsLFxuICAgICAgICBmbG9vcixcbiAgICAgICAgcm91bmQsXG4gICAgICAgIGNsYW1wLFxuICAgICAgICBhZGQsXG4gICAgICAgIGFkZFNjYWxlZCxcbiAgICAgICAgc3VidHJhY3QsXG4gICAgICAgIHN1YixcbiAgICAgICAgZXF1YWxzQXBwcm94aW1hdGVseSxcbiAgICAgICAgZXF1YWxzLFxuICAgICAgICBsZXJwLFxuICAgICAgICBsZXJwVixcbiAgICAgICAgbWF4LFxuICAgICAgICBtaW4sXG4gICAgICAgIG11bFNjYWxhcixcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIGRpdlNjYWxhcixcbiAgICAgICAgaW52ZXJzZSxcbiAgICAgICAgaW52ZXJ0LFxuICAgICAgICBkb3QsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbGVuLFxuICAgICAgICBsZW5ndGhTcSxcbiAgICAgICAgbGVuU3EsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBkaXN0LFxuICAgICAgICBkaXN0YW5jZVNxLFxuICAgICAgICBkaXN0U3EsXG4gICAgICAgIG5vcm1hbGl6ZSxcbiAgICAgICAgbmVnYXRlLFxuICAgICAgICBjb3B5LFxuICAgICAgICBjbG9uZSxcbiAgICAgICAgbXVsdGlwbHksXG4gICAgICAgIG11bCxcbiAgICAgICAgZGl2aWRlLFxuICAgICAgICBkaXYsXG4gICAgICAgIHplcm8sXG4gICAgICAgIHRyYW5zZm9ybU1hdDQsXG4gICAgICAgIHNldExlbmd0aCxcbiAgICAgICAgdHJ1bmNhdGUsXG4gICAgICAgIG1pZHBvaW50LFxuICAgIH07XG59XG5jb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbi8qKlxuICpcbiAqIFZlYzQgbWF0aCBmdW5jdGlvbnMuXG4gKlxuICogQWxtb3N0IGFsbCBmdW5jdGlvbnMgdGFrZSBhbiBvcHRpb25hbCBgbmV3RHN0YCBhcmd1bWVudC4gSWYgaXQgaXMgbm90IHBhc3NlZCBpbiB0aGVcbiAqIGZ1bmN0aW9ucyB3aWxsIGNyZWF0ZSBhIG5ldyBgVmVjNGAuIEluIG90aGVyIHdvcmRzIHlvdSBjYW4gZG8gdGhpc1xuICpcbiAqICAgICBjb25zdCB2ID0gdmVjNC5jcm9zcyh2MSwgdjIpOyAgLy8gQ3JlYXRlcyBhIG5ldyBWZWM0IHdpdGggdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdjEgeCB2Mi5cbiAqXG4gKiBvclxuICpcbiAqICAgICBjb25zdCB2ID0gdmVjNC5jcmVhdGUoKTtcbiAqICAgICB2ZWM0LmNyb3NzKHYxLCB2Miwgdik7ICAvLyBQdXRzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHYxIHggdjIgaW4gdlxuICpcbiAqIFRoZSBmaXJzdCBzdHlsZSBpcyBvZnRlbiBlYXNpZXIgYnV0IGRlcGVuZGluZyBvbiB3aGVyZSBpdCdzIHVzZWQgaXQgZ2VuZXJhdGVzIGdhcmJhZ2Ugd2hlcmVcbiAqIGFzIHRoZXJlIGlzIGFsbW9zdCBuZXZlciBhbGxvY2F0aW9uIHdpdGggdGhlIHNlY29uZCBzdHlsZS5cbiAqXG4gKiBJdCBpcyBhbHdheXMgc2FmZSB0byBwYXNzIGFueSB2ZWN0b3IgYXMgdGhlIGRlc3RpbmF0aW9uLiBTbyBmb3IgZXhhbXBsZVxuICpcbiAqICAgICB2ZWM0LmNyb3NzKHYxLCB2MiwgdjEpOyAgLy8gUHV0cyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2MSB4IHYyIGluIHYxXG4gKlxuICovXG5mdW5jdGlvbiBnZXRBUEkoQ3Rvcikge1xuICAgIGxldCBhcGkgPSBjYWNoZS5nZXQoQ3Rvcik7XG4gICAgaWYgKCFhcGkpIHtcbiAgICAgICAgYXBpID0gZ2V0QVBJSW1wbChDdG9yKTtcbiAgICAgICAgY2FjaGUuc2V0KEN0b3IsIGFwaSk7XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgd2dwdS1tYXRyaXggQVBJIGZvciB0eXBlXG4gKi9cbmZ1bmN0aW9uIHdncHVNYXRyaXhBUEkoTWF0M0N0b3IsIE1hdDRDdG9yLCBRdWF0Q3RvciwgVmVjMkN0b3IsIFZlYzNDdG9yLCBWZWM0Q3Rvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKiBAbmFtZXNwYWNlIG1hdDQgKi9cbiAgICAgICAgbWF0NDogZ2V0QVBJJDIoTWF0M0N0b3IpLFxuICAgICAgICAvKiogQG5hbWVzcGFjZSBtYXQzICovXG4gICAgICAgIG1hdDM6IGdldEFQSSQ0KE1hdDRDdG9yKSxcbiAgICAgICAgLyoqIEBuYW1lc3BhY2UgcXVhdCAqL1xuICAgICAgICBxdWF0OiBnZXRBUEkkMShRdWF0Q3RvciksXG4gICAgICAgIC8qKiBAbmFtZXNwYWNlIHZlYzIgKi9cbiAgICAgICAgdmVjMjogZ2V0QVBJJDUoVmVjMkN0b3IpLFxuICAgICAgICAvKiogQG5hbWVzcGFjZSB2ZWMzICovXG4gICAgICAgIHZlYzM6IGdldEFQSSQzKFZlYzNDdG9yKSxcbiAgICAgICAgLyoqIEBuYW1lc3BhY2UgdmVjNCAqL1xuICAgICAgICB2ZWM0OiBnZXRBUEkoVmVjNEN0b3IpLFxuICAgIH07XG59XG5jb25zdCB7IFxuLyoqIEBuYW1lc3BhY2UgKi9cbm1hdDQsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbm1hdDMsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnF1YXQsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzIsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzMsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzQsIH0gPSB3Z3B1TWF0cml4QVBJKEZsb2F0MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDMyQXJyYXkpO1xuY29uc3QgeyBcbi8qKiBAbmFtZXNwYWNlICovXG5tYXQ0OiBtYXQ0ZCwgXG4vKiogQG5hbWVzcGFjZSAqL1xubWF0MzogbWF0M2QsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnF1YXQ6IHF1YXRkLCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWMyOiB2ZWMyZCwgXG4vKiogQG5hbWVzcGFjZSAqL1xudmVjMzogdmVjM2QsIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzQ6IHZlYzRkLCB9ID0gd2dwdU1hdHJpeEFQSShGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheSwgRmxvYXQ2NEFycmF5LCBGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheSwgRmxvYXQ2NEFycmF5KTtcbmNvbnN0IHsgXG4vKiogQG5hbWVzcGFjZSAqL1xubWF0NDogbWF0NG4sIFxuLyoqIEBuYW1lc3BhY2UgKi9cbm1hdDM6IG1hdDNuLCBcbi8qKiBAbmFtZXNwYWNlICovXG5xdWF0OiBxdWF0biwgXG4vKiogQG5hbWVzcGFjZSAqL1xudmVjMjogdmVjMm4sIFxuLyoqIEBuYW1lc3BhY2UgKi9cbnZlYzM6IHZlYzNuLCBcbi8qKiBAbmFtZXNwYWNlICovXG52ZWM0OiB2ZWM0biwgfSA9IHdncHVNYXRyaXhBUEkoWmVyb0FycmF5LCBBcnJheSwgQXJyYXksIEFycmF5LCBBcnJheSwgQXJyYXkpO1xuXG5leHBvcnQgeyBtYXQzLCBtYXQzZCwgbWF0M24sIG1hdDQsIG1hdDRkLCBtYXQ0biwgcXVhdCwgcXVhdGQsIHF1YXRuLCB1dGlscywgdmVjMiwgdmVjMmQsIHZlYzJuLCB2ZWMzLCB2ZWMzZCwgdmVjM24sIHZlYzQsIHZlYzRkLCB2ZWM0biB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2dwdS1tYXRyaXgubW9kdWxlLmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgUmVuZGVyZXIgZnJvbSBcIkAvcmVuZGVyZXJcIjtcclxuY29uc3QgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcclxuXHJcbnRyeSB7XHJcbiAgcmVuZGVyZXIucmVuZGVyKCk7XHJcbn0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9